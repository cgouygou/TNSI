{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cours de Terminale NSI - M. Gouygou \u2693\ufe0e Lien vers le site de Premi\u00e8re. Programme Progression Liens utiles Sources L\u00e9gende du site Le programme de terminale NSI est articul\u00e9 autour de cinq th\u00e8mes. Nous traiterons les diff\u00e9rentes entr\u00e9es du programme dans les chapitres suivants, o\u00f9 la mention \u2192 BAC indique les chapitres pouvant \u00eatre \u00e9valu\u00e9s lors de l'\u00e9preuve \u00e9crite terminale de mars 2023. Th\u00e8me 1 Th\u00e8me 2 Th\u00e8me 3 Th\u00e8me 4 Th\u00e8me 5 Th\u00e8me 1: Structures de donn\u00e9es 1.1 Listes cha\u00een\u00e9es \u2192 BAC 1.2 Piles et Files \u2192 BAC 1.3 Dictionnaires \u2192 BAC 1.4 Arbres \u2192 BAC 1.5 Graphes Th\u00e8me 2: Langages et programmation 2.1 Programmation orient\u00e9e objet \u2192 BAC 2.2 R\u00e9cursivit\u00e9 \u2192 BAC 2.3 Calculabilit\u00e9 et d\u00e9cidabilit\u00e9 2.4 Paradigmes de programmation Th\u00e8me 3: Algorithmique 3.1 Diviser pour r\u00e9gner \u2192 BAC 3.2 Programmation dynamique 3.3 Recherche textuelle Th\u00e8me 4: Bases de donn\u00e9es 4.1 Mod\u00e8le relationnel \u2192 BAC 4.2 Langage SQL \u2192 BAC Th\u00e8me 5: Architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux 5.1 Syst\u00e8me sur puce 5.2 Gestion des processus \u2192 BAC 5.3 Protocoles de routage \u2192 BAC 5.4 S\u00e9curisation des communications \u00c0 propos de la sp\u00e9cialit\u00e9 NSI Le site Eduscol Les troph\u00e9es NSI \u00c0 propos de la culture des sciences de l'informatique Interstices Inria \u00c0 propos de Python Une interview de Guido van Rossum , le cr\u00e9ateur de Python \u00c0 propos de l'orientation Talents du num\u00e9rique Une brochure int\u00e9ressante sur les m\u00e9tiers du num\u00e9rique. Un podcast sur les poursuites d'\u00e9tudes (CPGE MPI, IUT, Universit\u00e9) apr\u00e8s avoir choisi NSI comme sp\u00e9cialit\u00e9 au lyc\u00e9e. Zoom sur les m\u00e9tiers des math\u00e9matiques et de l'informatique Onisep Pour se creuser la t\u00eate Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Cod\u00e9moi Advent of Code MicroContest Hackinscience Pour se former en autonomie Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame L'essentiel des sources des contenus de ce site: L'excellentissime site de Gilles Lassus : https://glassus.github.io/terminale_nsi/ Le site de David Roche, https://pixees.fr/informatiquelycee Pr\u00e9pabac NSI, Tle g\u00e9n\u00e9rale , C. Adobet, G. Connan, G. Rozsavolgyi, L. Signac, Hatier NSI Tle, 24 le\u00e7ons avec exercices corrig\u00e9s , T. Balabonski, S. Conchon, J-C. Fili\u00e2tre, K. Nguyen, Ellipses Informatique et Sciences du Num\u00e9rique , G. Dowek, Eyrolles Les ressources disponibles sur https://gitlab.com/eskool/profs-info et sur le forum NSI - INRIA Cours/\u00c0 savoir Remarque Exemple M\u00e9thode/algorithme Code/Programme Exercice/TP Astuce/conseil Solution/Correction Attention/Remarque importante Citation Histoire de l'informatique Video Lien externe Lien vers activit\u00e9 Capytale Pyd\u00e9fi - c0d1ng UP","title":"Accueil"},{"location":"#cours-de-terminale-nsi-m-gouygou","text":"Lien vers le site de Premi\u00e8re. Programme Progression Liens utiles Sources L\u00e9gende du site Le programme de terminale NSI est articul\u00e9 autour de cinq th\u00e8mes. Nous traiterons les diff\u00e9rentes entr\u00e9es du programme dans les chapitres suivants, o\u00f9 la mention \u2192 BAC indique les chapitres pouvant \u00eatre \u00e9valu\u00e9s lors de l'\u00e9preuve \u00e9crite terminale de mars 2023. Th\u00e8me 1 Th\u00e8me 2 Th\u00e8me 3 Th\u00e8me 4 Th\u00e8me 5 Th\u00e8me 1: Structures de donn\u00e9es 1.1 Listes cha\u00een\u00e9es \u2192 BAC 1.2 Piles et Files \u2192 BAC 1.3 Dictionnaires \u2192 BAC 1.4 Arbres \u2192 BAC 1.5 Graphes Th\u00e8me 2: Langages et programmation 2.1 Programmation orient\u00e9e objet \u2192 BAC 2.2 R\u00e9cursivit\u00e9 \u2192 BAC 2.3 Calculabilit\u00e9 et d\u00e9cidabilit\u00e9 2.4 Paradigmes de programmation Th\u00e8me 3: Algorithmique 3.1 Diviser pour r\u00e9gner \u2192 BAC 3.2 Programmation dynamique 3.3 Recherche textuelle Th\u00e8me 4: Bases de donn\u00e9es 4.1 Mod\u00e8le relationnel \u2192 BAC 4.2 Langage SQL \u2192 BAC Th\u00e8me 5: Architectures mat\u00e9rielles, syst\u00e8mes d'exploitation et r\u00e9seaux 5.1 Syst\u00e8me sur puce 5.2 Gestion des processus \u2192 BAC 5.3 Protocoles de routage \u2192 BAC 5.4 S\u00e9curisation des communications \u00c0 propos de la sp\u00e9cialit\u00e9 NSI Le site Eduscol Les troph\u00e9es NSI \u00c0 propos de la culture des sciences de l'informatique Interstices Inria \u00c0 propos de Python Une interview de Guido van Rossum , le cr\u00e9ateur de Python \u00c0 propos de l'orientation Talents du num\u00e9rique Une brochure int\u00e9ressante sur les m\u00e9tiers du num\u00e9rique. Un podcast sur les poursuites d'\u00e9tudes (CPGE MPI, IUT, Universit\u00e9) apr\u00e8s avoir choisi NSI comme sp\u00e9cialit\u00e9 au lyc\u00e9e. Zoom sur les m\u00e9tiers des math\u00e9matiques et de l'informatique Onisep Pour se creuser la t\u00eate Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Cod\u00e9moi Advent of Code MicroContest Hackinscience Pour se former en autonomie Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame L'essentiel des sources des contenus de ce site: L'excellentissime site de Gilles Lassus : https://glassus.github.io/terminale_nsi/ Le site de David Roche, https://pixees.fr/informatiquelycee Pr\u00e9pabac NSI, Tle g\u00e9n\u00e9rale , C. Adobet, G. Connan, G. Rozsavolgyi, L. Signac, Hatier NSI Tle, 24 le\u00e7ons avec exercices corrig\u00e9s , T. Balabonski, S. Conchon, J-C. Fili\u00e2tre, K. Nguyen, Ellipses Informatique et Sciences du Num\u00e9rique , G. Dowek, Eyrolles Les ressources disponibles sur https://gitlab.com/eskool/profs-info et sur le forum NSI - INRIA Cours/\u00c0 savoir Remarque Exemple M\u00e9thode/algorithme Code/Programme Exercice/TP Astuce/conseil Solution/Correction Attention/Remarque importante Citation Histoire de l'informatique Video Lien externe Lien vers activit\u00e9 Capytale Pyd\u00e9fi - c0d1ng UP","title":"Cours de Terminale NSI - M. Gouygou"},{"location":"T01_StructuresDonnees/TP/","text":"TP \u2693\ufe0e TP1: le cr\u00eapier psycho-rigide \u2693\ufe0e \u00c9nonc\u00e9 \u00c0 la fin de sa journ\u00e9e, un cr\u00eapier dispose d'une pile d\u00e9sordonn\u00e9e de cr\u00eapes. Le cr\u00eapier \u00e9tant un peu psycho-rigide, il d\u00e9cide de ranger sa pile de cr\u00eapes, de la plus grande (en bas) \u00e0 la plus petite (en haut). Pour cette t\u00e2che, le cr\u00eapier peut faire une seule action : glisser sa spatule entre deux cr\u00eapes et retourner le haut de la pile. Pile initiale Choix d'insertion de la spatule Pile retourn\u00e9e Comment doit-il proc\u00e9der pour trier toute la pile de cr\u00eapes? Rappels (?) de m\u00e9thodes utiles (?) sur les listes de Python la m\u00e9thode append permet un \u00e9l\u00e9ment d'ajouter en fin de liste : >>> lst = [ 1 , 4 , 7 ] >>> lst . append ( 10 ) >>> lst . append ( 13 ) >>> lst [ 1 , 4 , 7 , 10 , 13 ] la m\u00e9thode pop permet d'enlever et de renvoyer un \u00e9l\u00e9ment d'une liste (par d\u00e9faut le dernier): >>> lst . pop () 13 >>> lst . pop () 10 >>> lst [ 1 , 4 , 7 ] >>> lst . pop ( 0 ) 1 >>> lst [ 4 , 7 ] Indications \u00c9crire une fonction plus_grand(lst, k) qui renvoie l'indice du plus grand \u00e9l\u00e9ment de la liste lst apr\u00e8s la position k . Exemple: >>> pile = [ 149 , 117 , 131 , 142 , 125 ] >>> plus_grand ( pile , 0 ) 0 >>> plus_grand ( pile , 1 ) 3 \u00c9crire une fonction retourner(lst, k) qui renvoie la liste retourn\u00e9e \u00e0 partir de l'indice k . Exemple: >>> pile = [ 149 , 117 , 131 , 142 , 125 ] >>> retourner ( pile , 3 ) [ 149 , 117 , 131 , 125 , 142 ] \u00c9crire une fonction r\u00e9cursive ordonner(lst, k) qui ordonne la liste lst \u00e0 partir de l'indice k . Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from random import randint def plus_grand ( liste : list , k : int ) -> int : ''' renvoie l'indice du plus grand \u00e9l\u00e9ment de la liste dont l'indice est sup\u00e9rieur \u00e0 k ''' imax = k m = 0 for i in range ( k , len ( liste )): if liste [ i ] > m : m = liste [ i ] imax = i return imax def retourner_pile ( liste : list , k : int ) -> list : ''' renvoie la liste retourn\u00e9e, c'est-\u00e0-dire consitut\u00e9e des \u00e9lements dans l'ordre inverse, \u00e0 partir de l'indice k ''' retour = [] for i in range ( len ( liste )): if i < k : retour . append ( liste [ i ]) else : retour . append ( liste . pop ()) return retour def ordonner_pile ( liste : list , n : int ): if n == len ( liste ): return liste else : lst1 = retourner_pile ( liste , plus_grand ( liste , n )) lst2 = retourner_pile ( lst1 , n ) return ordonner_pile ( lst2 , n + 1 )","title":"TP"},{"location":"T01_StructuresDonnees/TP/#tp","text":"","title":"TP"},{"location":"T01_StructuresDonnees/TP/#tp1-le-crepier-psycho-rigide","text":"\u00c9nonc\u00e9 \u00c0 la fin de sa journ\u00e9e, un cr\u00eapier dispose d'une pile d\u00e9sordonn\u00e9e de cr\u00eapes. Le cr\u00eapier \u00e9tant un peu psycho-rigide, il d\u00e9cide de ranger sa pile de cr\u00eapes, de la plus grande (en bas) \u00e0 la plus petite (en haut). Pour cette t\u00e2che, le cr\u00eapier peut faire une seule action : glisser sa spatule entre deux cr\u00eapes et retourner le haut de la pile. Pile initiale Choix d'insertion de la spatule Pile retourn\u00e9e Comment doit-il proc\u00e9der pour trier toute la pile de cr\u00eapes? Rappels (?) de m\u00e9thodes utiles (?) sur les listes de Python la m\u00e9thode append permet un \u00e9l\u00e9ment d'ajouter en fin de liste : >>> lst = [ 1 , 4 , 7 ] >>> lst . append ( 10 ) >>> lst . append ( 13 ) >>> lst [ 1 , 4 , 7 , 10 , 13 ] la m\u00e9thode pop permet d'enlever et de renvoyer un \u00e9l\u00e9ment d'une liste (par d\u00e9faut le dernier): >>> lst . pop () 13 >>> lst . pop () 10 >>> lst [ 1 , 4 , 7 ] >>> lst . pop ( 0 ) 1 >>> lst [ 4 , 7 ] Indications \u00c9crire une fonction plus_grand(lst, k) qui renvoie l'indice du plus grand \u00e9l\u00e9ment de la liste lst apr\u00e8s la position k . Exemple: >>> pile = [ 149 , 117 , 131 , 142 , 125 ] >>> plus_grand ( pile , 0 ) 0 >>> plus_grand ( pile , 1 ) 3 \u00c9crire une fonction retourner(lst, k) qui renvoie la liste retourn\u00e9e \u00e0 partir de l'indice k . Exemple: >>> pile = [ 149 , 117 , 131 , 142 , 125 ] >>> retourner ( pile , 3 ) [ 149 , 117 , 131 , 125 , 142 ] \u00c9crire une fonction r\u00e9cursive ordonner(lst, k) qui ordonne la liste lst \u00e0 partir de l'indice k . Correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from random import randint def plus_grand ( liste : list , k : int ) -> int : ''' renvoie l'indice du plus grand \u00e9l\u00e9ment de la liste dont l'indice est sup\u00e9rieur \u00e0 k ''' imax = k m = 0 for i in range ( k , len ( liste )): if liste [ i ] > m : m = liste [ i ] imax = i return imax def retourner_pile ( liste : list , k : int ) -> list : ''' renvoie la liste retourn\u00e9e, c'est-\u00e0-dire consitut\u00e9e des \u00e9lements dans l'ordre inverse, \u00e0 partir de l'indice k ''' retour = [] for i in range ( len ( liste )): if i < k : retour . append ( liste [ i ]) else : retour . append ( liste . pop ()) return retour def ordonner_pile ( liste : list , n : int ): if n == len ( liste ): return liste else : lst1 = retourner_pile ( liste , plus_grand ( liste , n )) lst2 = retourner_pile ( lst1 , n ) return ordonner_pile ( lst2 , n + 1 )","title":"TP1: le cr\u00eapier psycho-rigide"},{"location":"T01_StructuresDonnees/accueil/","text":"Th\u00e8me 1 : Structures de donn\u00e9es \u2693\ufe0e En informatique, une structure de donn\u00e9es est une mani\u00e8re d'organiser les donn\u00e9es pour les traiter plus facilement. Une structure de donn\u00e9es est une mise en \u0153uvre concr\u00e8te d'un type abstrait . Pour un type abstrait donn\u00e9, il faut absolument diff\u00e9rencier l' interface de l' impl\u00e9mentation : interface : ensemble des m\u00e9thodes qui permettent de manipuler le type abstrait; impl\u00e9mentation : code (Python en ce qui nous concerne) qui permet de construire les m\u00e9thodes. On choisit un type abstrait en fonction du probl\u00e8me \u00e0 r\u00e9soudre (choisir le bon type, c'est d\u00e9j\u00e0 r\u00e9soudre la majeure partie du probl\u00e8me) et des m\u00e9thodes \u00e0 envisager (et de leur co\u00fbt ), appel\u00e9es \u00e9galement primitives . Diff\u00e9rents types abstraits de donn\u00e9es tableaux (vus en premi\u00e8re) listes cha\u00een\u00e9es piles files tableaux associatifs (vus en premi\u00e8re) arbres graphes","title":"Th\u00e8me 1 : Structures de donn\u00e9es"},{"location":"T01_StructuresDonnees/accueil/#theme-1-structures-de-donnees","text":"En informatique, une structure de donn\u00e9es est une mani\u00e8re d'organiser les donn\u00e9es pour les traiter plus facilement. Une structure de donn\u00e9es est une mise en \u0153uvre concr\u00e8te d'un type abstrait . Pour un type abstrait donn\u00e9, il faut absolument diff\u00e9rencier l' interface de l' impl\u00e9mentation : interface : ensemble des m\u00e9thodes qui permettent de manipuler le type abstrait; impl\u00e9mentation : code (Python en ce qui nous concerne) qui permet de construire les m\u00e9thodes. On choisit un type abstrait en fonction du probl\u00e8me \u00e0 r\u00e9soudre (choisir le bon type, c'est d\u00e9j\u00e0 r\u00e9soudre la majeure partie du probl\u00e8me) et des m\u00e9thodes \u00e0 envisager (et de leur co\u00fbt ), appel\u00e9es \u00e9galement primitives . Diff\u00e9rents types abstraits de donn\u00e9es tableaux (vus en premi\u00e8re) listes cha\u00een\u00e9es piles files tableaux associatifs (vus en premi\u00e8re) arbres graphes","title":"Th\u00e8me 1 : Structures de donn\u00e9es"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/","text":"T1.1 Listes cha\u00een\u00e9es \u2693\ufe0e 1.1.1 Retour sur les tableaux \u2693\ufe0e Dans une structure de tableau ( array en anglais), les donn\u00e9es (ou une r\u00e9f\u00e9rence vers les donn\u00e9es) sont organis\u00e9es de mani\u00e8re s\u00e9quentielle en m\u00e9moire, o\u00f9 chaque \u00e9l\u00e9ment (ou r\u00e9f\u00e9rence) est de m\u00eame type. On peut donc calculer la position de l\u2019\u00e9l\u00e9ment (ou de la r\u00e9f\u00e9rence) en m\u00e9moire en fonction de son num\u00e9ro d\u2019ordre dans la s\u00e9quence. En r\u00e8gle g\u00e9n\u00e9rale, la taille du tableau est connue \u00e0 la d\u00e9claration. Dans ce cas, on ne peut pas ajouter d\u2019\u00e9l\u00e9ment au del\u00e0 de la derni\u00e8re case pr\u00e9vue. Quelques propri\u00e9t\u00e9s des tableaux : cr\u00e9ation d'un tableau de taille donn\u00e9e acc\u00e8s \u00e0 un \u00e9l\u00e9ment \u00e0 partir de son indice en temps constant ( \\(O(1)\\) ) modification d\u2019un \u00e9l\u00e9ment \u00e0 partir de son indice en temps constant ( \\(O(1)\\) ) En revanche, l'insertion d'un \u00e9l\u00e9ment dans le tableau impose de d\u00e9caler tous les \u00e9lements d'un indice, elle se fait donc en temps lin\u00e9aire, soit \\(O(n)\\) ... 1.1.2 Liste cha\u00een\u00e9e \u2693\ufe0e Avec une structure de liste (cha\u00een\u00e9e) , on repr\u00e9sente \u00e0 nouveau une s\u00e9quence d'\u00e9l\u00e9ments (\u00e0 nouveau le plus souvent homog\u00e8nes), mais les donn\u00e9es ne sont pas n\u00e9cessairement s\u00e9quentielles en m\u00e9moire. On dispose en revanche d'un moyen permettant de passer d'un \u00e9l\u00e9ment au suivant, d'o\u00f9 le terme cha\u00een\u00e9 . Chaque \u00e9l\u00e9ment est donc stock\u00e9 dans un bloc m\u00e9moire avec une deuxi\u00e8me information: l'adresse de l'\u00e9l\u00e9ment suivant. On parle de maillon ou cellule (ou encore node ) pour d\u00e9signer ces blocs. On peut g\u00e9n\u00e9ralement ajouter de nouveaux \u00e9l\u00e9ments pour augmenter la taille de la structure dynamiquement. Et finalement, une liste cha\u00een\u00e9e est soit vide, soit n'est qu'un lien vers une cellule, qui contient une valeur et un lien vers une cellule, qui est soit vide, soit n'est qu'un lien vers une cellule, qui contient une valeur et un lien vers une cellule, qui... On parle donc de d\u00e9finition r\u00e9cursive d'une liste cha\u00een\u00e9e. Interface On dispose (ou souhaite disposer) sur une liste cha\u00een\u00e9e des m\u00e9thodes/primitives suivantes: construire une liste vide, souvent nomm\u00e9e nil d\u00e9terminer si la liste est vide ( est_vide , is_empty ) ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de liste ( insert ) r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en t\u00eate de liste ( tete , head ) r\u00e9cup\u00e9rer la liste priv\u00e9e de son premier \u00e9l\u00e9ment, appel\u00e9e la queue ( queue , tail ) Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) . Acc\u00e8s \u00e0 un \u00e9l\u00e9ment Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment quelconque, il faut parcourir toute la liste jusqu'\u00e0 trouver l'\u00e9l\u00e9ment: le temps d'acc\u00e8s est lin\u00e9aire, c'est-\u00e0-dire proportionnel \u00e0 la taille de la liste (en \\(O(n)\\) ) et donc non constant. 1.1.3 Impl\u00e9mentation d'une liste cha\u00een\u00e9e \u2693\ufe0e On va donc impl\u00e9menter deux classes Cellule et Liste qui nous permettront de respecter l'interface demand\u00e9e, ainsi qu'une fonction construire et la constante nil repr\u00e9sentant la liste vide. Impl\u00e9mentation On ne d\u00e9finit la m\u00e9thode sp\u00e9ciale __str__ uniquement pour v\u00e9rifier et afficher de fa\u00e7on pratique la liste. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Cellule : def __init__ ( self , v , p ): self . valeur = v self . pointeur = p class Liste : def __init__ ( self , c ): self . cellule = c def est_vide ( self ): return self . cellule == None def tete ( self ): return self . cellule . valeur def queue ( self ): return self . cellule . pointeur def __str__ ( self ): l = [] while not self . est_vide (): l . append ( str ( self . tete ())) self = self . queue () return ' -> ' . join ( l ) def construire ( tete , queue ): return Liste ( Cellule ( tete , queue )) nil = Liste ( None ) Il est important de bien s\u00e9parer les deux classes Liste et Cellule , car l'attribut pointeur d\u2019une cellule n\u2019est pas une cellule mais bien une liste, c\u2019est-\u00e0-dire, sur le sch\u00e9ma, un lien vers une cellule. 1.1.4 Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Utiliser la fonction construire pour cr\u00e9er la liste lst de l'exemple: Vous devez avoir ensuite: >>> print ( l ) 3 -> 5 -> 1 >>> l . tete () 3 >>> l . queue () < __main__ . Liste object at 0 x ...> >>> print ( l . queue ()) 5 -> 1 >>> l . queue () . tete () 5 >>> l . queue () . queue () . tete () 1 l = construire ( 3 , construire ( 5 , construire ( 1 , nil ))) Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une fonction longueur qui renvoie la longueur d'une liste en param\u00e8tre (ou ajouter la m\u00e9thode sp\u00e9ciale __len__ \u00e0 la classe Liste ) Quelle est la complexit\u00e9 de cette fonction? def __len__ ( self ): n = 0 while not self . est_vide (): n += 1 self = self . queue () return n On est oblig\u00e9 de parcourir toute la liste, de longueur \\(n\\) , donc la complexit\u00e9 est en \\(O(n)\\) . Exercice 3 \u00c9nonc\u00e9 Correction Ajouter la m\u00e9thode insert \u00e0 la classe Liste , qui ins\u00e8re une valeur en t\u00eate de liste. 1 2 3 4 def insert ( self , v ): L = construire ( self . tete (), self . queue ()) self . cellule . pointeur = L self . cellule . valeur = v Exercice 4 \u00c9nonc\u00e9 Indication Correction \u00c9crire une fonction conversion qui prend en param\u00e8tre un tableau/liste (de type list de Python) et le convertit en liste cha\u00een\u00e9e (de type Liste ). Exemple d'utilisation 1 2 3 4 5 6 >>> tab = [ 3 , 5 , 1 ] >>> ll = conversion ( tab ) >>> type ( ll ) < class ' __main__ . Liste '> >>> print ( ll ) 3 -> 5 -> 1 La d\u00e9finition d'une liste cha\u00een\u00e9e est r\u00e9cursive ... 1 2 3 4 5 6 7 8 def conversion ( tab : list ) -> Liste : ''' Convertit tab (fourni en liste de Python) en objet Liste (cha\u00een\u00e9e) ''' if tab == []: return nil else : return construire ( tab [ 0 ], conversion ( tab [ 1 :])) Exercice 5 \u00c9nonc\u00e9 Correction \u00c9crire les fonctions suivantes (r\u00e9cursivement si possible): concatener(lst1, lst2) : fonction qui op\u00e8re une concat\u00e9nation de deux listes, c'est-\u00e0-dire les mettre bout \u00e0 bout. nieme(lst, n) : fonction qui renvoie le n-i\u00e8me \u00e9l\u00e9ment de la liste (sashant que la t\u00eate est le \u00ab0-i\u00e8me\u00bb). occurences(x, lst) : fonction qui renvoie le nombre d'occurences de la valeur x dans lst . Quelle est la complexit\u00e9 de ces fonctions? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. def concatener ( l1 : Liste , l2 : Liste ) -> Liste : if l1 . est_vide (): return l2 else : return construire ( l1 . tete (), concatener ( l1 . queue (), l2 )) # 2. def nieme ( lst : Liste , n : int ) -> int : if lst . est_vide (): return None elif n == 0 : return lst . tete () else : return nieme ( lst . queue (), n - 1 ) # 3. version r\u00e9cursive def occurences ( x : int , lst : Liste ) -> int : if lst . est_vide (): return 0 elif lst . tete () == x : return 1 + occurences ( x , lst . queue ()) else : return occurences ( x , lst . queue ()) # 3. version it\u00e9rative def occurences ( x : int , lst : Liste ) -> int : nb_occurences = 0 while not lst . est_vide (): if lst . tete () == x : nb_occurences += 1 lst = lst . queue () return n Complexit\u00e9s: La fonction concatener a un co\u00fbt en \\(O(n)\\) o\u00f9 \\(n\\) est la longueur de la liste l1 . En revanche, la longueur de la liste l2 n'a pas d'importance. et 3. : les fonctions nieme et occurences doivent parcourir la liste, donc sont de complexit\u00e9 lin\u00e9aire, c'est-\u00e0-dire en \\(O(n)\\) o\u00f9 \\(n\\) est la longueur de la liste.","title":"T1.1 Listes cha\u00een\u00e9es"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/#t11-listes-chainees","text":"","title":"T1.1 Listes cha\u00een\u00e9es"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/#111-retour-sur-les-tableaux","text":"Dans une structure de tableau ( array en anglais), les donn\u00e9es (ou une r\u00e9f\u00e9rence vers les donn\u00e9es) sont organis\u00e9es de mani\u00e8re s\u00e9quentielle en m\u00e9moire, o\u00f9 chaque \u00e9l\u00e9ment (ou r\u00e9f\u00e9rence) est de m\u00eame type. On peut donc calculer la position de l\u2019\u00e9l\u00e9ment (ou de la r\u00e9f\u00e9rence) en m\u00e9moire en fonction de son num\u00e9ro d\u2019ordre dans la s\u00e9quence. En r\u00e8gle g\u00e9n\u00e9rale, la taille du tableau est connue \u00e0 la d\u00e9claration. Dans ce cas, on ne peut pas ajouter d\u2019\u00e9l\u00e9ment au del\u00e0 de la derni\u00e8re case pr\u00e9vue. Quelques propri\u00e9t\u00e9s des tableaux : cr\u00e9ation d'un tableau de taille donn\u00e9e acc\u00e8s \u00e0 un \u00e9l\u00e9ment \u00e0 partir de son indice en temps constant ( \\(O(1)\\) ) modification d\u2019un \u00e9l\u00e9ment \u00e0 partir de son indice en temps constant ( \\(O(1)\\) ) En revanche, l'insertion d'un \u00e9l\u00e9ment dans le tableau impose de d\u00e9caler tous les \u00e9lements d'un indice, elle se fait donc en temps lin\u00e9aire, soit \\(O(n)\\) ...","title":"1.1.1 Retour sur les tableaux"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/#112-liste-chainee","text":"Avec une structure de liste (cha\u00een\u00e9e) , on repr\u00e9sente \u00e0 nouveau une s\u00e9quence d'\u00e9l\u00e9ments (\u00e0 nouveau le plus souvent homog\u00e8nes), mais les donn\u00e9es ne sont pas n\u00e9cessairement s\u00e9quentielles en m\u00e9moire. On dispose en revanche d'un moyen permettant de passer d'un \u00e9l\u00e9ment au suivant, d'o\u00f9 le terme cha\u00een\u00e9 . Chaque \u00e9l\u00e9ment est donc stock\u00e9 dans un bloc m\u00e9moire avec une deuxi\u00e8me information: l'adresse de l'\u00e9l\u00e9ment suivant. On parle de maillon ou cellule (ou encore node ) pour d\u00e9signer ces blocs. On peut g\u00e9n\u00e9ralement ajouter de nouveaux \u00e9l\u00e9ments pour augmenter la taille de la structure dynamiquement. Et finalement, une liste cha\u00een\u00e9e est soit vide, soit n'est qu'un lien vers une cellule, qui contient une valeur et un lien vers une cellule, qui est soit vide, soit n'est qu'un lien vers une cellule, qui contient une valeur et un lien vers une cellule, qui... On parle donc de d\u00e9finition r\u00e9cursive d'une liste cha\u00een\u00e9e. Interface On dispose (ou souhaite disposer) sur une liste cha\u00een\u00e9e des m\u00e9thodes/primitives suivantes: construire une liste vide, souvent nomm\u00e9e nil d\u00e9terminer si la liste est vide ( est_vide , is_empty ) ins\u00e9rer un \u00e9l\u00e9ment en t\u00eate de liste ( insert ) r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en t\u00eate de liste ( tete , head ) r\u00e9cup\u00e9rer la liste priv\u00e9e de son premier \u00e9l\u00e9ment, appel\u00e9e la queue ( queue , tail ) Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) . Acc\u00e8s \u00e0 un \u00e9l\u00e9ment Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment quelconque, il faut parcourir toute la liste jusqu'\u00e0 trouver l'\u00e9l\u00e9ment: le temps d'acc\u00e8s est lin\u00e9aire, c'est-\u00e0-dire proportionnel \u00e0 la taille de la liste (en \\(O(n)\\) ) et donc non constant.","title":"1.1.2 Liste cha\u00een\u00e9e"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/#113-implementation-dune-liste-chainee","text":"On va donc impl\u00e9menter deux classes Cellule et Liste qui nous permettront de respecter l'interface demand\u00e9e, ainsi qu'une fonction construire et la constante nil repr\u00e9sentant la liste vide. Impl\u00e9mentation On ne d\u00e9finit la m\u00e9thode sp\u00e9ciale __str__ uniquement pour v\u00e9rifier et afficher de fa\u00e7on pratique la liste. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Cellule : def __init__ ( self , v , p ): self . valeur = v self . pointeur = p class Liste : def __init__ ( self , c ): self . cellule = c def est_vide ( self ): return self . cellule == None def tete ( self ): return self . cellule . valeur def queue ( self ): return self . cellule . pointeur def __str__ ( self ): l = [] while not self . est_vide (): l . append ( str ( self . tete ())) self = self . queue () return ' -> ' . join ( l ) def construire ( tete , queue ): return Liste ( Cellule ( tete , queue )) nil = Liste ( None ) Il est important de bien s\u00e9parer les deux classes Liste et Cellule , car l'attribut pointeur d\u2019une cellule n\u2019est pas une cellule mais bien une liste, c\u2019est-\u00e0-dire, sur le sch\u00e9ma, un lien vers une cellule.","title":"1.1.3 Impl\u00e9mentation d'une liste cha\u00een\u00e9e"},{"location":"T01_StructuresDonnees/T1.1_Listes/T1.1_Listes/#114-exercices","text":"Exercice 1 \u00c9nonc\u00e9 Correction Utiliser la fonction construire pour cr\u00e9er la liste lst de l'exemple: Vous devez avoir ensuite: >>> print ( l ) 3 -> 5 -> 1 >>> l . tete () 3 >>> l . queue () < __main__ . Liste object at 0 x ...> >>> print ( l . queue ()) 5 -> 1 >>> l . queue () . tete () 5 >>> l . queue () . queue () . tete () 1 l = construire ( 3 , construire ( 5 , construire ( 1 , nil ))) Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une fonction longueur qui renvoie la longueur d'une liste en param\u00e8tre (ou ajouter la m\u00e9thode sp\u00e9ciale __len__ \u00e0 la classe Liste ) Quelle est la complexit\u00e9 de cette fonction? def __len__ ( self ): n = 0 while not self . est_vide (): n += 1 self = self . queue () return n On est oblig\u00e9 de parcourir toute la liste, de longueur \\(n\\) , donc la complexit\u00e9 est en \\(O(n)\\) . Exercice 3 \u00c9nonc\u00e9 Correction Ajouter la m\u00e9thode insert \u00e0 la classe Liste , qui ins\u00e8re une valeur en t\u00eate de liste. 1 2 3 4 def insert ( self , v ): L = construire ( self . tete (), self . queue ()) self . cellule . pointeur = L self . cellule . valeur = v Exercice 4 \u00c9nonc\u00e9 Indication Correction \u00c9crire une fonction conversion qui prend en param\u00e8tre un tableau/liste (de type list de Python) et le convertit en liste cha\u00een\u00e9e (de type Liste ). Exemple d'utilisation 1 2 3 4 5 6 >>> tab = [ 3 , 5 , 1 ] >>> ll = conversion ( tab ) >>> type ( ll ) < class ' __main__ . Liste '> >>> print ( ll ) 3 -> 5 -> 1 La d\u00e9finition d'une liste cha\u00een\u00e9e est r\u00e9cursive ... 1 2 3 4 5 6 7 8 def conversion ( tab : list ) -> Liste : ''' Convertit tab (fourni en liste de Python) en objet Liste (cha\u00een\u00e9e) ''' if tab == []: return nil else : return construire ( tab [ 0 ], conversion ( tab [ 1 :])) Exercice 5 \u00c9nonc\u00e9 Correction \u00c9crire les fonctions suivantes (r\u00e9cursivement si possible): concatener(lst1, lst2) : fonction qui op\u00e8re une concat\u00e9nation de deux listes, c'est-\u00e0-dire les mettre bout \u00e0 bout. nieme(lst, n) : fonction qui renvoie le n-i\u00e8me \u00e9l\u00e9ment de la liste (sashant que la t\u00eate est le \u00ab0-i\u00e8me\u00bb). occurences(x, lst) : fonction qui renvoie le nombre d'occurences de la valeur x dans lst . Quelle est la complexit\u00e9 de ces fonctions? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. def concatener ( l1 : Liste , l2 : Liste ) -> Liste : if l1 . est_vide (): return l2 else : return construire ( l1 . tete (), concatener ( l1 . queue (), l2 )) # 2. def nieme ( lst : Liste , n : int ) -> int : if lst . est_vide (): return None elif n == 0 : return lst . tete () else : return nieme ( lst . queue (), n - 1 ) # 3. version r\u00e9cursive def occurences ( x : int , lst : Liste ) -> int : if lst . est_vide (): return 0 elif lst . tete () == x : return 1 + occurences ( x , lst . queue ()) else : return occurences ( x , lst . queue ()) # 3. version it\u00e9rative def occurences ( x : int , lst : Liste ) -> int : nb_occurences = 0 while not lst . est_vide (): if lst . tete () == x : nb_occurences += 1 lst = lst . queue () return n Complexit\u00e9s: La fonction concatener a un co\u00fbt en \\(O(n)\\) o\u00f9 \\(n\\) est la longueur de la liste l1 . En revanche, la longueur de la liste l2 n'a pas d'importance. et 3. : les fonctions nieme et occurences doivent parcourir la liste, donc sont de complexit\u00e9 lin\u00e9aire, c'est-\u00e0-dire en \\(O(n)\\) o\u00f9 \\(n\\) est la longueur de la liste.","title":"1.1.4 Exercices"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/","text":"T1.2 Piles et Files \u2693\ufe0e 1.2.1 Les piles \u2693\ufe0e Une pile (stack) est une structure de donn\u00e9es lin\u00e9aire contenant des \u00e9l\u00e9ments g\u00e9n\u00e9ralement homog\u00e8nes fond\u00e9e sur le principe \u00abdernier arriv\u00e9, premier sorti\u00bb (en anglais LIFO : Last In, First Out). Exemples de situations utilisant une pile: historiques: de navigation sur le Web, d'annulation d'instructions (Ctrl+Z) appels de fonctions r\u00e9cursives la Chandeleur parcours en profondeur d'un arbre/graphe (plus tard...) Interface On dispose (ou souhaite disposer) sur une pile des m\u00e9thodes/primitives suivantes: d\u00e9terminer si la pile est vide ( est_vide , is_empty ) empiler un nouvel \u00e9l\u00e9ment au sommet de la pile ( empiler , push ) d\u00e9piler l'\u00e9l\u00e9ment du sommet de la pile ( depiler , pop ) et le renvoyer Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) . 1.2.2 Les files \u2693\ufe0e Une file (queue) est une structure de donn\u00e9es lin\u00e9aire contenant des \u00e9l\u00e9ments g\u00e9n\u00e9ralement homog\u00e8nes fond\u00e9e sur le principe \u00abpremier arriv\u00e9, premier sorti\u00bb (en anglais FIFO : Fast In, First Out). Exemples de situations utilisant une file: file d'attente : documents soumis \u00e0 impression, \u00e9l\u00e8ves \u00e0 la cantine... gestion des processus parcours en largeur d'un arbre/graphe (plus tard...) Interface On dispose (ou souhaite disposer) sur une file des m\u00e9thodes/primitives suivantes: d\u00e9terminer si la file est vide ( is_empty ) enfiler (ajouter) un nouvel \u00e9l\u00e9ment dans la file ( enqueue ) d\u00e9filer l'\u00e9l\u00e9ment de t\u00eate de la file ( dequeue ) et le renvoyer Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) . 1.2.3 Impl\u00e9mentations \u2693\ufe0e 1.2.3.1 Impl\u00e9mentations d'une pile \u2693\ufe0e Liste Python L\u2019impl\u00e9mentation Python du type list en fait un bon candidat pour la structure de pile : append (pour push ) et pop sont les deux op\u00e9rations utilisables sur les piles, toutes les deux en \\(O(1)\\) . Test de l'impl\u00e9mentation Dans les deux exercices qui suivent, quelle que soit l'impl\u00e9mentation de la pile, le code suivant: 1 2 3 4 5 6 7 p = Pile () p . empiler ( \"prems\" ) p . empiler ( \"deuz\" ) print ( p . depiler ()) p . empiler ( \"troiz\" ) while not p . est_vide (): print ( p . depiler ()) doit afficher: deuz troiz prems Exercice 1: avec une liste de Python \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe Pile contenant les m\u00e9thodes est_vide , empiler et depiler \u00e0 l'aide des m\u00e9thodes natives sur les listes de Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Pile : def __init__ ( self ): self . contenu = [] def est_vide ( self ): return self . contenu == [] def empiler ( self , valeur ): self . contenu . append ( valeur ) def depiler ( self ): if self . est_vide (): raise IndexError ( 'd\u00e9piler sur une pile vide' ) return self . contenu . pop () Exercice 2: avec une liste cha\u00een\u00e9e \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe Pile contenant les m\u00e9thodes est_vide , empiler et depiler \u00e0 l'aide d'une liste cha\u00een\u00e9e: empiler un nouvel \u00e9l\u00e9ment revient \u00e0 ajouter un \u00e9l\u00e9ment en t\u00eate de liste; d\u00e9piler un \u00e9l\u00e9ment revient \u00e0 supprimer l'\u00e9l\u00e9ment de t\u00eate. La classe Pile contient ainsi un seul attribut contenu associ\u00e9 \u00e0 la liste cha\u00een\u00e9e contenant les \u00e9l\u00e9ments de la pile. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Pile : def __init__ ( self ): self . contenu = Liste ( None ) def est_vide ( self ): return self . contenu . est_vide () def empiler ( self , valeur ): self . contenu . insert ( valeur ) def depiler ( self ): valeur = self . contenu . tete () self . contenu = self . contenu . queue () return valeur 1.2.3.2 Impl\u00e9mentations d'une file \u2693\ufe0e Test de l'impl\u00e9mentation Dans les trois exercices qui suivent, quelle que soit l'impl\u00e9mentation de la file, le code suivant: 1 2 3 4 5 6 7 f = File () f . enfiler ( \"prems\" ) f . enfiler ( \"deuz\" ) print ( f . defiler ()) f . enfiler ( \"troiz\" ) while not f . est_vide (): print ( f . defiler ()) doit afficher: prems deuz troiz Liste Python Avec deux piles Avec une liste cha\u00een\u00e9e (modifi\u00e9e) Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe File contenant les m\u00e9thodes est_vide , enfiler et defiler \u00e0 l'aide des m\u00e9thodes natives sur les listes de Python (consulter l'aide sur la m\u00e9thode pop ). 1 2 3 4 5 6 7 8 9 10 11 12 class File : def __init__ ( self ): self . contenu = [] def est_vide ( self ): return self . contenu == [] def enfiler ( self , valeur ): self . contenu . append ( valeur ) def defiler ( self ): return self . contenu . pop ( 0 ) Liste Python Pour une file en revanche, le type list de Python ne fournit pas une bonne impl\u00e9mentation d'une file, car la suppression en d\u00e9but de liste ne se fait pas en temps constant mais en temps lin\u00e9aire \\(O(n)\\) : il faut d\u00e9caler les \u00e9l\u00e9ments un \u00e0 un. Le principe est de disposer d'une pile d'entr\u00e9e et d'une pile de sortie... Exercice 4 \u00c9nonc\u00e9 Correction Terminer l'impl\u00e9mentation d'une classe File ayant comme attributs une pile d'entr\u00e9e et une pile de sortie. 1 2 3 4 class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () Cette impl\u00e9mentation respecte-t-elle la contrainte de complexit\u00e9 sur l'insertion en fin de file? la suppression en d\u00e9but de file? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfiler ( self , valeur ): self . entree . empiler ( valeur ) def defiler ( self ): if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empiler ( self . entree . depiler ()) return self . sortie . depiler () Comme pour une pile, on peut vouloir impl\u00e9menter une file \u00e0 l'aide d'une liste cha\u00een\u00e9e: si la suppression en t\u00eate de file ( defiler ) se fait en temps constant, en revanche l'ajout d'un \u00e9l\u00e9ment en queue de liste se fait en temps lin\u00e9aire... Il est donc n\u00e9cessaire de modifier la structure de liste cha\u00een\u00e9e en lui attribuant \u00e9galement une r\u00e9f\u00e9rence vers le dernier \u00e9l\u00e9ment de la liste: c'est une structure de type deque ( double-ended queue ). Impl\u00e9mentation d'une file avec une deque La principale diff\u00e9rence avec une liste cha\u00een\u00e9e est qu'il doit y avoir un attribut r\u00e9f\u00e9ren\u00e7ant le dernier \u00e9l\u00e9ment: 1 2 3 4 5 6 7 class File : \"\"\" Impl\u00e9mentation d'une file \u00e0 partir d'une liste chain\u00e9e \"\"\" def __init__ ( self ): self . _first = None self . _last = None Pour les m\u00e9thodes enfiler et defiler , il faut g\u00e9rer les r\u00e9f\u00e9rences \u00e0 la t\u00eate et \u00e0 la fin de la liste. Exercice 5 \u00c9nonc\u00e9 Correction Terminer l'impl\u00e9mentation de la classe File . 1.2.4 Exercices \u2693\ufe0e Exercice 6: calculatrice polonaise inverse \u00c9nonc\u00e9 Indication Correction L'\u00e9criture polonaise inverse des expressions arithm\u00e9tiques place l'op\u00e9rateur apr\u00e8s ses op\u00e9randes. Cette notation ne n\u00e9cessite aucune parenth\u00e8se ni aucune r\u00e8gle de priorit\u00e9. Ainsi l'expression polonaise inverse d\u00e9crite par la cha\u00eene de caract\u00e8res: '1 2 3 * + 4 *' d\u00e9signe l'expression traditionnellement not\u00e9e \\((1+2\\times3)\\times4\\) . \u00c9crire une fonction eval_pol_inv prenant en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant une expression en notation polonaise inverse compos\u00e9e d'additions et de multiplications de nombres entiers et renvoyant la valeur de cette expression. On supposera que les \u00e9l\u00e9ments de l'expression sont s\u00e9par\u00e9s par des espaces. Attention: cette fonction ne doit pas renvoyer de r\u00e9sultat (ou None ) si l'expression est mal \u00e9crite. Quelques tests: 1 2 assert eval_pol_inv ( '2 1 7 + 5 * +' ) == 42 assert eval_pol_inv ( '1 + 2' ) == None La valeur d'une telle expression peut \u00eatre calcul\u00e9e facilement en utilisant une pile pour stocker les r\u00e9sultats interm\u00e9diaires. Pour cela, on observe un \u00e0 un les \u00e9l\u00e9ments de l'expression et on effectue les actions suivantes : si on voit un nombre, on le place sur la pile; si on voit un op\u00e9rateur binaire, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile, on leur applique l'op\u00e9rateur, et on replace le r\u00e9sultat sur la pile. Si l'expression \u00e9tait bien \u00e9crite, il y a bien toujours deux nombres sur la pile lorsque l'on voit un op\u00e9rateur, et \u00e0 la fin du processus il reste exactement un nombre sur la pile, qui est le r\u00e9sultat. Exercice 7 \u00c9nonc\u00e9 Correction Dans cet exercice, on utilise une classe Pile impl\u00e9ment\u00e9e avec une liste de Python et poss\u00e9dant ses quatre \u00e9l\u00e9ments d'interface usuels: Un constructeur qui permet de cr\u00e9er une pile vide, repr\u00e9sent\u00e9e par [] ; La m\u00e9thode est_vide() qui renvoie True si l'objet est une pile ne contenant aucun \u00e9l\u00e9ment, et False sinon ; La m\u00e9thode empiler qui prend un objet quelconque en param\u00e8tre et ajoute cet objet au sommet de la pile. Dans la repr\u00e9sentation de la pile dans la console, cet objet appara\u00eet \u00e0 droite des autres \u00e9l\u00e9ments de la pile ; La m\u00e9thode depiler qui renvoie l'objet pr\u00e9sent au sommet de la pile et le retire de la pile. Exemples: >>> mapile = Pile () >>> mapile . empiler ( 2 ) >>> mapile [ 2 ] >>> mapile . empiler ( 3 ) >>> mapile . empiler ( 50 ) >>> mapile [ 2 , 3 , 50 ] >>> mapile . depiler () 50 >>> mapile [ 2 , 3 ] La m\u00e9thode est_triee ci-dessous renvoie True si, en d\u00e9pilant tous les \u00e9l\u00e9ments un par un , ils sont trait\u00e9s dans l'ordre croissant, et False sinon. Compl\u00e9ter les lignes 6 et 8. 1 2 3 4 5 6 7 8 9 def est_triee ( self ): if not self . est_vide () : e1 = self . depiler () while not self . est_vide (): e2 = self . depiler () if e1 ... e2 : return False e1 = ... return True On cr\u00e9e dans la console la pile A repr\u00e9sent\u00e9e par [1, 2, 3, 4] . a. Donner la valeur renvoy\u00e9e par l'appel A.est_triee() . b. Donner le contenu de la pile A apr\u00e8s l'ex\u00e9cution de cette instruction. On souhaite maintenant \u00e9crire le code d'une m\u00e9thode depileMax d'une pile non vide ne contenant que des nombres entiers et renvoyant le plus grand \u00e9l\u00e9ment de cette pile en le retirant de la pile. Apr\u00e8s l'ex\u00e9cution de p.depileMax() , le nombre d'\u00e9l\u00e9ments de la pile p diminue donc de 1. Compl\u00e9ter les lignes 9 et 11 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def depileMax ( self ): assert not self . est_vide (), \"Pile vide\" q = Pile () maxi = self . depiler () while not self . est_vide () : elt = self . depiler () if maxi < elt : q . empiler ( maxi ) maxi = ... else : ... while not q . est_vide (): self . empiler ( q . depiler ()) return maxi On cr\u00e9e la pile B repr\u00e9sent\u00e9e par [9, -7, 8, 12, 4] et on effectue l\u2019appel B.depileMax() . a. Donner le contenu des piles B et q \u00e0 la fin de chaque it\u00e9ration de la boucle while de la ligne 5. b. Donner le contenu des piles B et q avant l\u2019ex\u00e9cution de la ligne 14. c. Donner un exemple de pile qui montre que l'ordre des \u00e9l\u00e9ments restants n\u2019est pas pr\u00e9serv\u00e9 apr\u00e8s l\u2019ex\u00e9cution de depileMax . On donne le code de la fonction traite : 1 2 3 4 5 6 def traite ( self ): q = Pile () while not self . est_vide (): q . empile ( self . depile_max ()) while not q . est_vide (): self . empile ( q . depile ()) a. Donner les contenus successifs des piles B et q avant la ligne 3, avant la ligne 5, \u00e0 la fin de l'ex\u00e9cution de la fonction traite lorsque la fonction traite est appel\u00e9e avec la pile B contenant [1, 6, 4, 3, 7, 2] . b. Expliquer le traitement effectu\u00e9 par cette fonction. Exercice 8: files d'attente \u00c9nonc\u00e9 Correction Dans cet exercice, on se propose d'\u00e9valuer le temps d'attente de clients \u00e0 des guichets, en comparant la solution d'une unique file d'attente et la solution d'une file d'attente par guichet. Pour cela, on mod\u00e9lise le temps par une variable globale, qui est incr\u00e9ment\u00e9e \u00e0 chaque tour de boucle. Lorsqu'un nouveau client arrive, il est plac\u00e9 dans une file sous la forme d'un entier \u00e9gal \u00e0 la valeur de l'horloge, c'est-\u00e0-dire \u00e9gal \u00e0 son heure d'arriv\u00e9e. Lorsqu'un client est servi, c'est-\u00e0-dire lorsqu'il sort de sa file d'attente, on obtient son temps d'attente en faisant la soustraction de la valeur courante de l'horloge et de la valeur qui vient d'\u00eatre retir\u00e9e de la file. L'id\u00e9e est de faire tourner une telle simulation relativement longtemps, tout en totalisant le nombre de clients servis et le temps d'attente cumul\u00e9 sur tous les clients. Le rapport de ces deux quantit\u00e9s nous donne le temps d'attente moyen. On peut alors comparer plusieurs strat\u00e9gies (une ou plusieurs files, choix d'une file au hasard quand il y en a plusieurs, choix de la file o\u00f9 il y a le moins de clients, etc.). On se donne un nombre N de guichets (par exemple, N = 5). Pour simuler la disponibilit\u00e9 d'un guichet, on peut se donner un tableau d'entiers dispo de taille N. La valeur de dispo[i] indique le nombre de tours d'hor loge o\u00f9 le guichet i sera occup\u00e9. En particulier, lorsque cette valeur vaut 0, cela veut dire que le guichet est libre et peut donc servir un nouveau client. Lorsqu'un client est servi par le guichet 1, on choisit un temps de traitement pour ce client, au hasard entre 0 et N, et on l'affecte \u00e0 dispo[i] . \u00c0 chaque tour d'horloge, on r\u00e9alise deux op\u00e9rations: on fait appara\u00eetre un nouveau client; pour chaque guichet i : s'il est disponible, il sert un nouveau client (pris dans sa propre file ou dans l'unique file, selon le mod\u00e8le), le cas \u00e9ch\u00e9ant; sinon, on d\u00e9cr\u00e9mente dispo[i] . \u00c9crire un programme qui effectue une telle simulation, sur 100 tours d'horloge, et affiche au final le temps d'attente moyen. Comparer avec diff\u00e9rentes strat\u00e9gies. Exercice 9 \u00c9nonc\u00e9 Correction https://adventofcode.com/2018/day/5 Exercice 10 \u00c9nonc\u00e9 Code de d\u00e9part pour les fain\u00e9ant.e.s Correction https://adventofcode.com/2022/day/5 On travaillera avec la situation de d\u00e9part suivante : Et ce fichier d'instructions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data = open ( 'input_day5.txt' ) . read () . splitlines () class Pile : def __init__ ( self , lst ): self . contenu = lst def est_vide ( self ): return self . contenu == [] def empiler ( self , valeur ): self . contenu . append ( valeur ) def depiler ( self ): if self . est_vide (): raise IndexError ( \"d\u00e9piler sur une liste vide\" ) return self . contenu . pop () piles = [ Pile ( list ( 'QMGCL' )), Pile ( list ( 'RDLCTFHG' )), Pile ( list ( 'VJFNMTWR' )), Pile ( list ( 'JFDVQP' )), Pile ( list ( 'NFMSLBT' )), Pile ( list ( 'RNVHCDP' )), Pile ( list ( 'HCT' )), Pile ( list ( 'GSJVZNHP' )), Pile ( list ( 'ZFHG' ))]","title":"T1.2 Piles et Files"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#t12-piles-et-files","text":"","title":"T1.2 Piles et Files"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#121-les-piles","text":"Une pile (stack) est une structure de donn\u00e9es lin\u00e9aire contenant des \u00e9l\u00e9ments g\u00e9n\u00e9ralement homog\u00e8nes fond\u00e9e sur le principe \u00abdernier arriv\u00e9, premier sorti\u00bb (en anglais LIFO : Last In, First Out). Exemples de situations utilisant une pile: historiques: de navigation sur le Web, d'annulation d'instructions (Ctrl+Z) appels de fonctions r\u00e9cursives la Chandeleur parcours en profondeur d'un arbre/graphe (plus tard...) Interface On dispose (ou souhaite disposer) sur une pile des m\u00e9thodes/primitives suivantes: d\u00e9terminer si la pile est vide ( est_vide , is_empty ) empiler un nouvel \u00e9l\u00e9ment au sommet de la pile ( empiler , push ) d\u00e9piler l'\u00e9l\u00e9ment du sommet de la pile ( depiler , pop ) et le renvoyer Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) .","title":"1.2.1 Les piles"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#122-les-files","text":"Une file (queue) est une structure de donn\u00e9es lin\u00e9aire contenant des \u00e9l\u00e9ments g\u00e9n\u00e9ralement homog\u00e8nes fond\u00e9e sur le principe \u00abpremier arriv\u00e9, premier sorti\u00bb (en anglais FIFO : Fast In, First Out). Exemples de situations utilisant une file: file d'attente : documents soumis \u00e0 impression, \u00e9l\u00e8ves \u00e0 la cantine... gestion des processus parcours en largeur d'un arbre/graphe (plus tard...) Interface On dispose (ou souhaite disposer) sur une file des m\u00e9thodes/primitives suivantes: d\u00e9terminer si la file est vide ( is_empty ) enfiler (ajouter) un nouvel \u00e9l\u00e9ment dans la file ( enqueue ) d\u00e9filer l'\u00e9l\u00e9ment de t\u00eate de la file ( dequeue ) et le renvoyer Ces op\u00e9rations doivent \u00eatre r\u00e9alis\u00e9es en temps constant , soit en \\(O(1)\\) .","title":"1.2.2 Les files"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#123-implementations","text":"","title":"1.2.3 Impl\u00e9mentations"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#1231-implementations-dune-pile","text":"Liste Python L\u2019impl\u00e9mentation Python du type list en fait un bon candidat pour la structure de pile : append (pour push ) et pop sont les deux op\u00e9rations utilisables sur les piles, toutes les deux en \\(O(1)\\) . Test de l'impl\u00e9mentation Dans les deux exercices qui suivent, quelle que soit l'impl\u00e9mentation de la pile, le code suivant: 1 2 3 4 5 6 7 p = Pile () p . empiler ( \"prems\" ) p . empiler ( \"deuz\" ) print ( p . depiler ()) p . empiler ( \"troiz\" ) while not p . est_vide (): print ( p . depiler ()) doit afficher: deuz troiz prems Exercice 1: avec une liste de Python \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe Pile contenant les m\u00e9thodes est_vide , empiler et depiler \u00e0 l'aide des m\u00e9thodes natives sur les listes de Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Pile : def __init__ ( self ): self . contenu = [] def est_vide ( self ): return self . contenu == [] def empiler ( self , valeur ): self . contenu . append ( valeur ) def depiler ( self ): if self . est_vide (): raise IndexError ( 'd\u00e9piler sur une pile vide' ) return self . contenu . pop () Exercice 2: avec une liste cha\u00een\u00e9e \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe Pile contenant les m\u00e9thodes est_vide , empiler et depiler \u00e0 l'aide d'une liste cha\u00een\u00e9e: empiler un nouvel \u00e9l\u00e9ment revient \u00e0 ajouter un \u00e9l\u00e9ment en t\u00eate de liste; d\u00e9piler un \u00e9l\u00e9ment revient \u00e0 supprimer l'\u00e9l\u00e9ment de t\u00eate. La classe Pile contient ainsi un seul attribut contenu associ\u00e9 \u00e0 la liste cha\u00een\u00e9e contenant les \u00e9l\u00e9ments de la pile. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Pile : def __init__ ( self ): self . contenu = Liste ( None ) def est_vide ( self ): return self . contenu . est_vide () def empiler ( self , valeur ): self . contenu . insert ( valeur ) def depiler ( self ): valeur = self . contenu . tete () self . contenu = self . contenu . queue () return valeur","title":"1.2.3.1 Impl\u00e9mentations d'une pile"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#1232-implementations-dune-file","text":"Test de l'impl\u00e9mentation Dans les trois exercices qui suivent, quelle que soit l'impl\u00e9mentation de la file, le code suivant: 1 2 3 4 5 6 7 f = File () f . enfiler ( \"prems\" ) f . enfiler ( \"deuz\" ) print ( f . defiler ()) f . enfiler ( \"troiz\" ) while not f . est_vide (): print ( f . defiler ()) doit afficher: prems deuz troiz Liste Python Avec deux piles Avec une liste cha\u00een\u00e9e (modifi\u00e9e) Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter une classe File contenant les m\u00e9thodes est_vide , enfiler et defiler \u00e0 l'aide des m\u00e9thodes natives sur les listes de Python (consulter l'aide sur la m\u00e9thode pop ). 1 2 3 4 5 6 7 8 9 10 11 12 class File : def __init__ ( self ): self . contenu = [] def est_vide ( self ): return self . contenu == [] def enfiler ( self , valeur ): self . contenu . append ( valeur ) def defiler ( self ): return self . contenu . pop ( 0 ) Liste Python Pour une file en revanche, le type list de Python ne fournit pas une bonne impl\u00e9mentation d'une file, car la suppression en d\u00e9but de liste ne se fait pas en temps constant mais en temps lin\u00e9aire \\(O(n)\\) : il faut d\u00e9caler les \u00e9l\u00e9ments un \u00e0 un. Le principe est de disposer d'une pile d'entr\u00e9e et d'une pile de sortie... Exercice 4 \u00c9nonc\u00e9 Correction Terminer l'impl\u00e9mentation d'une classe File ayant comme attributs une pile d'entr\u00e9e et une pile de sortie. 1 2 3 4 class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () Cette impl\u00e9mentation respecte-t-elle la contrainte de complexit\u00e9 sur l'insertion en fin de file? la suppression en d\u00e9but de file? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfiler ( self , valeur ): self . entree . empiler ( valeur ) def defiler ( self ): if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empiler ( self . entree . depiler ()) return self . sortie . depiler () Comme pour une pile, on peut vouloir impl\u00e9menter une file \u00e0 l'aide d'une liste cha\u00een\u00e9e: si la suppression en t\u00eate de file ( defiler ) se fait en temps constant, en revanche l'ajout d'un \u00e9l\u00e9ment en queue de liste se fait en temps lin\u00e9aire... Il est donc n\u00e9cessaire de modifier la structure de liste cha\u00een\u00e9e en lui attribuant \u00e9galement une r\u00e9f\u00e9rence vers le dernier \u00e9l\u00e9ment de la liste: c'est une structure de type deque ( double-ended queue ). Impl\u00e9mentation d'une file avec une deque La principale diff\u00e9rence avec une liste cha\u00een\u00e9e est qu'il doit y avoir un attribut r\u00e9f\u00e9ren\u00e7ant le dernier \u00e9l\u00e9ment: 1 2 3 4 5 6 7 class File : \"\"\" Impl\u00e9mentation d'une file \u00e0 partir d'une liste chain\u00e9e \"\"\" def __init__ ( self ): self . _first = None self . _last = None Pour les m\u00e9thodes enfiler et defiler , il faut g\u00e9rer les r\u00e9f\u00e9rences \u00e0 la t\u00eate et \u00e0 la fin de la liste. Exercice 5 \u00c9nonc\u00e9 Correction Terminer l'impl\u00e9mentation de la classe File .","title":"1.2.3.2 Impl\u00e9mentations d'une file"},{"location":"T01_StructuresDonnees/T1.2_FifoLifo/T1.2_FifoLifo/#124-exercices","text":"Exercice 6: calculatrice polonaise inverse \u00c9nonc\u00e9 Indication Correction L'\u00e9criture polonaise inverse des expressions arithm\u00e9tiques place l'op\u00e9rateur apr\u00e8s ses op\u00e9randes. Cette notation ne n\u00e9cessite aucune parenth\u00e8se ni aucune r\u00e8gle de priorit\u00e9. Ainsi l'expression polonaise inverse d\u00e9crite par la cha\u00eene de caract\u00e8res: '1 2 3 * + 4 *' d\u00e9signe l'expression traditionnellement not\u00e9e \\((1+2\\times3)\\times4\\) . \u00c9crire une fonction eval_pol_inv prenant en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant une expression en notation polonaise inverse compos\u00e9e d'additions et de multiplications de nombres entiers et renvoyant la valeur de cette expression. On supposera que les \u00e9l\u00e9ments de l'expression sont s\u00e9par\u00e9s par des espaces. Attention: cette fonction ne doit pas renvoyer de r\u00e9sultat (ou None ) si l'expression est mal \u00e9crite. Quelques tests: 1 2 assert eval_pol_inv ( '2 1 7 + 5 * +' ) == 42 assert eval_pol_inv ( '1 + 2' ) == None La valeur d'une telle expression peut \u00eatre calcul\u00e9e facilement en utilisant une pile pour stocker les r\u00e9sultats interm\u00e9diaires. Pour cela, on observe un \u00e0 un les \u00e9l\u00e9ments de l'expression et on effectue les actions suivantes : si on voit un nombre, on le place sur la pile; si on voit un op\u00e9rateur binaire, on r\u00e9cup\u00e8re les deux nombres au sommet de la pile, on leur applique l'op\u00e9rateur, et on replace le r\u00e9sultat sur la pile. Si l'expression \u00e9tait bien \u00e9crite, il y a bien toujours deux nombres sur la pile lorsque l'on voit un op\u00e9rateur, et \u00e0 la fin du processus il reste exactement un nombre sur la pile, qui est le r\u00e9sultat. Exercice 7 \u00c9nonc\u00e9 Correction Dans cet exercice, on utilise une classe Pile impl\u00e9ment\u00e9e avec une liste de Python et poss\u00e9dant ses quatre \u00e9l\u00e9ments d'interface usuels: Un constructeur qui permet de cr\u00e9er une pile vide, repr\u00e9sent\u00e9e par [] ; La m\u00e9thode est_vide() qui renvoie True si l'objet est une pile ne contenant aucun \u00e9l\u00e9ment, et False sinon ; La m\u00e9thode empiler qui prend un objet quelconque en param\u00e8tre et ajoute cet objet au sommet de la pile. Dans la repr\u00e9sentation de la pile dans la console, cet objet appara\u00eet \u00e0 droite des autres \u00e9l\u00e9ments de la pile ; La m\u00e9thode depiler qui renvoie l'objet pr\u00e9sent au sommet de la pile et le retire de la pile. Exemples: >>> mapile = Pile () >>> mapile . empiler ( 2 ) >>> mapile [ 2 ] >>> mapile . empiler ( 3 ) >>> mapile . empiler ( 50 ) >>> mapile [ 2 , 3 , 50 ] >>> mapile . depiler () 50 >>> mapile [ 2 , 3 ] La m\u00e9thode est_triee ci-dessous renvoie True si, en d\u00e9pilant tous les \u00e9l\u00e9ments un par un , ils sont trait\u00e9s dans l'ordre croissant, et False sinon. Compl\u00e9ter les lignes 6 et 8. 1 2 3 4 5 6 7 8 9 def est_triee ( self ): if not self . est_vide () : e1 = self . depiler () while not self . est_vide (): e2 = self . depiler () if e1 ... e2 : return False e1 = ... return True On cr\u00e9e dans la console la pile A repr\u00e9sent\u00e9e par [1, 2, 3, 4] . a. Donner la valeur renvoy\u00e9e par l'appel A.est_triee() . b. Donner le contenu de la pile A apr\u00e8s l'ex\u00e9cution de cette instruction. On souhaite maintenant \u00e9crire le code d'une m\u00e9thode depileMax d'une pile non vide ne contenant que des nombres entiers et renvoyant le plus grand \u00e9l\u00e9ment de cette pile en le retirant de la pile. Apr\u00e8s l'ex\u00e9cution de p.depileMax() , le nombre d'\u00e9l\u00e9ments de la pile p diminue donc de 1. Compl\u00e9ter les lignes 9 et 11 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def depileMax ( self ): assert not self . est_vide (), \"Pile vide\" q = Pile () maxi = self . depiler () while not self . est_vide () : elt = self . depiler () if maxi < elt : q . empiler ( maxi ) maxi = ... else : ... while not q . est_vide (): self . empiler ( q . depiler ()) return maxi On cr\u00e9e la pile B repr\u00e9sent\u00e9e par [9, -7, 8, 12, 4] et on effectue l\u2019appel B.depileMax() . a. Donner le contenu des piles B et q \u00e0 la fin de chaque it\u00e9ration de la boucle while de la ligne 5. b. Donner le contenu des piles B et q avant l\u2019ex\u00e9cution de la ligne 14. c. Donner un exemple de pile qui montre que l'ordre des \u00e9l\u00e9ments restants n\u2019est pas pr\u00e9serv\u00e9 apr\u00e8s l\u2019ex\u00e9cution de depileMax . On donne le code de la fonction traite : 1 2 3 4 5 6 def traite ( self ): q = Pile () while not self . est_vide (): q . empile ( self . depile_max ()) while not q . est_vide (): self . empile ( q . depile ()) a. Donner les contenus successifs des piles B et q avant la ligne 3, avant la ligne 5, \u00e0 la fin de l'ex\u00e9cution de la fonction traite lorsque la fonction traite est appel\u00e9e avec la pile B contenant [1, 6, 4, 3, 7, 2] . b. Expliquer le traitement effectu\u00e9 par cette fonction. Exercice 8: files d'attente \u00c9nonc\u00e9 Correction Dans cet exercice, on se propose d'\u00e9valuer le temps d'attente de clients \u00e0 des guichets, en comparant la solution d'une unique file d'attente et la solution d'une file d'attente par guichet. Pour cela, on mod\u00e9lise le temps par une variable globale, qui est incr\u00e9ment\u00e9e \u00e0 chaque tour de boucle. Lorsqu'un nouveau client arrive, il est plac\u00e9 dans une file sous la forme d'un entier \u00e9gal \u00e0 la valeur de l'horloge, c'est-\u00e0-dire \u00e9gal \u00e0 son heure d'arriv\u00e9e. Lorsqu'un client est servi, c'est-\u00e0-dire lorsqu'il sort de sa file d'attente, on obtient son temps d'attente en faisant la soustraction de la valeur courante de l'horloge et de la valeur qui vient d'\u00eatre retir\u00e9e de la file. L'id\u00e9e est de faire tourner une telle simulation relativement longtemps, tout en totalisant le nombre de clients servis et le temps d'attente cumul\u00e9 sur tous les clients. Le rapport de ces deux quantit\u00e9s nous donne le temps d'attente moyen. On peut alors comparer plusieurs strat\u00e9gies (une ou plusieurs files, choix d'une file au hasard quand il y en a plusieurs, choix de la file o\u00f9 il y a le moins de clients, etc.). On se donne un nombre N de guichets (par exemple, N = 5). Pour simuler la disponibilit\u00e9 d'un guichet, on peut se donner un tableau d'entiers dispo de taille N. La valeur de dispo[i] indique le nombre de tours d'hor loge o\u00f9 le guichet i sera occup\u00e9. En particulier, lorsque cette valeur vaut 0, cela veut dire que le guichet est libre et peut donc servir un nouveau client. Lorsqu'un client est servi par le guichet 1, on choisit un temps de traitement pour ce client, au hasard entre 0 et N, et on l'affecte \u00e0 dispo[i] . \u00c0 chaque tour d'horloge, on r\u00e9alise deux op\u00e9rations: on fait appara\u00eetre un nouveau client; pour chaque guichet i : s'il est disponible, il sert un nouveau client (pris dans sa propre file ou dans l'unique file, selon le mod\u00e8le), le cas \u00e9ch\u00e9ant; sinon, on d\u00e9cr\u00e9mente dispo[i] . \u00c9crire un programme qui effectue une telle simulation, sur 100 tours d'horloge, et affiche au final le temps d'attente moyen. Comparer avec diff\u00e9rentes strat\u00e9gies. Exercice 9 \u00c9nonc\u00e9 Correction https://adventofcode.com/2018/day/5 Exercice 10 \u00c9nonc\u00e9 Code de d\u00e9part pour les fain\u00e9ant.e.s Correction https://adventofcode.com/2022/day/5 On travaillera avec la situation de d\u00e9part suivante : Et ce fichier d'instructions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data = open ( 'input_day5.txt' ) . read () . splitlines () class Pile : def __init__ ( self , lst ): self . contenu = lst def est_vide ( self ): return self . contenu == [] def empiler ( self , valeur ): self . contenu . append ( valeur ) def depiler ( self ): if self . est_vide (): raise IndexError ( \"d\u00e9piler sur une liste vide\" ) return self . contenu . pop () piles = [ Pile ( list ( 'QMGCL' )), Pile ( list ( 'RDLCTFHG' )), Pile ( list ( 'VJFNMTWR' )), Pile ( list ( 'JFDVQP' )), Pile ( list ( 'NFMSLBT' )), Pile ( list ( 'RNVHCDP' )), Pile ( list ( 'HCT' )), Pile ( list ( 'GSJVZNHP' )), Pile ( list ( 'ZFHG' ))]","title":"1.2.4 Exercices"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.1_Arbres/","text":"G\u00e9n\u00e9ralit\u00e9s sur les arbres \u2693\ufe0e 1. Notion d'arbre \u2693\ufe0e Un arbre est une structure de donn\u00e9es qui permet de repr\u00e9senter des donn\u00e9es structur\u00e9es de fa\u00e7on hi\u00e9rarchique . On trouve beaucoup d'applications en informatique... Exemples Exemple 1 2 3 4 5 6 7 8 Arbre de classification des esp\u00e8ces animales DOM d'une page web Arborescence de fichiers Analyse grammaticale d'une phrase Analyse d'une expression alg\u00e9brique \\((x+1) \\times (3\\times y+2)\\) Arbre de jeu Arbre minimal couvrant (graphes) Arbre des appels d'une fonction r\u00e9cursive Vocabulaire Un arbre est un ensemble de n\u0153uds reli\u00e9s par des ar\u00eates , de sorte que chaque n\u0153ud poss\u00e8de un unique parent, sauf un, appel\u00e9 racine de l'arbre. On parle aussi d'arbre enracin\u00e9 . Il existe deux types de n\u0153uds: les n\u0153uds internes qui poss\u00e8dent des successeurs ( fils ); les feuilles (ou n\u0153uds externes) qui ne poss\u00e8dent pas de fils. \u00c0 chaque sommet est associ\u00e9 une \u00e9tiquette ou valeur . Exemples Dans l'arbre pr\u00e9c\u00e9dent, la racine est le sommet \u00e9tiquet\u00e9 A; les n\u0153uds internes sont : B, C, H, K et L; ls feuilles sont : D, E, F, G, I, J, M et N; par exemple, B est le p\u00e8re de C et F; par exemple, L et N sont les fils de K. 2. Sous-arbre \u2693\ufe0e En ne consid\u00e9rant que le n\u0153ud B et ses descendants, on obtient un nouvel arbre qu'on appelle sous-arbre de racine B . Structure r\u00e9cursive On peut donc voir un arbre comme une structure de donn\u00e9es r\u00e9cursive (ce sera utile pour les algorithmes utilisant des arbres): soit l'arbre est r\u00e9duit \u00e0 un seul n\u0153ud, sa racine (cas de base); soit l'arbre est consitu\u00e9 d'une racine R et d'un ensemble de sous-arbres dont les racines sont les fils de R. 3. Caract\u00e9ristiques \u2693\ufe0e D\u00e9finitions la taille d'un arbre est le nombre de ses n\u0153uds (un arbre sans n\u0153ud est un arbre vide, de taille 0); la profondeur d'un n\u0153ud est le nombre de n\u0153uds du chemin le plus court vers la racine; la hauteur d'un arbre est la plus grande profondeur d'un de ses n\u0153uds. En particulier, un arbre vide a une hauteur de 0 et un arbre r\u00e9duit \u00e0 un seul n\u0153ud (la racine) a une hauteur de 1. Exercice \u00c9nonc\u00e9 Correction Dans l'arbre donn\u00e9 pr\u00e9c\u00e9demment en exemple, d\u00e9terminer: la taille de l'arbre. la profondeur des n\u0153uds B, J, E, M. la hauteur de l'arbre.","title":"G\u00e9n\u00e9ralit\u00e9s sur les arbres"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.1_Arbres/#generalites-sur-les-arbres","text":"","title":"G\u00e9n\u00e9ralit\u00e9s sur les arbres"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.1_Arbres/#1-notion-darbre","text":"Un arbre est une structure de donn\u00e9es qui permet de repr\u00e9senter des donn\u00e9es structur\u00e9es de fa\u00e7on hi\u00e9rarchique . On trouve beaucoup d'applications en informatique... Exemples Exemple 1 2 3 4 5 6 7 8 Arbre de classification des esp\u00e8ces animales DOM d'une page web Arborescence de fichiers Analyse grammaticale d'une phrase Analyse d'une expression alg\u00e9brique \\((x+1) \\times (3\\times y+2)\\) Arbre de jeu Arbre minimal couvrant (graphes) Arbre des appels d'une fonction r\u00e9cursive Vocabulaire Un arbre est un ensemble de n\u0153uds reli\u00e9s par des ar\u00eates , de sorte que chaque n\u0153ud poss\u00e8de un unique parent, sauf un, appel\u00e9 racine de l'arbre. On parle aussi d'arbre enracin\u00e9 . Il existe deux types de n\u0153uds: les n\u0153uds internes qui poss\u00e8dent des successeurs ( fils ); les feuilles (ou n\u0153uds externes) qui ne poss\u00e8dent pas de fils. \u00c0 chaque sommet est associ\u00e9 une \u00e9tiquette ou valeur . Exemples Dans l'arbre pr\u00e9c\u00e9dent, la racine est le sommet \u00e9tiquet\u00e9 A; les n\u0153uds internes sont : B, C, H, K et L; ls feuilles sont : D, E, F, G, I, J, M et N; par exemple, B est le p\u00e8re de C et F; par exemple, L et N sont les fils de K.","title":"1. Notion d'arbre"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.1_Arbres/#2-sous-arbre","text":"En ne consid\u00e9rant que le n\u0153ud B et ses descendants, on obtient un nouvel arbre qu'on appelle sous-arbre de racine B . Structure r\u00e9cursive On peut donc voir un arbre comme une structure de donn\u00e9es r\u00e9cursive (ce sera utile pour les algorithmes utilisant des arbres): soit l'arbre est r\u00e9duit \u00e0 un seul n\u0153ud, sa racine (cas de base); soit l'arbre est consitu\u00e9 d'une racine R et d'un ensemble de sous-arbres dont les racines sont les fils de R.","title":"2. Sous-arbre"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.1_Arbres/#3-caracteristiques","text":"D\u00e9finitions la taille d'un arbre est le nombre de ses n\u0153uds (un arbre sans n\u0153ud est un arbre vide, de taille 0); la profondeur d'un n\u0153ud est le nombre de n\u0153uds du chemin le plus court vers la racine; la hauteur d'un arbre est la plus grande profondeur d'un de ses n\u0153uds. En particulier, un arbre vide a une hauteur de 0 et un arbre r\u00e9duit \u00e0 un seul n\u0153ud (la racine) a une hauteur de 1. Exercice \u00c9nonc\u00e9 Correction Dans l'arbre donn\u00e9 pr\u00e9c\u00e9demment en exemple, d\u00e9terminer: la taille de l'arbre. la profondeur des n\u0153uds B, J, E, M. la hauteur de l'arbre.","title":"3. Caract\u00e9ristiques"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/","text":"Arbres binaires \u2693\ufe0e Vocabulaire Arbre binaire Sous-arbres Un arbre est binaire si chacun de ses n\u0153uds poss\u00e8de au plus deux fils : un fils gauche et un fils droit. L'arbre est dit complet si tous les n\u0153uds poss\u00e8dent exactement deux fils (ce qui n'est pas le cas de l'arbre pr\u00e9c\u00e9dent, le n\u0153us Y n'ayant qu'un fils gauche). Les sous-arbres sont alors appel\u00e9s sous-arbre gauche et sous-arbre droit. Exercice 1 \u00c9nonc\u00e9 Correction Dessiner un arbre binaire complet de hauteur 4. 1. Taille et hauteur d'un arbre binaire \u2693\ufe0e Exercice 2 \u00c9nonc\u00e9 Correction Construire un arbre binaire de hauteur \\(h\\) (par exemple \\(h=4\\) ) poss\u00e9dant le moins de n\u0153uds possibles. Quelle est sa taille \\(n\\) ? Construire un arbre binaire de hauteur \\(h\\) (par exemple \\(h=4\\) ) poss\u00e9dant le plus de n\u0153uds possibles. Quelle est sa taille \\(n\\) ? Encadrement de la taille d'un arbre Pour un arbre binaire de taille \\(n\\) et de hauteur \\(h\\) : \\[h \\leqslant n \\leqslant 2^{h} - 1\\] Exercice 3 \u00c9nonc\u00e9 Correction Donner un encadrement de la taille d'un arbre de hauteur 6. Donner un encadrement de la hauteur d'un arbre de taille 24. 2. Parcours d'un arbre binaire \u2693\ufe0e L'int\u00e9r\u00eat des arbres est de stocker de l'information - les \u00e9tiquettes - de fa\u00e7on structur\u00e9e. Il est donc important de savoir comment parcourir un arbre pour avoir acc\u00e8s \u00e0 tous les n\u0153uds et les traiter . 2.1 Parcours en largeur (BFS) \u2693\ufe0e Parcours en largeur Le parcours en largeur d'abord (ou BFS pour Breadth-First Search) consiste \u00e0 parcourir l'arbre niveau par niveau. Les n\u0153uds de niveau 0 sont sont d'abord parcourus puis les n\u0153uds de niveau 1 et ainsi de suite. Dans chaque niveau, les n\u0153uds sont parcourus de la gauche vers la droite. Le parcours en largeur de l'arbre ci-dessus parcours les n\u0153uds dans l'ordre T-Y-O-P-H-N. Algorithme de parcours en largeur Le principe est d'utiliser une file : on commence par enfiler la racine de l'arbre; puis tant que la file n'est pas vide: on d\u00e9file un n\u0153ud; on traite le n\u0153ud; on enfile les fils du n\u0153ud (s'il en poss\u00e8de) 2.2 Parcours en profondeur (DFS) \u2693\ufe0e Parcours en profondeur Le parcours en profondeur d'abord( ou DFS pour Depth-First Search) consiste \u00e0 poursuivre un chemin jusqu'\u00e0 rencontrer une feuille, puis revenir au dernier n\u0153ud o\u00f9 l'on pouvait explorer un autre chemin, etc. Il se d\u00e9finit de mani\u00e8re r\u00e9cursive sur les sous-arbres de l'arbre. Il existe plusieurs parcours d'arbres en profondeur, selon que le traitement de la racine a lieu avant l'exploration des sous-arbres (parcours pr\u00e9fixe ), entre celle du sous-arbre gauche et celle du sous-arbre droit (parcours infixe ) ou apr\u00e8s l'exploration des sous-arbres (parcours postfixe/suffixe ). Algorithmes de parcours en profondeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: traiter(A.racine) # pr\u00e9fixe: traitement de la racine avant les appels r\u00e9cursifs parcours(A.fils_gauche) parcours(A.fils_droit) Sur cet arbre, le parcours pr\u00e9fixe donne : \\(\\quad\\times \\quad - \\quad x \\quad1\\quad+\\quad y\\quad3\\) En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: parcours(A.fils_gauche) traiter(A.racine) # infixe: traitement de la racine entre les appels r\u00e9cursifs parcours(A.fils_droit) Sur cet arbre, le parcours infixe donne : \\(\\quad x\\quad -\\quad1 \\quad \\times \\quad y \\quad+\\quad 3\\) En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: parcours(A.fils_gauche) parcours(A.fils_droit) traiter(A.racine) # postfixe: traitement de la racine apr\u00e8s les appels r\u00e9cursifs Sur cet arbre, le parcours postfixe donne : \\(\\quad x\\quad 1\\quad-\\quad y\\quad3\\quad+\\quad\\times\\) 3. Impl\u00e9mentation d'un arbre binaire \u2693\ufe0e Python ne propose pas de fa\u00e7on native l\u2019impl\u00e9mentation des arbres binaires. Il est cependant tr\u00e8s ais\u00e9 de d\u00e9finir un arbre binaire en d\u00e9finissant des classes Arbre et Noeud : 1 2 3 4 5 6 7 8 9 10 11 class Noeud : def __init__ ( self , v , g = None , d = None ): self . valeur = v self . gauche = g # type Noeud self . droit = d # type Noeud class Arbre : def __init__ ( self , racine = None ): self . racine = racine # type : Noeud arbre = Arbre ( Noeud ( \"A\" )) 4. Exercices \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction Dessiner: les arbres binaires \u00e0 1 n\u0153ud; les arbres binaires \u00e0 2 n\u0153uds; les arbres binaires \u00e0 3 n\u0153uds; les arbres binaires \u00e0 4 n\u0153uds; Sans les dessiner, d\u00e9nombrer le nombre d'arbres binaires \u00e0 5 n\u0153uds. Exercice 5 \u00c9nonc\u00e9 Correction Effectuer sur l'arbre suivant: un parcours pr\u00e9fixe un parcours infixe un parcours postfixe Exercice 6 Arbre 1 Arbre 2 Correction Sur l'arbre suivant: Donner sa taille et sa hauteur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours en largeur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours pr\u00e9fixe, puis dans un parcours infixe et enfin dans un parcours postfixe. Sur l'arbre suivant: Donner sa taille et sa hauteur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours en largeur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours pr\u00e9fixe, puis dans un parcours infixe et enfin dans un parcours postfixe. Exercice 7 \u00c9nonc\u00e9 Correction \u00c0 l'aide des classe Arbre et Noeud , cr\u00e9er une instance d' Arbre repr\u00e9sentant l'arbre: Exercice 8 \u00c9nonc\u00e9 Correction On d\u00e9finit un arbre par les instructions suivantes: 1 2 3 4 5 6 7 8 ng = Noeud ( 9 ) nd = Noeud ( 4 ) ng = Noeud ( 1 , ng , nd ) nd = Noeud ( 12 ) nd = Noeud ( 6 , ng , nd ) ngd = Noeud ( 3 ) ng = Noeud ( 10 , d = ngd ) arbre = Arbre ( Noeud ( 5 , ng , nd )) Repr\u00e9senter graphiquement cet arbre.","title":"Arbres binaires"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#arbres-binaires","text":"Vocabulaire Arbre binaire Sous-arbres Un arbre est binaire si chacun de ses n\u0153uds poss\u00e8de au plus deux fils : un fils gauche et un fils droit. L'arbre est dit complet si tous les n\u0153uds poss\u00e8dent exactement deux fils (ce qui n'est pas le cas de l'arbre pr\u00e9c\u00e9dent, le n\u0153us Y n'ayant qu'un fils gauche). Les sous-arbres sont alors appel\u00e9s sous-arbre gauche et sous-arbre droit. Exercice 1 \u00c9nonc\u00e9 Correction Dessiner un arbre binaire complet de hauteur 4.","title":"Arbres binaires"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#1-taille-et-hauteur-dun-arbre-binaire","text":"Exercice 2 \u00c9nonc\u00e9 Correction Construire un arbre binaire de hauteur \\(h\\) (par exemple \\(h=4\\) ) poss\u00e9dant le moins de n\u0153uds possibles. Quelle est sa taille \\(n\\) ? Construire un arbre binaire de hauteur \\(h\\) (par exemple \\(h=4\\) ) poss\u00e9dant le plus de n\u0153uds possibles. Quelle est sa taille \\(n\\) ? Encadrement de la taille d'un arbre Pour un arbre binaire de taille \\(n\\) et de hauteur \\(h\\) : \\[h \\leqslant n \\leqslant 2^{h} - 1\\] Exercice 3 \u00c9nonc\u00e9 Correction Donner un encadrement de la taille d'un arbre de hauteur 6. Donner un encadrement de la hauteur d'un arbre de taille 24.","title":"1. Taille et hauteur d'un arbre binaire"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#2-parcours-dun-arbre-binaire","text":"L'int\u00e9r\u00eat des arbres est de stocker de l'information - les \u00e9tiquettes - de fa\u00e7on structur\u00e9e. Il est donc important de savoir comment parcourir un arbre pour avoir acc\u00e8s \u00e0 tous les n\u0153uds et les traiter .","title":"2. Parcours d'un arbre binaire"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#21-parcours-en-largeur-bfs","text":"Parcours en largeur Le parcours en largeur d'abord (ou BFS pour Breadth-First Search) consiste \u00e0 parcourir l'arbre niveau par niveau. Les n\u0153uds de niveau 0 sont sont d'abord parcourus puis les n\u0153uds de niveau 1 et ainsi de suite. Dans chaque niveau, les n\u0153uds sont parcourus de la gauche vers la droite. Le parcours en largeur de l'arbre ci-dessus parcours les n\u0153uds dans l'ordre T-Y-O-P-H-N. Algorithme de parcours en largeur Le principe est d'utiliser une file : on commence par enfiler la racine de l'arbre; puis tant que la file n'est pas vide: on d\u00e9file un n\u0153ud; on traite le n\u0153ud; on enfile les fils du n\u0153ud (s'il en poss\u00e8de)","title":"2.1 Parcours en largeur (BFS)"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#22-parcours-en-profondeur-dfs","text":"Parcours en profondeur Le parcours en profondeur d'abord( ou DFS pour Depth-First Search) consiste \u00e0 poursuivre un chemin jusqu'\u00e0 rencontrer une feuille, puis revenir au dernier n\u0153ud o\u00f9 l'on pouvait explorer un autre chemin, etc. Il se d\u00e9finit de mani\u00e8re r\u00e9cursive sur les sous-arbres de l'arbre. Il existe plusieurs parcours d'arbres en profondeur, selon que le traitement de la racine a lieu avant l'exploration des sous-arbres (parcours pr\u00e9fixe ), entre celle du sous-arbre gauche et celle du sous-arbre droit (parcours infixe ) ou apr\u00e8s l'exploration des sous-arbres (parcours postfixe/suffixe ). Algorithmes de parcours en profondeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: traiter(A.racine) # pr\u00e9fixe: traitement de la racine avant les appels r\u00e9cursifs parcours(A.fils_gauche) parcours(A.fils_droit) Sur cet arbre, le parcours pr\u00e9fixe donne : \\(\\quad\\times \\quad - \\quad x \\quad1\\quad+\\quad y\\quad3\\) En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: parcours(A.fils_gauche) traiter(A.racine) # infixe: traitement de la racine entre les appels r\u00e9cursifs parcours(A.fils_droit) Sur cet arbre, le parcours infixe donne : \\(\\quad x\\quad -\\quad1 \\quad \\times \\quad y \\quad+\\quad 3\\) En pseudo-code: fonction parcours(A: arbre): si A est non vide alors: parcours(A.fils_gauche) parcours(A.fils_droit) traiter(A.racine) # postfixe: traitement de la racine apr\u00e8s les appels r\u00e9cursifs Sur cet arbre, le parcours postfixe donne : \\(\\quad x\\quad 1\\quad-\\quad y\\quad3\\quad+\\quad\\times\\)","title":"2.2 Parcours en profondeur (DFS)"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#3-implementation-dun-arbre-binaire","text":"Python ne propose pas de fa\u00e7on native l\u2019impl\u00e9mentation des arbres binaires. Il est cependant tr\u00e8s ais\u00e9 de d\u00e9finir un arbre binaire en d\u00e9finissant des classes Arbre et Noeud : 1 2 3 4 5 6 7 8 9 10 11 class Noeud : def __init__ ( self , v , g = None , d = None ): self . valeur = v self . gauche = g # type Noeud self . droit = d # type Noeud class Arbre : def __init__ ( self , racine = None ): self . racine = racine # type : Noeud arbre = Arbre ( Noeud ( \"A\" ))","title":"3. Impl\u00e9mentation d'un arbre binaire"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.2_Arbres_binaires/#4-exercices","text":"Exercice 4 \u00c9nonc\u00e9 Correction Dessiner: les arbres binaires \u00e0 1 n\u0153ud; les arbres binaires \u00e0 2 n\u0153uds; les arbres binaires \u00e0 3 n\u0153uds; les arbres binaires \u00e0 4 n\u0153uds; Sans les dessiner, d\u00e9nombrer le nombre d'arbres binaires \u00e0 5 n\u0153uds. Exercice 5 \u00c9nonc\u00e9 Correction Effectuer sur l'arbre suivant: un parcours pr\u00e9fixe un parcours infixe un parcours postfixe Exercice 6 Arbre 1 Arbre 2 Correction Sur l'arbre suivant: Donner sa taille et sa hauteur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours en largeur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours pr\u00e9fixe, puis dans un parcours infixe et enfin dans un parcours postfixe. Sur l'arbre suivant: Donner sa taille et sa hauteur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours en largeur. Donner l'ordre des n\u0153uds visit\u00e9s dans un parcours pr\u00e9fixe, puis dans un parcours infixe et enfin dans un parcours postfixe. Exercice 7 \u00c9nonc\u00e9 Correction \u00c0 l'aide des classe Arbre et Noeud , cr\u00e9er une instance d' Arbre repr\u00e9sentant l'arbre: Exercice 8 \u00c9nonc\u00e9 Correction On d\u00e9finit un arbre par les instructions suivantes: 1 2 3 4 5 6 7 8 ng = Noeud ( 9 ) nd = Noeud ( 4 ) ng = Noeud ( 1 , ng , nd ) nd = Noeud ( 12 ) nd = Noeud ( 6 , ng , nd ) ngd = Noeud ( 3 ) ng = Noeud ( 10 , d = ngd ) arbre = Arbre ( Noeud ( 5 , ng , nd )) Repr\u00e9senter graphiquement cet arbre.","title":"4. Exercices"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.3_ABR/","text":"Arbres Binaires de Recherche (ABR) \u2693\ufe0e","title":"Arbres Binaires de Recherche (ABR)"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4.3_ABR/#arbres-binaires-de-recherche-abr","text":"","title":"Arbres Binaires de Recherche (ABR)"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4_TP/","text":"TP Arbres binaires \u2693\ufe0e Objectif Dans ce TP, il s'agit d'utiliser l'impl\u00e9mentation POO d'un arbre binaire et d'impl\u00e9menter des fonctions: de calcul de taille de calcul de hauteur de parcours (largeur, pr\u00e9fixe, infixe, postfixe)","title":"TP Arbres binaires"},{"location":"T01_StructuresDonnees/T1.4_Arbres/T1.4_TP/#tp-arbres-binaires","text":"Objectif Dans ce TP, il s'agit d'utiliser l'impl\u00e9mentation POO d'un arbre binaire et d'impl\u00e9menter des fonctions: de calcul de taille de calcul de hauteur de parcours (largeur, pr\u00e9fixe, infixe, postfixe)","title":"TP Arbres binaires"},{"location":"T02_Programmation/accueil/","text":"Th\u00e8me 2 : Langages et Programmation \u2693\ufe0e Histoire de l'informatique En 1962, Ole-Johan Dahl et Kristen Nygaard cr\u00e9ent le langage Simula, premier langage \u00e0 classes. Au d\u00e9but des ann\u00e9es 1970, Alan Kay s'inspire de Simula pour cr\u00e9er le langage Smalltalk, qui est le premier langage orient\u00e9 objet . Aujourd'hui, il existe de nombreux langages \u00e0 objets, sous forme fonctionnelle , imp\u00e9rative , ou les deux, comme Python par exemple.","title":"Th\u00e8me 2 : Langages et Programmation"},{"location":"T02_Programmation/accueil/#theme-2-langages-et-programmation","text":"Histoire de l'informatique En 1962, Ole-Johan Dahl et Kristen Nygaard cr\u00e9ent le langage Simula, premier langage \u00e0 classes. Au d\u00e9but des ann\u00e9es 1970, Alan Kay s'inspire de Simula pour cr\u00e9er le langage Smalltalk, qui est le premier langage orient\u00e9 objet . Aujourd'hui, il existe de nombreux langages \u00e0 objets, sous forme fonctionnelle , imp\u00e9rative , ou les deux, comme Python par exemple.","title":"Th\u00e8me 2 : Langages et Programmation"},{"location":"T02_Programmation/T2.1_POO/T2.1_Exercices/","text":"T2.1 POO: Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Compl\u00e9ter la classe Balle avec la m\u00e9thode avance qui doit actualiser les coordonn\u00e9es de l'objet en g\u00e9rant les rebonds sur les bords de la fen\u00eatre. Cr\u00e9er une liste de 100 instances de cette classe et compl\u00e9ter la boucle des \u00e9v\u00e9nements. Si possible, g\u00e9rer les collisions... Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une classe Voiture qui contiendra les attributs kilometrage , consommation dont les valeurs seront donn\u00e9es comme arguments \u00e0 l'initialisation et un attribut carburant valant 0 par d\u00e9faut. Doter la classe d'une m\u00e9thode affiche qui donne le kilom\u00e9trage et le carburant disponible. Doter la classe d'une m\u00e9thode remplir qui prend en argument un entier correspondant au volume de carburant \u00e0 ajouter au r\u00e9servoir. Doter la classe d'une m\u00e9thode avance qui prend en argument un entier correspondant au nombre de kilom\u00e8tres parcourus et qui actualise les valeurs des attributs kilometrage et consommation . Exemple d'utilisation de la classe >>> christine = Voiture ( 0 , 8 ) La voiture a parcouru 0 kilom\u00e8tres et il y a 0 litres d 'essence dans le r\u00e9servoir. >>> christine . affiche () >>> christine . remplir ( 25 ) >>> christine . avance ( 200 ) >>> christine . affiche () La voiture a parcouru 200 kilom\u00e8tres et il y a 9.0 litres d 'essence dans le r\u00e9servoir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Voiture : def __init__ ( self , kil , conso ): self . kilometrage = kil self . consommation = conso self . carburant = 0 def affiche ( self ): return f 'La voiture a parcouru { self . kilometrage } kilom\u00e8tres et il y a { self . carburant } litres d essence dans le r\u00e9servoir.' ) def remplir ( self , litres ): self . carburant += litres def avance ( self , kilometres ): self . kilometrage += kilometres self . carburant -= kilometres / 100 * self . consommation Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): return f 'Il est { self . heures } heures, { self . minutes } minutes et { self . secondes } secondes.' def avance ( self , s ): self . secondes += s self . minutes += self . secondes // 60 self . secondes = self . secondes % 60 self . heures += self . minutes // 60 self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 Exercice 5 \u00c9nonc\u00e9 Correction On souhaite construire une base d'objets servant \u00e0 cr\u00e9er des jeux utilisant des d\u00e9s. Un d\u00e9 doit poss\u00e9der un nombre de faces, ainsi qu'une valeur (la face sup\u00e9rieure du d\u00e9 une fois qu'on l'a lanc\u00e9, et la valeur -1 s'il n'a pas encore \u00e9t\u00e9 lanc\u00e9). On doit pouvoir lancer le d\u00e9, c'est-\u00e0-dire lui attribuer une valeur al\u00e9atoire entre 1 et son nombre de faces). Un jeu de d\u00e9s poss\u00e8de un nombre de d\u00e9s ainsi qu'un ensemble de ces d\u00e9s. On doit pouvoir lancer tous les d\u00e9s (en une fois), faire la somme des valeurs des d\u00e9s, et on souhaite afficher la valeur des d\u00e9s ainsi que leur somme. Questions: Cr\u00e9er un diagramme de classe pour deux classes repr\u00e9sentant ce probl\u00e8me: une classe Jeu et une classe De . \u00c9crire les classes, sachant qu'une instance de classe Jeu doit prendre en arguments le nombre de d\u00e9s et le nombre de faces de chaque d\u00e9 (identique pour tous les d\u00e9s), et qu'une instance de classe De doit prendre en argument son nombre de faces. Exemples d'utilisation >>> j = Jeu ( 3 , 6 ) #pour cr\u00e9er un jeu de 3 d\u00e9s \u00e0 6 faces >>> print ( j ) Les d\u00e9s n 'ont pas \u00e9t\u00e9 lanc\u00e9s >>> j . lancer () >>> j . somme () 13 >>> print ( j ) Les d\u00e9s valent 2 , 5 et 6 et leur somme vaut 13. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import random class Jeu : def __init__ ( self , n , f ): self . nb_des = n self . faces_de = f self . des = [ De ( self . faces_de ) for _ in range ( self . nb_des )] def lancer ( self ): for de in self . des : de . lancer () def somme ( self ): s = 0 for de in self . des : s += de . valeur return s # ou return sum([de.valeur for de in self.des]) def __str__ ( self ): if self . somme () < 0 : return 'Les d\u00e9s n ont pas \u00e9t\u00e9 lanc\u00e9s' else : valeurs = ', ' . join ([ str ( self . des [ k ] . valeur ) for k in range ( self . nb_des - 1 )]) return f 'Les d\u00e9s valent { valeurs } et { self . des [ - 1 ] . valeur } et leur somme vaut { self . somme () } .' class De (): def __init__ ( self , n ): self . nb_faces = n self . valeur = - 1 def lancer ( self ): self . valeur = random . randint ( 1 , self . nb_faces ) j = Jeu ( 3 , 6 )","title":"T2.1 POO: Exercices"},{"location":"T02_Programmation/T2.1_POO/T2.1_Exercices/#t21-poo-exercices","text":"Exercice 1 \u00c9nonc\u00e9 Correction Compl\u00e9ter la classe Balle avec la m\u00e9thode avance qui doit actualiser les coordonn\u00e9es de l'objet en g\u00e9rant les rebonds sur les bords de la fen\u00eatre. Cr\u00e9er une liste de 100 instances de cette classe et compl\u00e9ter la boucle des \u00e9v\u00e9nements. Si possible, g\u00e9rer les collisions... Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une classe Voiture qui contiendra les attributs kilometrage , consommation dont les valeurs seront donn\u00e9es comme arguments \u00e0 l'initialisation et un attribut carburant valant 0 par d\u00e9faut. Doter la classe d'une m\u00e9thode affiche qui donne le kilom\u00e9trage et le carburant disponible. Doter la classe d'une m\u00e9thode remplir qui prend en argument un entier correspondant au volume de carburant \u00e0 ajouter au r\u00e9servoir. Doter la classe d'une m\u00e9thode avance qui prend en argument un entier correspondant au nombre de kilom\u00e8tres parcourus et qui actualise les valeurs des attributs kilometrage et consommation . Exemple d'utilisation de la classe >>> christine = Voiture ( 0 , 8 ) La voiture a parcouru 0 kilom\u00e8tres et il y a 0 litres d 'essence dans le r\u00e9servoir. >>> christine . affiche () >>> christine . remplir ( 25 ) >>> christine . avance ( 200 ) >>> christine . affiche () La voiture a parcouru 200 kilom\u00e8tres et il y a 9.0 litres d 'essence dans le r\u00e9servoir. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Voiture : def __init__ ( self , kil , conso ): self . kilometrage = kil self . consommation = conso self . carburant = 0 def affiche ( self ): return f 'La voiture a parcouru { self . kilometrage } kilom\u00e8tres et il y a { self . carburant } litres d essence dans le r\u00e9servoir.' ) def remplir ( self , litres ): self . carburant += litres def avance ( self , kilometres ): self . kilometrage += kilometres self . carburant -= kilometres / 100 * self . consommation Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): return f 'Il est { self . heures } heures, { self . minutes } minutes et { self . secondes } secondes.' def avance ( self , s ): self . secondes += s self . minutes += self . secondes // 60 self . secondes = self . secondes % 60 self . heures += self . minutes // 60 self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 Exercice 5 \u00c9nonc\u00e9 Correction On souhaite construire une base d'objets servant \u00e0 cr\u00e9er des jeux utilisant des d\u00e9s. Un d\u00e9 doit poss\u00e9der un nombre de faces, ainsi qu'une valeur (la face sup\u00e9rieure du d\u00e9 une fois qu'on l'a lanc\u00e9, et la valeur -1 s'il n'a pas encore \u00e9t\u00e9 lanc\u00e9). On doit pouvoir lancer le d\u00e9, c'est-\u00e0-dire lui attribuer une valeur al\u00e9atoire entre 1 et son nombre de faces). Un jeu de d\u00e9s poss\u00e8de un nombre de d\u00e9s ainsi qu'un ensemble de ces d\u00e9s. On doit pouvoir lancer tous les d\u00e9s (en une fois), faire la somme des valeurs des d\u00e9s, et on souhaite afficher la valeur des d\u00e9s ainsi que leur somme. Questions: Cr\u00e9er un diagramme de classe pour deux classes repr\u00e9sentant ce probl\u00e8me: une classe Jeu et une classe De . \u00c9crire les classes, sachant qu'une instance de classe Jeu doit prendre en arguments le nombre de d\u00e9s et le nombre de faces de chaque d\u00e9 (identique pour tous les d\u00e9s), et qu'une instance de classe De doit prendre en argument son nombre de faces. Exemples d'utilisation >>> j = Jeu ( 3 , 6 ) #pour cr\u00e9er un jeu de 3 d\u00e9s \u00e0 6 faces >>> print ( j ) Les d\u00e9s n 'ont pas \u00e9t\u00e9 lanc\u00e9s >>> j . lancer () >>> j . somme () 13 >>> print ( j ) Les d\u00e9s valent 2 , 5 et 6 et leur somme vaut 13. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import random class Jeu : def __init__ ( self , n , f ): self . nb_des = n self . faces_de = f self . des = [ De ( self . faces_de ) for _ in range ( self . nb_des )] def lancer ( self ): for de in self . des : de . lancer () def somme ( self ): s = 0 for de in self . des : s += de . valeur return s # ou return sum([de.valeur for de in self.des]) def __str__ ( self ): if self . somme () < 0 : return 'Les d\u00e9s n ont pas \u00e9t\u00e9 lanc\u00e9s' else : valeurs = ', ' . join ([ str ( self . des [ k ] . valeur ) for k in range ( self . nb_des - 1 )]) return f 'Les d\u00e9s valent { valeurs } et { self . des [ - 1 ] . valeur } et leur somme vaut { self . somme () } .' class De (): def __init__ ( self , n ): self . nb_faces = n self . valeur = - 1 def lancer ( self ): self . valeur = random . randint ( 1 , self . nb_faces ) j = Jeu ( 3 , 6 )","title":"T2.1 POO: Exercices"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO1/","text":"T2.1 POO : Programmation Orient\u00e9e Objet (part one) \u2693\ufe0e 2.1.1 Retour sur le TP \u2693\ufe0e Et si maintenant on doit cr\u00e9er 100 balles qui rebondissent? 2.1.2 Introduction \u2693\ufe0e Paradigme Objet La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. Mais qu'est-ce qu'un objet? Vocabulaire En POO, une classe est un mod\u00e8le (on parle parfois de moule) de cr\u00e9ation d\u2019objets (en Python c\u2019est un type). Un objet est une valeur (au sens large), instance d\u2019une classe. La classe permet de d\u00e9finir quels seront les attributs (ou variables d\u2019instance , c\u2019est \u00e0 dire les donn\u00e9es associ\u00e9es \u00e0 l\u2019objet, qui le caract\u00e9risent) et les m\u00e9thodes (comportement de l\u2019objet) qui sont des fonctions qui s'appliquent uniquement aux objets de cette classe. Nous en avons d\u00e9j\u00e0 manipul\u00e9s sans le savoir: >>> n = 42 >>> type ( n ) < class ' int '> n est une instance de classe int . Dans l'inspecteur d'objet de Thonny, on observe que cet objet poss\u00e8de des attributs (comme real par exemple) ainsi que des m\u00e9thodes (comme bit_length par exemple). On manipule ces objets (attributs et m\u00e9thodes) par la notation point\u00e9e sp\u00e9cifique \u00e0 la POO... >>> n . real 42 >>> n . bit_length () 6 Un autre exemple avec la classe list bien connue: >>> tab = [ 1 , 2 , 3 ] >>> type ( tab ) < class ' list '> >>> tab . append ( 4 ) >>> tab [ 1 , 2 , 3 , 4 ] 2.1.3 Cr\u00e9ation d'une classe \u2693\ufe0e Cr\u00e9ons une classe permettant de structurer l'objet \u00abballe\u00bb du DL2. D\u00e9finition de la classe On d\u00e9finit le nom d'une classe avec le mot-cl\u00e9 class , avec une majuscule (par convention): 1 2 class Balle : pass On peut d\u00e8s \u00e0 pr\u00e9sent cr\u00e9er une instance de Balle , mais avec une d\u00e9finition aussi pauvre, on ne peut pas en faire grand chose, sauf cr\u00e9er des attributs de fa\u00e7on anarchique: >>> b = Balle () >>> type ( b ) < class ' __main__ . Balle '> >>> b . x = 1 >>> b . nimp = True M\u00e9thode constructeur Il s'agit de munir une instance de ses attributs d\u00e8s sa cr\u00e9ation, \u00e0 l'aide de la m\u00e9thode sp\u00e9ciale (ou magique ) __init__ qui comme son nom l'indique, initialise les attributs de l'objet avec les valeurs pass\u00e9es en param\u00e8tre. C'est un passage oblig\u00e9 . Avec param\u00e8tres Sans (tous les) param\u00e8tres La fa\u00e7on classique de d\u00e9finir un objet est de donner les valeurs de ses attributs lors de la cr\u00e9ation. 1 2 3 4 5 6 7 8 class Balle : def __init__ ( self , abscisse , ordonnee , dep_h , dep_v , coul , r ): self . x = abscisse self . y = ordonnee self . dx = dep_h self . dy = dep_v self . couleur = coul self . rayon = r On peut alors cr\u00e9er un objet Balle , de position de d\u00e9part (10, 50) , de d\u00e9placement (2, 3) , rouge et de rayon 8: >>> b = Balle ( 10 , 50 , 2 , 3 , ( 255 , 0 , 0 ), 8 ) On peut aussi affecter des valeurs identiques pour toutes les instances d'une classe, ou bien les choisir al\u00e9atoirement. 1 2 3 4 5 6 7 8 9 10 11 12 import random width , height = 320 , 240 class Balle : def __init__ ( self , coul ): self . x = random . randint ( 0 , width ) self . y = random . randint ( 0 , height ) self . dx = random . randint ( 2 , 4 ) self . dy = random . randint ( 2 , 4 ) self . couleur = coul self . rayon = 8 Pour d\u00e9clarer un objet, on ne donne ici que sa couleur: >>> b = Balle (( 255 , 110 , 66 )) Param\u00e8tre self Le premier param\u00e8tre d'une m\u00e9thode de classe (comme __init__ ci-dessus) est toujours self . Stricto sensu, ce n'est pas un mot r\u00e9serv\u00e9 du langage Python (mais par convention oui), il sert \u00e0 pr\u00e9ciser que les variables d'instance (les attributs) et les m\u00e9thodes sont propres \u00e0 l'objet que l'on d\u00e9finit dans la classe. Ajout d'une m\u00e9thode On d\u00e9finit les m\u00e9thodes comme des fonctions, dans le corps de la classe (c'est-\u00e0-dire en respectant l'indentation), et avec self en premier param\u00e8tre. 1 2 3 4 5 6 7 8 9 10 11 class Balle : def __init__ ( self , abscisse , ordonnee , dep_h , dep_v , coul , r ): self . x = abscisse self . y = ordonnee self . dx = dep_h self . dy = dep_v self . couleur = coul self . rayon = r def affiche ( self ): pygame . draw . circle ( screen , self . couleur ,( self . x , self . y ), self . rayon ) Dans la fonction circle , on distingue donc screen qui est une variable globale (pas de self ) des autres variables d'instance (pr\u00e9fix\u00e9es par self ). Appel d'une m\u00e9thode On peut appeler une m\u00e9thode de deux fa\u00e7ons (avec obj instance d'une classe Classe poss\u00e9dant une m\u00e9thode methode ): obj.methode(*args) Classe.methode(obj, *args) Bien que ces deux syntaxes sont techniquement identiques, on n'utilise dans la pratique que la premi\u00e8re , mais conna\u00eetre la deuxi\u00e8me permet de comprendre pourquoi le param\u00e8tre self est toujours en premier, pourquoi l\u2019oublier peut produire des bugs difficiles \u00e0 trouver, et pourquoi ce n\u2019est pas un mot r\u00e9serv\u00e9 (c\u2019est un simple nom de param\u00e8tre, mais conventionnellement, on l\u2019appelle self ). Exemple: >>> l = [ 1 , 2 , 3 ] >>> l . append ( 4 ) >>> list . append ( l , 5 ) >>> l [ 1 , 2 , 3 , 4 , 5 ]","title":"T2.1 POO : Programmation Orient\u00e9e Objet (part one)"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO1/#t21-poo-programmation-orientee-objet-part-one","text":"","title":"T2.1 POO : Programmation Orient\u00e9e Objet (part one)"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO1/#211-retour-sur-le-tp","text":"Et si maintenant on doit cr\u00e9er 100 balles qui rebondissent?","title":"2.1.1 Retour sur le TP"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO1/#212-introduction","text":"Paradigme Objet La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. Mais qu'est-ce qu'un objet? Vocabulaire En POO, une classe est un mod\u00e8le (on parle parfois de moule) de cr\u00e9ation d\u2019objets (en Python c\u2019est un type). Un objet est une valeur (au sens large), instance d\u2019une classe. La classe permet de d\u00e9finir quels seront les attributs (ou variables d\u2019instance , c\u2019est \u00e0 dire les donn\u00e9es associ\u00e9es \u00e0 l\u2019objet, qui le caract\u00e9risent) et les m\u00e9thodes (comportement de l\u2019objet) qui sont des fonctions qui s'appliquent uniquement aux objets de cette classe. Nous en avons d\u00e9j\u00e0 manipul\u00e9s sans le savoir: >>> n = 42 >>> type ( n ) < class ' int '> n est une instance de classe int . Dans l'inspecteur d'objet de Thonny, on observe que cet objet poss\u00e8de des attributs (comme real par exemple) ainsi que des m\u00e9thodes (comme bit_length par exemple). On manipule ces objets (attributs et m\u00e9thodes) par la notation point\u00e9e sp\u00e9cifique \u00e0 la POO... >>> n . real 42 >>> n . bit_length () 6 Un autre exemple avec la classe list bien connue: >>> tab = [ 1 , 2 , 3 ] >>> type ( tab ) < class ' list '> >>> tab . append ( 4 ) >>> tab [ 1 , 2 , 3 , 4 ]","title":"2.1.2 Introduction"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO1/#213-creation-dune-classe","text":"Cr\u00e9ons une classe permettant de structurer l'objet \u00abballe\u00bb du DL2. D\u00e9finition de la classe On d\u00e9finit le nom d'une classe avec le mot-cl\u00e9 class , avec une majuscule (par convention): 1 2 class Balle : pass On peut d\u00e8s \u00e0 pr\u00e9sent cr\u00e9er une instance de Balle , mais avec une d\u00e9finition aussi pauvre, on ne peut pas en faire grand chose, sauf cr\u00e9er des attributs de fa\u00e7on anarchique: >>> b = Balle () >>> type ( b ) < class ' __main__ . Balle '> >>> b . x = 1 >>> b . nimp = True M\u00e9thode constructeur Il s'agit de munir une instance de ses attributs d\u00e8s sa cr\u00e9ation, \u00e0 l'aide de la m\u00e9thode sp\u00e9ciale (ou magique ) __init__ qui comme son nom l'indique, initialise les attributs de l'objet avec les valeurs pass\u00e9es en param\u00e8tre. C'est un passage oblig\u00e9 . Avec param\u00e8tres Sans (tous les) param\u00e8tres La fa\u00e7on classique de d\u00e9finir un objet est de donner les valeurs de ses attributs lors de la cr\u00e9ation. 1 2 3 4 5 6 7 8 class Balle : def __init__ ( self , abscisse , ordonnee , dep_h , dep_v , coul , r ): self . x = abscisse self . y = ordonnee self . dx = dep_h self . dy = dep_v self . couleur = coul self . rayon = r On peut alors cr\u00e9er un objet Balle , de position de d\u00e9part (10, 50) , de d\u00e9placement (2, 3) , rouge et de rayon 8: >>> b = Balle ( 10 , 50 , 2 , 3 , ( 255 , 0 , 0 ), 8 ) On peut aussi affecter des valeurs identiques pour toutes les instances d'une classe, ou bien les choisir al\u00e9atoirement. 1 2 3 4 5 6 7 8 9 10 11 12 import random width , height = 320 , 240 class Balle : def __init__ ( self , coul ): self . x = random . randint ( 0 , width ) self . y = random . randint ( 0 , height ) self . dx = random . randint ( 2 , 4 ) self . dy = random . randint ( 2 , 4 ) self . couleur = coul self . rayon = 8 Pour d\u00e9clarer un objet, on ne donne ici que sa couleur: >>> b = Balle (( 255 , 110 , 66 )) Param\u00e8tre self Le premier param\u00e8tre d'une m\u00e9thode de classe (comme __init__ ci-dessus) est toujours self . Stricto sensu, ce n'est pas un mot r\u00e9serv\u00e9 du langage Python (mais par convention oui), il sert \u00e0 pr\u00e9ciser que les variables d'instance (les attributs) et les m\u00e9thodes sont propres \u00e0 l'objet que l'on d\u00e9finit dans la classe. Ajout d'une m\u00e9thode On d\u00e9finit les m\u00e9thodes comme des fonctions, dans le corps de la classe (c'est-\u00e0-dire en respectant l'indentation), et avec self en premier param\u00e8tre. 1 2 3 4 5 6 7 8 9 10 11 class Balle : def __init__ ( self , abscisse , ordonnee , dep_h , dep_v , coul , r ): self . x = abscisse self . y = ordonnee self . dx = dep_h self . dy = dep_v self . couleur = coul self . rayon = r def affiche ( self ): pygame . draw . circle ( screen , self . couleur ,( self . x , self . y ), self . rayon ) Dans la fonction circle , on distingue donc screen qui est une variable globale (pas de self ) des autres variables d'instance (pr\u00e9fix\u00e9es par self ). Appel d'une m\u00e9thode On peut appeler une m\u00e9thode de deux fa\u00e7ons (avec obj instance d'une classe Classe poss\u00e9dant une m\u00e9thode methode ): obj.methode(*args) Classe.methode(obj, *args) Bien que ces deux syntaxes sont techniquement identiques, on n'utilise dans la pratique que la premi\u00e8re , mais conna\u00eetre la deuxi\u00e8me permet de comprendre pourquoi le param\u00e8tre self est toujours en premier, pourquoi l\u2019oublier peut produire des bugs difficiles \u00e0 trouver, et pourquoi ce n\u2019est pas un mot r\u00e9serv\u00e9 (c\u2019est un simple nom de param\u00e8tre, mais conventionnellement, on l\u2019appelle self ). Exemple: >>> l = [ 1 , 2 , 3 ] >>> l . append ( 4 ) >>> list . append ( l , 5 ) >>> l [ 1 , 2 , 3 , 4 , 5 ]","title":"2.1.3 Cr\u00e9ation d'une classe"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/","text":"T2.1 POO (part two) \u2693\ufe0e 2.1.4 Des inconv\u00e9nients \u2693\ufe0e Mauvaise utilisation \u2693\ufe0e Reprenons l'exemple de la classe Voiture de l'exercice 2 et imaginons l'utilisation suivante: >>> dmc12 = Voiture ( 0 , 20 ) >>> dmc12 . remplir ( 25000 ) >>> dmc12 . avance ( - 500 ) >>> dmc12 . affiche () La voiture a parcouru - 500 kilom\u00e8tres et il y a 25100.0 litres d 'essence dans le r\u00e9servoir. Quels probl\u00e8mes illustre cet exemple? Diff\u00e9rentes impl\u00e9mentations \u2693\ufe0e Revenons maintenant sur la classe Chrono de l'exercice 3. L'objectif de cette classe est de manipuler un chronom\u00e8tre, et donc d'utiliser exclusivement les m\u00e9thodes affiche et avance . On aurait donc tr\u00e8s bien pu ne g\u00e9rer qu'un seul attribut temps donnant le temps en secondes, et de calculer les heures et minutes \u00e0 partir de la valeur de ceta ttribut. Par exemple: 1 2 3 4 5 6 7 8 9 10 11 12 class Chrono : def __init__ ( self , t ): self . temps = t def affiche ( self ): h = self . temps // 3600 m = self . temps // 60 - 60 * h s = self . temps - 3600 * h - 60 * m return f 'Il est { h } heures, { m } minutes et { s } secondes.' def avance ( self , s ): self . temps += s 2.1.5 Un rem\u00e8de: l'encapsulation \u2693\ufe0e Priv\u00e9 \u2260 Public Dans la philosophie de la POO, les attributs doivent \u00eatre priv\u00e9s , c'est \u00e0 dire qu'ils ne doivent pas \u00eatre modifiables directement. Leur manipulation doit se faire uniquement par des m\u00e9thodes. L'utilisateur ne doit pas avoir besoin de conna\u00eetre ces attributs, cela reste dans les choix d'impl\u00e9mentation. Les m\u00e9thodes, elles, sont publiques : elles constituent ce qu'on appelle l' interface de la classe. Pour acc\u00e9der ou modifier les valeurs des attributs, on passe donc par des m\u00e9thodes d\u00e9di\u00e9es : c'est le principe de l' encapsulation . Exemple: accesseurs et mutateurs 1 2 3 4 5 6 7 8 9 10 11 12 class Voiture : def __init__ ( self , k , conso ): self . kilometrage = k self . consommation = conso self . carburant = 0 def get_kilometrage ( self ): return self . kilometrage def set_kilometrage ( self , k ): if k > get_kilometrage (): self . kilometrage = k \u25b6 La m\u00e9thode get_kilometrage est ce qu'on appelle un accesseur ( getter en anglais). Sa seule et unique vocation est de donner la valeur de l'attribut correspondant, celui-ci n'\u00e9tant pas accessible puisque priv\u00e9. \u25b6 La m\u00e9thode set_kilometrage est ce qu'on appelle un mutateur ( setter en anglais). Il permet de modifier la valeur de l'attribut, en permettant d'effectuer tous les contr\u00f4les \u00e9ventuels sur cette valeur . Exercice 6 \u00c9nonc\u00e9 Correction \u00c9crire un accesseur et un mutateur pour l'attribut carburant . R\u00e9\u00e9crire la m\u00e9thode avance de la classe Voiture en utilisant les accesseurs et mutateurs. Exercice 7 \u00c9nonc\u00e9 Correction Reprendre la classe Chrono (impl\u00e9mentation ci-dessus, avec un seul attribut) en ajoutant les m\u00e9thodes getter et setter (avec contr\u00f4le sur l'argument) et en modifiant les m\u00e9thodes existantes. 2.1.6 Compl\u00e9ments (Hors programme) \u2693\ufe0e M\u00e9thodes sp\u00e9ciales \u2693\ufe0e Les m\u00e9thodes sp\u00e9ciales (parfois appel\u00e9es m\u00e9thodes magiques) sont encadr\u00e9es par des __ . Ces m\u00e9thodes (il en existe environ une centaine) sont appel\u00e9es dans des contextes particuliers (par exemple __init__ est appel\u00e9e apr\u00e8s que l\u2019objet a \u00e9t\u00e9 allou\u00e9, pour initialiser ses attributs). Utiliser __init__ est un passage oblig\u00e9. Un autre passage presque oblig\u00e9 est l\u2019obtention d\u2019un affichage human-friendly d\u2019un objet, ce qu'on a fait avec nos fonctions affiche dans les exemples/exercices pr\u00e9c\u00e9dents. __str__ : donne une repr\u00e9sentation de l'objet en cha\u00eene de caract\u00e8res d\u00e8s que Python en a besoin, par exemple pour print . __repr__ : est utilis\u00e9e pour afficher l'objet lors de son \u00e9valuation, en console par exemple. S\u2019il n\u2019y a pas de m\u00e9thode __str__ c\u2019est __repr__ qui est utilis\u00e9e lors d\u2019un affichage avec print . __len__ est appel\u00e9e automatiquement si on demande la taille d\u2019un objet avec la fonction len . Exemples Avec une m\u00e9thode normale Avec __str__ Avec __repr__ La m\u00e9thode __len__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def affiche ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c < __main__ . Chrono object at 0x7fc8986c7cd0 > >>> print ( c ) < __main__ . Chrono object at 0x7fc8986c7cd0 > >>> c . affiche () 'Il est 0 heures, 32 minutes et 58 secondes.' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def __str__ ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c < __main__ . Chrono object at 0x7f701d943460 > >>> print ( c ) Il est 0 heures , 32 minutes et 58 secondes . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def __repr__ ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c Il est 0 heures , 32 minutes et 58 secondes . >>> print ( c ) Il est 0 heures , 32 minutes et 58 secondes . Avec cette m\u00e9thode sp\u00e9ciale, on d\u00e9cide de ce que signifie la taille (longueur) de l'objet (si cela signifie quelque chose, n'est-ce pas... ). Si elle n'est pas d\u00e9finie dans la classe, appeler la fonction len entra\u00eenera une erreur: TypeError : object of type 'Chrono' has no len () 1 2 3 4 5 6 7 8 class Parcours : def __init__ ( self , spes , options ): self . trc = [ 'Philo' , 'HG' , 'LVA' , 'LVB' , 'ES' , 'EPS' ] self . spes = spes self . options = options def __len__ ( self ): return len ( self . trc ) + len ( self . spes ) + len ( self . options ) >>> mpi = Parcours ([ 'Maths' , 'NSI' ], [ 'Maths expertes' ]) >>> len ( mpi ) 9 Propri\u00e9t\u00e9s \u2693\ufe0e En POO, Python permet de combiner: le respect des getters et setters (probl\u00e8me g\u00e9n\u00e9ral \u00e0 la POO); la souplesse syntaxique de la manipulation des attributs . On utilise pour cela des propri\u00e9t\u00e9s . Pour l'illustrer, on observe une classe Point qui repr\u00e9sente un point par une abscisse et une ordonn\u00e9e (comme c'est original) positives 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point : def __init__ ( self , x , y ): self . _x = x self . _y = y def get_x ( self ): return self . _x def set_x ( self , x ): if x >= 0 : self . _x = x # idem pour y x = property ( get_x , set_x ) y = property ( get_y , set_y ) Dans le code qui pr\u00e9c\u00e8de, _x est un attribut, get_x et set_x sont des m\u00e9thodes (qui se trouvent \u00eatre un getter et un setter ), et x est une propri\u00e9t\u00e9. Si on \u00e9crit \u00e0 pr\u00e9sent : >>> p = Point ( 1 , 0 ) >>> p . x 1 >>> p . x = - 2 >>> p . x 1 >>> p . x += 3 >>> p . x 4 En utilisant la propri\u00e9t\u00e9 x , Python utilise automatiquement le getter ou le setter selon le contexte. Noter que dans p.x += 3 , le getter et le setter sont utilis\u00e9s. D\u00e9corateurs \u2693\ufe0e Voici une autre syntaxe possible, mais on n'a plus acc\u00e8s directement aux getter et setter. 1 2 3 4 5 6 7 8 9 10 11 12 class Point : def __init__ ( self , x , y ): self . _x = x self . _y = y @property def x ( self ): return self . _x @x . setter def x ( self , x ): self . _x = x H\u00e9ritage \u2693\ufe0e Un des piliers de la POO (mais hors-programme) est le concept d' h\u00e9ritage . En bref, cela signifie qu'une classe peut \u00eatre \u00e9crite \u00e0 partir d'une classe parent d\u00e9j\u00e0 existante, et donc h\u00e9ritera de ses attributs et m\u00e9thodes. Par exemple, si on veut des points color\u00e9s, il suffit d'ajouter un atttibut de couleur \u00e0 la classe pr\u00e9c\u00e9dente. 1 2 3 4 class PointColore ( Point ): def __init__ ( self , x , y , couleur ): super () . __init__ ( x , y ) self . couleur = couleur On signale que la classe PointColore h\u00e9rite de la classe parent Point (ligne 1). Ensuite, la m\u00e9thode __init__ a \u00e9t\u00e9 red\u00e9finie. On notera l\u2019appel \u00e0 la m\u00e9thode __init__ de la classe parent en utilisant super pour les attributs de la classe Point . Toute instance de la classe PointColore b\u00e9n\u00e9ficie des m\u00e9thodes dej\u00e0 existantes dans Point , sans avoir besoin de les red\u00e9finir.","title":"T2.1 POO (part two)"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#t21-poo-part-two","text":"","title":"T2.1 POO (part two)"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#214-des-inconvenients","text":"","title":"2.1.4 Des inconv\u00e9nients"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#mauvaise-utilisation","text":"Reprenons l'exemple de la classe Voiture de l'exercice 2 et imaginons l'utilisation suivante: >>> dmc12 = Voiture ( 0 , 20 ) >>> dmc12 . remplir ( 25000 ) >>> dmc12 . avance ( - 500 ) >>> dmc12 . affiche () La voiture a parcouru - 500 kilom\u00e8tres et il y a 25100.0 litres d 'essence dans le r\u00e9servoir. Quels probl\u00e8mes illustre cet exemple?","title":"Mauvaise utilisation"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#differentes-implementations","text":"Revenons maintenant sur la classe Chrono de l'exercice 3. L'objectif de cette classe est de manipuler un chronom\u00e8tre, et donc d'utiliser exclusivement les m\u00e9thodes affiche et avance . On aurait donc tr\u00e8s bien pu ne g\u00e9rer qu'un seul attribut temps donnant le temps en secondes, et de calculer les heures et minutes \u00e0 partir de la valeur de ceta ttribut. Par exemple: 1 2 3 4 5 6 7 8 9 10 11 12 class Chrono : def __init__ ( self , t ): self . temps = t def affiche ( self ): h = self . temps // 3600 m = self . temps // 60 - 60 * h s = self . temps - 3600 * h - 60 * m return f 'Il est { h } heures, { m } minutes et { s } secondes.' def avance ( self , s ): self . temps += s","title":"Diff\u00e9rentes impl\u00e9mentations"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#215-un-remede-lencapsulation","text":"Priv\u00e9 \u2260 Public Dans la philosophie de la POO, les attributs doivent \u00eatre priv\u00e9s , c'est \u00e0 dire qu'ils ne doivent pas \u00eatre modifiables directement. Leur manipulation doit se faire uniquement par des m\u00e9thodes. L'utilisateur ne doit pas avoir besoin de conna\u00eetre ces attributs, cela reste dans les choix d'impl\u00e9mentation. Les m\u00e9thodes, elles, sont publiques : elles constituent ce qu'on appelle l' interface de la classe. Pour acc\u00e9der ou modifier les valeurs des attributs, on passe donc par des m\u00e9thodes d\u00e9di\u00e9es : c'est le principe de l' encapsulation . Exemple: accesseurs et mutateurs 1 2 3 4 5 6 7 8 9 10 11 12 class Voiture : def __init__ ( self , k , conso ): self . kilometrage = k self . consommation = conso self . carburant = 0 def get_kilometrage ( self ): return self . kilometrage def set_kilometrage ( self , k ): if k > get_kilometrage (): self . kilometrage = k \u25b6 La m\u00e9thode get_kilometrage est ce qu'on appelle un accesseur ( getter en anglais). Sa seule et unique vocation est de donner la valeur de l'attribut correspondant, celui-ci n'\u00e9tant pas accessible puisque priv\u00e9. \u25b6 La m\u00e9thode set_kilometrage est ce qu'on appelle un mutateur ( setter en anglais). Il permet de modifier la valeur de l'attribut, en permettant d'effectuer tous les contr\u00f4les \u00e9ventuels sur cette valeur . Exercice 6 \u00c9nonc\u00e9 Correction \u00c9crire un accesseur et un mutateur pour l'attribut carburant . R\u00e9\u00e9crire la m\u00e9thode avance de la classe Voiture en utilisant les accesseurs et mutateurs. Exercice 7 \u00c9nonc\u00e9 Correction Reprendre la classe Chrono (impl\u00e9mentation ci-dessus, avec un seul attribut) en ajoutant les m\u00e9thodes getter et setter (avec contr\u00f4le sur l'argument) et en modifiant les m\u00e9thodes existantes.","title":"2.1.5 Un rem\u00e8de: l'encapsulation"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#216-complements-hors-programme","text":"","title":"2.1.6 Compl\u00e9ments (Hors programme)"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#methodes-speciales","text":"Les m\u00e9thodes sp\u00e9ciales (parfois appel\u00e9es m\u00e9thodes magiques) sont encadr\u00e9es par des __ . Ces m\u00e9thodes (il en existe environ une centaine) sont appel\u00e9es dans des contextes particuliers (par exemple __init__ est appel\u00e9e apr\u00e8s que l\u2019objet a \u00e9t\u00e9 allou\u00e9, pour initialiser ses attributs). Utiliser __init__ est un passage oblig\u00e9. Un autre passage presque oblig\u00e9 est l\u2019obtention d\u2019un affichage human-friendly d\u2019un objet, ce qu'on a fait avec nos fonctions affiche dans les exemples/exercices pr\u00e9c\u00e9dents. __str__ : donne une repr\u00e9sentation de l'objet en cha\u00eene de caract\u00e8res d\u00e8s que Python en a besoin, par exemple pour print . __repr__ : est utilis\u00e9e pour afficher l'objet lors de son \u00e9valuation, en console par exemple. S\u2019il n\u2019y a pas de m\u00e9thode __str__ c\u2019est __repr__ qui est utilis\u00e9e lors d\u2019un affichage avec print . __len__ est appel\u00e9e automatiquement si on demande la taille d\u2019un objet avec la fonction len . Exemples Avec une m\u00e9thode normale Avec __str__ Avec __repr__ La m\u00e9thode __len__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def affiche ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c < __main__ . Chrono object at 0x7fc8986c7cd0 > >>> print ( c ) < __main__ . Chrono object at 0x7fc8986c7cd0 > >>> c . affiche () 'Il est 0 heures, 32 minutes et 58 secondes.' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def __str__ ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c < __main__ . Chrono object at 0x7f701d943460 > >>> print ( c ) Il est 0 heures , 32 minutes et 58 secondes . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Chrono : def __init__ ( self , t ): self . temps = t def get_h ( self ): return self . temps // 3600 def get_m ( self ): return self . temps // 60 - 60 * self . get_h def get_s ( self ): return self . temps - 3600 * self . get_h - 60 * self . get_m def __repr__ ( self ): return f 'Il est { self . get_h } heures, { self . get_m } minutes et { self . get_s } secondes.' Utilisation en console >>> c = Chrono ( 1978 ) >>> c Il est 0 heures , 32 minutes et 58 secondes . >>> print ( c ) Il est 0 heures , 32 minutes et 58 secondes . Avec cette m\u00e9thode sp\u00e9ciale, on d\u00e9cide de ce que signifie la taille (longueur) de l'objet (si cela signifie quelque chose, n'est-ce pas... ). Si elle n'est pas d\u00e9finie dans la classe, appeler la fonction len entra\u00eenera une erreur: TypeError : object of type 'Chrono' has no len () 1 2 3 4 5 6 7 8 class Parcours : def __init__ ( self , spes , options ): self . trc = [ 'Philo' , 'HG' , 'LVA' , 'LVB' , 'ES' , 'EPS' ] self . spes = spes self . options = options def __len__ ( self ): return len ( self . trc ) + len ( self . spes ) + len ( self . options ) >>> mpi = Parcours ([ 'Maths' , 'NSI' ], [ 'Maths expertes' ]) >>> len ( mpi ) 9","title":"M\u00e9thodes sp\u00e9ciales"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#proprietes","text":"En POO, Python permet de combiner: le respect des getters et setters (probl\u00e8me g\u00e9n\u00e9ral \u00e0 la POO); la souplesse syntaxique de la manipulation des attributs . On utilise pour cela des propri\u00e9t\u00e9s . Pour l'illustrer, on observe une classe Point qui repr\u00e9sente un point par une abscisse et une ordonn\u00e9e (comme c'est original) positives 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point : def __init__ ( self , x , y ): self . _x = x self . _y = y def get_x ( self ): return self . _x def set_x ( self , x ): if x >= 0 : self . _x = x # idem pour y x = property ( get_x , set_x ) y = property ( get_y , set_y ) Dans le code qui pr\u00e9c\u00e8de, _x est un attribut, get_x et set_x sont des m\u00e9thodes (qui se trouvent \u00eatre un getter et un setter ), et x est une propri\u00e9t\u00e9. Si on \u00e9crit \u00e0 pr\u00e9sent : >>> p = Point ( 1 , 0 ) >>> p . x 1 >>> p . x = - 2 >>> p . x 1 >>> p . x += 3 >>> p . x 4 En utilisant la propri\u00e9t\u00e9 x , Python utilise automatiquement le getter ou le setter selon le contexte. Noter que dans p.x += 3 , le getter et le setter sont utilis\u00e9s.","title":"Propri\u00e9t\u00e9s"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#decorateurs","text":"Voici une autre syntaxe possible, mais on n'a plus acc\u00e8s directement aux getter et setter. 1 2 3 4 5 6 7 8 9 10 11 12 class Point : def __init__ ( self , x , y ): self . _x = x self . _y = y @property def x ( self ): return self . _x @x . setter def x ( self , x ): self . _x = x","title":"D\u00e9corateurs"},{"location":"T02_Programmation/T2.1_POO/T2.1_POO2/#heritage","text":"Un des piliers de la POO (mais hors-programme) est le concept d' h\u00e9ritage . En bref, cela signifie qu'une classe peut \u00eatre \u00e9crite \u00e0 partir d'une classe parent d\u00e9j\u00e0 existante, et donc h\u00e9ritera de ses attributs et m\u00e9thodes. Par exemple, si on veut des points color\u00e9s, il suffit d'ajouter un atttibut de couleur \u00e0 la classe pr\u00e9c\u00e9dente. 1 2 3 4 class PointColore ( Point ): def __init__ ( self , x , y , couleur ): super () . __init__ ( x , y ) self . couleur = couleur On signale que la classe PointColore h\u00e9rite de la classe parent Point (ligne 1). Ensuite, la m\u00e9thode __init__ a \u00e9t\u00e9 red\u00e9finie. On notera l\u2019appel \u00e0 la m\u00e9thode __init__ de la classe parent en utilisant super pour les attributs de la classe Point . Toute instance de la classe PointColore b\u00e9n\u00e9ficie des m\u00e9thodes dej\u00e0 existantes dans Point , sans avoir besoin de les red\u00e9finir.","title":"H\u00e9ritage"},{"location":"T02_Programmation/T2.1_POO/T2.1_TP/","text":"TP : introduction \u00e0 Pygame \u2693\ufe0e Introduction \u2693\ufe0e Commencer par consulter les pages: Introduction \u00e0 Pygame Animation simple (sans \u00e9v\u00e9nements) Dessiner avec Pygame \u00c9nonc\u00e9 \u2693\ufe0e \u00c0 partir du code donn\u00e9 en exemple avec une repr\u00e9sentation de la balle par un cercle (cf. Dessiner avec Pygame ), terminer le programme pour faire rebondir la balle sur tous les bords de la fen\u00eatre. Ajouter une deuxi\u00e8me balle, dont la position de d\u00e9part, la couleur et le d\u00e9placement seront al\u00e9atoires (utiliser le module random ). G\u00e9rer la collision entre deux balles: en cr\u00e9ant une fonction distance qui renvoie la distance entre les centres de deux balles; en \u00e9changeant les d\u00e9placements des balles lorsqu'il y a collision.","title":"TP : introduction \u00e0 Pygame"},{"location":"T02_Programmation/T2.1_POO/T2.1_TP/#tp-introduction-a-pygame","text":"","title":"TP : introduction \u00e0 Pygame"},{"location":"T02_Programmation/T2.1_POO/T2.1_TP/#introduction","text":"Commencer par consulter les pages: Introduction \u00e0 Pygame Animation simple (sans \u00e9v\u00e9nements) Dessiner avec Pygame","title":"Introduction"},{"location":"T02_Programmation/T2.1_POO/T2.1_TP/#enonce","text":"\u00c0 partir du code donn\u00e9 en exemple avec une repr\u00e9sentation de la balle par un cercle (cf. Dessiner avec Pygame ), terminer le programme pour faire rebondir la balle sur tous les bords de la fen\u00eatre. Ajouter une deuxi\u00e8me balle, dont la position de d\u00e9part, la couleur et le d\u00e9placement seront al\u00e9atoires (utiliser le module random ). G\u00e9rer la collision entre deux balles: en cr\u00e9ant une fonction distance qui renvoie la distance entre les centres de deux balles; en \u00e9changeant les d\u00e9placements des balles lorsqu'il y a collision.","title":"\u00c9nonc\u00e9"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/","text":"T2.2 R\u00e9cursivit\u00e9 \u2693\ufe0e Voir ici Dans le m\u00eame \u00e9tat d'esprit, chez Google: 2.2.1 Principe \u2693\ufe0e En r\u00e8gle g\u00e9n\u00e9rale, un objet est dit r\u00e9cursif s'il se d\u00e9finit \u00e0 partir de lui-m\u00eame. On trouve donc des acronymes r\u00e9cursifs, comme GNU dans GNU/Linux (GNU is Not Unix), le logiciel d'\u00e9mulation WINE (Wine Is Not an Emulator), les cartes bancaire VISA (Visa International Service Association), le moteur de recherche Bing (Bing is not Google), etc. Mais aussi des images illustrant la mise en ab\u00eeme: En informatique, on parle de programme r\u00e9cursif ou plut\u00f4t de fonction r\u00e9cursive: D\u00e9finition Une fonction r\u00e9cursive est une fonction qui s'appelle elle-m\u00eame dans sa propre d\u00e9finition. Un programme est r\u00e9cursif lorsqu'il fait intervenir une fonction r\u00e9cursive (ou plusieurs). 2.2.2 Premiers exemples et pr\u00e9cautions d'usage \u2693\ufe0e No infinite recursion ! Voici trois premiers exemples de fonctions r\u00e9cursives. Dans chaque cas, rep\u00e9rer l'appel r\u00e9cursif \u00e0 la fonction. Une seule de ces 3 fonctions est correcte, laquelle? Fonction 1 Fonction 2 Fonction 3 1 2 3 4 def f ( n ): print ( n ) f ( n - 1 ) print ( \"Hello world!\" ) 1 2 3 4 5 6 def f ( n ): if n == 0 : print ( \"Hello world!\" ) else : print ( n ) f ( n - 1 ) 1 2 3 4 5 6 def f ( n ): if n == 0 : print ( \"Hello world!\" ) else : print ( n ) f ( n ) Cas de base Lorsqu'on \u00e9crit une fonction r\u00e9cursive, le pi\u00e8ge classique est de cr\u00e9er une boucle infinie . Hormis les blaques de geeks d'initi\u00e9s, la r\u00e9cursivit\u00e9 en informatique ne tol\u00e8re pas l'auto-r\u00e9f\u00e9rence infinie: il faut pr\u00e9voir une condition d'arr\u00eat qui traite le cas de base !!! Terminaison Pour s'assurer qu'une fonction r\u00e9cursive se termine, il faut absolument que la cha\u00eene d'appel conduise au cas de base. si le param\u00e8tre de la fonction est un entier, alors l'appel doit se faire avec un entier strictement inf\u00e9rieur ; si le param\u00e8tre de la fonction est une liste, alors l'appel doit se faire avec une liste de longueur strictement inf\u00e9rieure ; etc. Exemples \u00e0 conna\u00eetre Somme des n premiers entiers Factorielle On souhaite calculer la somme suivante: \\(S = 0 + 1 + 2 + 3 + \\dots + (n-1) + n\\) En premi\u00e8re, on a vu comment construire une fonction it\u00e9rative le permettant, \u00e0 l'aide d'une boucle for (d'o\u00f9 le terme it\u00e9ratif ) et d'une variable accumulatrice: 1 2 3 4 5 def somme ( n ): s = 0 for k in range ( n + 1 ): s += k return s Une autre fa\u00e7on de voir le probl\u00e8me, c'est de se dire que cette somme peut s'\u00e9crire \\(S = n + (n-1) + \\dots + 3 + 2 + 1 + 0\\) et que c'est la somme de \\(n\\) et de la somme des \\(n-1\\) premiers entiers : \\(S = n + \\underbrace{(n-1) + \\dots + 3 + 2 + 1 + 0}_{\\text{somme des entiers jusqu'\u00e0 } n-1}\\) . On \u00e9crit alors de fa\u00e7on \u00abassez naturelle\u00bb la fonction r\u00e9cursive suivante: 1 2 3 4 5 def somme ( n ): if n == 0 : return 0 else : return n + somme ( n - 1 ) En math\u00e9matiques, la factorielle d'un nombre entier \\(n\\) , not\u00e9e \\(n!\\) , est le produit de tous les entiers positifs non nuls inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Autrement dit, \\(n! = 1 \\times 2 \\times 3 \\times \\dots \\times (n-1) \\times n = n \\times (n-1) \\times \\dots \\times 3 \\times 2 \\times 1\\) . Exercice 1 \u00c9nonc\u00e9 Correction S'inspirer des fonctions somme pr\u00e9c\u00e9dentes pour \u00e9crire deux fonctions facto_iter (it\u00e9rative) et facto_rec (r\u00e9cursive) renvoyant la factorielle d'un nombre entier n strictement positif. 2.2.3 M\u00e9canisme \u2693\ufe0e Maintenant qu'on a vu le principe d'une fonction r\u00e9cursive, il faut comprendre comment se passent les appels successifs \u00e0 la fonction, pour un param\u00e8tre diff\u00e9rent. Reprenons l'exemple de la fonction r\u00e9cursive somme . Si on appelle cette fonction: >>> somme ( 5 ) Puisque l'argument 5 ne correspond pas au cas de base, la fonction va faire appel \u00e0 somme(4) . Il faut retenir que l'ex\u00e9cution de la fonction somme est interrompue (avec l'argument 5 ) pour rappeler la fonction somme (avec l'argument 4 )... Pour g\u00e9rer ces diff\u00e9rents appels, le syst\u00e8me utilise une pile d'ex\u00e9cution : On parle de pile, car les ex\u00e9cutions successives \u00abs'empilent\u00bb les unes sur les autres. Lorsque le cas de base est atteint, on \u00abd\u00e9pile\u00bb les instructions. D'o\u00f9 l'importance de l'existence du cas de base, et de s'assurer qu'il sera bien atteint... Limitation de la taille de la pile Dans l'exemple pr\u00e9c\u00e9dent, la pile a une profondeur de 6. La profondeur de la pile n'est pas illimit\u00e9e: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> somme ( 1000 ) Traceback ( most recent call last ): File \"<console>\" , line 1 , in < module > File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) [ Previous line repeated 984 more times ] File \"<tmp 1>\" , line 2 , in somme if n == 0 : RecursionError : maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent proches de la d\u00e9finition du probl\u00e8me \u00e0 r\u00e9soudre et assez naturels \u00e0 \u00e9crire, mais ils sont susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames et de n\u00e9cessiter un temps d'ex\u00e9cution trop grand ou un d\u00e9bordement de pile. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . 2.2.4 Exercices \u2693\ufe0e Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x, n) qui renvoie le nombre \\(x^n\\) . 1 2 3 4 5 6 7 8 def puissance ( x : float , n : int ): ''' calcule et renvoie la puissance n-i\u00e8me de x ''' if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive nb_chiffres(n) qui renvoie le nombre de chiffres du nombre entier n (penser \u00e0 la division euclidienne par 10). \u00c9crire une fonction r\u00e9cursive nb_bits(n) qui renvoie le nombre de bits dans l'\u00e9criture binaire du nombre entier n (penser \u00e0 la division euclidienne par 2). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def nb_chiffres ( n : int ) -> int : ''' renvoie le nombre de chiffres d'un entier n. ''' if n // 10 == 0 : return 1 else : return 1 + nb_chiffres ( n // 10 ) def nb_bits ( n : int ) -> int : ''' renvoie le nombre de bits dans l'\u00e9criture binaire d'un entier n. ''' if n // 2 == 0 : return 1 else : return 1 + nb_bits ( n // 2 ) ``` Exercice 4 \u00c9nonc\u00e9 Correction Le plus grand diviseur commun de deux nombres entiers \\(a\\) et \\(b\\) , not\u00e9 \\(\\text{pgcd}(a, b)\\) , v\u00e9rifie les propri\u00e9t\u00e9s suivantes: \\(\\text{pgcd}(a, 0) = a\\) \\(\\text{pgcd}(a, b) = \\text{pgcd}(b, c)\\) o\u00f9 \\(c\\) est le reste dans la division euclidienne de \\(a\\) par \\(b\\) . \u00c9crire une fonction r\u00e9cursive qui calcule le pgcd de deux nombres entiers. 1 2 3 4 5 6 7 8 def pgcd ( a : int , b : int ) -> int : ''' renvoie le pgcd de deux entiers a et b. ''' if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 5 \u00c9nonc\u00e9 Indications Correction La multiplication \u00e9gyptienne, dite aussi du paysan russe, \u00e9tait utilis\u00e9e par les scribes d\u00e8s l'Antiquit\u00e9. Elle ne n\u00e9cessite pas de conna\u00eetre les tables de multiplication (sic), seulement la division par deux et l'addition. Principe pour multiplier \\(a\\) par \\(b\\) : on divise \\(a\\) par 2 tant qu'on peut en doublant \\(b\\) ; sinon on d\u00e9cr\u00e9mente \\(a\\) et on ajoute \\(b\\) au r\u00e9sultat. \u00c9crire une fonction r\u00e9cursive qui multiplie deux entiers donn\u00e9s en param\u00e8tre par cette m\u00e9thode. Effectuer \u00e0 la main des multiplications \u00e9gyptiennes. Bien r\u00e9fl\u00e9chir au cas de base. 1 2 3 4 5 6 7 8 9 10 def multi_egpyt ( a : int , b : int ) -> int : ''' renvoie le produit de a par b par la m\u00e9thode \u00e9gyptienne. ''' if a == 0 : return 0 elif a % 2 == 0 : return multi_egypt ( a // 2 , b * 2 ) else : return b + multi_egypt ( a - 1 , b ) Exercice 6 : r\u00e9cursivit\u00e9 double \u00c9nonc\u00e9 Correction En math\u00e9matiques, la suite de Fibonacci est d\u00e9finie ainsi: \\(F_0=1\\) et \\(F_1=1\\) pour tout entier \\(n \\geqslant 2\\) : \\(F_{n+2} = F_{n+1} + F_n\\) . On a donc par exemple \\(F_2 = 1+1=2\\) , \\(F_3=2+1=3\\) , \\(F_4=3+2=5\\) , etc. Impl\u00e9menter une fonction r\u00e9cursive fibo qui calcule les termes de la suite de Fibonacci. Dessiner sous forme d'un arbre les appels de fibo(6) . D\u00e9but de l'arbre: 1 2 3 4 5 6 7 8 def fibo ( n : int ) -> int : ''' renvoie le n-i\u00e8me nombre de la suite de Fibonacci. ''' if n == 0 or n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Exercice 7 : r\u00e9cursivit\u00e9 crois\u00e9e \u00c9nonc\u00e9 Correction L'objectif est d'\u00e9crire deux fonctions est_pair et est_impair qui testent la parit\u00e9 d'un nombre entier. Seules op\u00e9rations autoris\u00e9es : test de nullit\u00e9 et soustraire 1. 1 2 3 4 5 6 7 8 9 10 11 def est_pair ( n ): if n == 0 : return True else : return est_impair ( n - 1 ) def est_impair ( n ): if n == 0 : return False else : return est_pair ( n - 1 ) Exercice 8: les tours de Hano\u00ef \u00c9nonc\u00e9 Correction Le probl\u00e8me des tours de Hano\u00ef, invent\u00e9 par le math\u00e9maticien \u00c9douard Lucas en 1889, consiste \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour de d\u00e9part \u00e0 une tour d'arriv\u00e9e, en passant par une tour interm\u00e9diaire. On ne peut d\u00e9placer qu'un disque \u00e0 la fois, et on ne peut pas placer un disque sur un plus petit que lui. Le but est bien entendu de minimiser le nombre de d\u00e9placements. Essayer de trouver une strat\u00e9gie optimale en s'entra\u00eenant par exemple ici Observer les \u00e9tapes-cl\u00e9s suivantes: \u00c9tape 1 \u00c9tape 2 \u00c9tape 3 \u00c9tape 4 \u00c9crire une fonction r\u00e9cursive hanoi(n, depart, arrivee, inter) affichant les d\u00e9placements successifs (par ex. 1 -> 3 ) pour d\u00e9placer n disques de la tour depart vers la tour arrivee en passant par la tour interm\u00e9diaire inter . 1 2 3 4 5 6 7 def hanoi ( n , depart , arrivee , inter ): if n == 1 : print ( depart , '->' , arrivee ) else : hanoi ( n - 1 , depart , inter , arrivee ) hanoi ( 1 , depart , arrivee , inter ) hanoi ( n - 1 , inter , arrivee , depart ) Exercice 9: rendu de monnaie, le retour \u00c9nonc\u00e9 Indications Correction \u00c9crire une fonction r\u00e9cursive nb_pieces(pieces, somme) o\u00f9 pieces est une liste de valeurs de pieces (tri\u00e9e dans l'ordre d\u00e9croissant) et somme un entier donnant la somme \u00e0 atteindre, et qui renvoie le nombre de pi\u00e8ces minimal. Pour cela, on envisagera la strat\u00e9gie suivante: en notant h le premier \u00e9l\u00e9ment de la liste et t la liste compl\u00e8te priv\u00e9e du premier \u00e9l\u00e9ment, la liste de pi\u00e8ces est [h] + t . on se retrouve face \u00e0 deux options: soit on prend h et il reste \u00e0 faire la somme somme - h avec la liste compl\u00e8te, soit on ne prend pas h et il reste \u00e0 faire la somme somme avec la liste t on choisit le minimum renvoy\u00e9 par ces deux options... Envisager le cas o\u00f9 la somme est n\u00e9gative ou qu'il n'y a pas de pi\u00e8ces \u00e0 prendre. Pour obtenir un nombre arbitrairement grand, on peut utiliser math.inf du module math . Slicing (hors-programme): pour obtenir une liste priv\u00e9e de son premier \u00e9l\u00e9ment, on \u00e9crit liste[1:] . 1 2 3 4 5 6 7 8 9 10 11 import math def nb_pieces ( pieces : list , somme : int ): if somme == 0 : return 0 elif somme < 0 or pieces == []: return math . inf else : option1 = 1 + nb_pieces ( pieces , somme - pieces [ 0 ]) option2 = nb_pieces ( pieces [ 1 :], somme ) return min ( option1 , option2 ) Exercice 10: le sac \u00e0 dos, le retour \u00c9nonc\u00e9 Correction En analysant le probl\u00e8me de fa\u00e7on similaire \u00e0 l'exercice pr\u00e9c\u00e9dent, compl\u00e9ter la fonction r\u00e9cursive suivante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def choix_recursif ( poids : list , valeurs : list , M : int ) -> tuple : ''' Renvoie le poids, la valeur et la s\u00e9lection d'objets sous forme d'un tuple (int, int, list) ''' if poids == []: return ... # Cas o\u00f9 on ne prend pas l'objet 0 poids1 , valeur1 , choix1 = choix_recursif ( ... , ... , ... ) if M >= poids [ 0 ]: # Cas o\u00f9 on prend l'objet 0 poids2 , valeur2 , choix2 = choix_recursif ( ... , ... , ... ) poids2 += ... valeur2 += ... if valeur2 > valeur1 : return ... else : return ... else : return ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def choix_recursif ( poids : list , valeurs : list , M : int ) -> tuple : ''' Renvoie le poids, la valeur et la s\u00e9lection d'objets sous forme d'un tuple (int, int, list) ''' if poids == []: return ( 0 , 0 , []) # Cas o\u00f9 on ne prend pas l'objet 0 poids1 , valeur1 , choix1 = choix_recursif ( poids [ 1 :], valeurs [ 1 :], M ) if M >= poids [ 0 ]: # Cas o\u00f9 on prend l'objet 0 poids2 , valeur2 , choix2 = choix_recursif ( poids [ 1 :], valeurs [ 1 :], M - poids [ 0 ]) poids2 = poids2 + poids [ 0 ] valeur2 = valeur2 + valeurs [ 0 ] if valeur2 > valeur1 : return poids2 , valeur2 , [ 1 ] + choix2 return poids1 , valeur1 , [ 0 ] + choix1 Exercice 11 \u00c9nonc\u00e9 Correction Les coefficients binomiaux se calculent ais\u00e9ment \u00e0 l'aide du triangle de pascal qui permet de les repr\u00e9senter: p=0 p=1 p=2 p=3 p=4 p=5 n=0 1 n=1 1 1 n=2 1 2 1 n=3 1 3 3 1 n=4 1 4 6 4 1 n=5 1 5 10 10 5 1 Le mode de calcul du coefficient \\(C(n, p)\\) est le suivant: \\(C(n,0)=1\\) et \\(C(n,n)=1\\) Dans les autres cas ( \\(0 < p < n\\) ), on a \\(C(n,p)=C(n-1,p-1)+C(n-1,p)\\) . \u00c9crire une fonction r\u00e9cursive C(n, p) qui prend deux entiers en param\u00e8tres et renvoie le coefficient binomial correspondant. 1 2 3 4 5 def C ( n : int , p : int ): if n == 0 or n == p : return 1 else : return C ( n - 1 , p - 1 ) + C ( n - 1 , p ) Pyd\u00e9fis Par ici la monnaie Le cr\u00e9pier (psycho-rigide)","title":"T2.2 R\u00e9cursivit\u00e9"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/#t22-recursivite","text":"Voir ici Dans le m\u00eame \u00e9tat d'esprit, chez Google:","title":"T2.2 R\u00e9cursivit\u00e9"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/#221-principe","text":"En r\u00e8gle g\u00e9n\u00e9rale, un objet est dit r\u00e9cursif s'il se d\u00e9finit \u00e0 partir de lui-m\u00eame. On trouve donc des acronymes r\u00e9cursifs, comme GNU dans GNU/Linux (GNU is Not Unix), le logiciel d'\u00e9mulation WINE (Wine Is Not an Emulator), les cartes bancaire VISA (Visa International Service Association), le moteur de recherche Bing (Bing is not Google), etc. Mais aussi des images illustrant la mise en ab\u00eeme: En informatique, on parle de programme r\u00e9cursif ou plut\u00f4t de fonction r\u00e9cursive: D\u00e9finition Une fonction r\u00e9cursive est une fonction qui s'appelle elle-m\u00eame dans sa propre d\u00e9finition. Un programme est r\u00e9cursif lorsqu'il fait intervenir une fonction r\u00e9cursive (ou plusieurs).","title":"2.2.1 Principe"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/#222-premiers-exemples-et-precautions-dusage","text":"No infinite recursion ! Voici trois premiers exemples de fonctions r\u00e9cursives. Dans chaque cas, rep\u00e9rer l'appel r\u00e9cursif \u00e0 la fonction. Une seule de ces 3 fonctions est correcte, laquelle? Fonction 1 Fonction 2 Fonction 3 1 2 3 4 def f ( n ): print ( n ) f ( n - 1 ) print ( \"Hello world!\" ) 1 2 3 4 5 6 def f ( n ): if n == 0 : print ( \"Hello world!\" ) else : print ( n ) f ( n - 1 ) 1 2 3 4 5 6 def f ( n ): if n == 0 : print ( \"Hello world!\" ) else : print ( n ) f ( n ) Cas de base Lorsqu'on \u00e9crit une fonction r\u00e9cursive, le pi\u00e8ge classique est de cr\u00e9er une boucle infinie . Hormis les blaques de geeks d'initi\u00e9s, la r\u00e9cursivit\u00e9 en informatique ne tol\u00e8re pas l'auto-r\u00e9f\u00e9rence infinie: il faut pr\u00e9voir une condition d'arr\u00eat qui traite le cas de base !!! Terminaison Pour s'assurer qu'une fonction r\u00e9cursive se termine, il faut absolument que la cha\u00eene d'appel conduise au cas de base. si le param\u00e8tre de la fonction est un entier, alors l'appel doit se faire avec un entier strictement inf\u00e9rieur ; si le param\u00e8tre de la fonction est une liste, alors l'appel doit se faire avec une liste de longueur strictement inf\u00e9rieure ; etc. Exemples \u00e0 conna\u00eetre Somme des n premiers entiers Factorielle On souhaite calculer la somme suivante: \\(S = 0 + 1 + 2 + 3 + \\dots + (n-1) + n\\) En premi\u00e8re, on a vu comment construire une fonction it\u00e9rative le permettant, \u00e0 l'aide d'une boucle for (d'o\u00f9 le terme it\u00e9ratif ) et d'une variable accumulatrice: 1 2 3 4 5 def somme ( n ): s = 0 for k in range ( n + 1 ): s += k return s Une autre fa\u00e7on de voir le probl\u00e8me, c'est de se dire que cette somme peut s'\u00e9crire \\(S = n + (n-1) + \\dots + 3 + 2 + 1 + 0\\) et que c'est la somme de \\(n\\) et de la somme des \\(n-1\\) premiers entiers : \\(S = n + \\underbrace{(n-1) + \\dots + 3 + 2 + 1 + 0}_{\\text{somme des entiers jusqu'\u00e0 } n-1}\\) . On \u00e9crit alors de fa\u00e7on \u00abassez naturelle\u00bb la fonction r\u00e9cursive suivante: 1 2 3 4 5 def somme ( n ): if n == 0 : return 0 else : return n + somme ( n - 1 ) En math\u00e9matiques, la factorielle d'un nombre entier \\(n\\) , not\u00e9e \\(n!\\) , est le produit de tous les entiers positifs non nuls inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Autrement dit, \\(n! = 1 \\times 2 \\times 3 \\times \\dots \\times (n-1) \\times n = n \\times (n-1) \\times \\dots \\times 3 \\times 2 \\times 1\\) . Exercice 1 \u00c9nonc\u00e9 Correction S'inspirer des fonctions somme pr\u00e9c\u00e9dentes pour \u00e9crire deux fonctions facto_iter (it\u00e9rative) et facto_rec (r\u00e9cursive) renvoyant la factorielle d'un nombre entier n strictement positif.","title":"2.2.2 Premiers exemples et pr\u00e9cautions d'usage"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/#223-mecanisme","text":"Maintenant qu'on a vu le principe d'une fonction r\u00e9cursive, il faut comprendre comment se passent les appels successifs \u00e0 la fonction, pour un param\u00e8tre diff\u00e9rent. Reprenons l'exemple de la fonction r\u00e9cursive somme . Si on appelle cette fonction: >>> somme ( 5 ) Puisque l'argument 5 ne correspond pas au cas de base, la fonction va faire appel \u00e0 somme(4) . Il faut retenir que l'ex\u00e9cution de la fonction somme est interrompue (avec l'argument 5 ) pour rappeler la fonction somme (avec l'argument 4 )... Pour g\u00e9rer ces diff\u00e9rents appels, le syst\u00e8me utilise une pile d'ex\u00e9cution : On parle de pile, car les ex\u00e9cutions successives \u00abs'empilent\u00bb les unes sur les autres. Lorsque le cas de base est atteint, on \u00abd\u00e9pile\u00bb les instructions. D'o\u00f9 l'importance de l'existence du cas de base, et de s'assurer qu'il sera bien atteint... Limitation de la taille de la pile Dans l'exemple pr\u00e9c\u00e9dent, la pile a une profondeur de 6. La profondeur de la pile n'est pas illimit\u00e9e: 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> somme ( 1000 ) Traceback ( most recent call last ): File \"<console>\" , line 1 , in < module > File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) File \"<tmp 1>\" , line 5 , in somme return n + somme ( n - 1 ) [ Previous line repeated 984 more times ] File \"<tmp 1>\" , line 2 , in somme if n == 0 : RecursionError : maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent proches de la d\u00e9finition du probl\u00e8me \u00e0 r\u00e9soudre et assez naturels \u00e0 \u00e9crire, mais ils sont susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames et de n\u00e9cessiter un temps d'ex\u00e9cution trop grand ou un d\u00e9bordement de pile. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique .","title":"2.2.3 M\u00e9canisme"},{"location":"T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/#224-exercices","text":"Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x, n) qui renvoie le nombre \\(x^n\\) . 1 2 3 4 5 6 7 8 def puissance ( x : float , n : int ): ''' calcule et renvoie la puissance n-i\u00e8me de x ''' if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive nb_chiffres(n) qui renvoie le nombre de chiffres du nombre entier n (penser \u00e0 la division euclidienne par 10). \u00c9crire une fonction r\u00e9cursive nb_bits(n) qui renvoie le nombre de bits dans l'\u00e9criture binaire du nombre entier n (penser \u00e0 la division euclidienne par 2). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def nb_chiffres ( n : int ) -> int : ''' renvoie le nombre de chiffres d'un entier n. ''' if n // 10 == 0 : return 1 else : return 1 + nb_chiffres ( n // 10 ) def nb_bits ( n : int ) -> int : ''' renvoie le nombre de bits dans l'\u00e9criture binaire d'un entier n. ''' if n // 2 == 0 : return 1 else : return 1 + nb_bits ( n // 2 ) ``` Exercice 4 \u00c9nonc\u00e9 Correction Le plus grand diviseur commun de deux nombres entiers \\(a\\) et \\(b\\) , not\u00e9 \\(\\text{pgcd}(a, b)\\) , v\u00e9rifie les propri\u00e9t\u00e9s suivantes: \\(\\text{pgcd}(a, 0) = a\\) \\(\\text{pgcd}(a, b) = \\text{pgcd}(b, c)\\) o\u00f9 \\(c\\) est le reste dans la division euclidienne de \\(a\\) par \\(b\\) . \u00c9crire une fonction r\u00e9cursive qui calcule le pgcd de deux nombres entiers. 1 2 3 4 5 6 7 8 def pgcd ( a : int , b : int ) -> int : ''' renvoie le pgcd de deux entiers a et b. ''' if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 5 \u00c9nonc\u00e9 Indications Correction La multiplication \u00e9gyptienne, dite aussi du paysan russe, \u00e9tait utilis\u00e9e par les scribes d\u00e8s l'Antiquit\u00e9. Elle ne n\u00e9cessite pas de conna\u00eetre les tables de multiplication (sic), seulement la division par deux et l'addition. Principe pour multiplier \\(a\\) par \\(b\\) : on divise \\(a\\) par 2 tant qu'on peut en doublant \\(b\\) ; sinon on d\u00e9cr\u00e9mente \\(a\\) et on ajoute \\(b\\) au r\u00e9sultat. \u00c9crire une fonction r\u00e9cursive qui multiplie deux entiers donn\u00e9s en param\u00e8tre par cette m\u00e9thode. Effectuer \u00e0 la main des multiplications \u00e9gyptiennes. Bien r\u00e9fl\u00e9chir au cas de base. 1 2 3 4 5 6 7 8 9 10 def multi_egpyt ( a : int , b : int ) -> int : ''' renvoie le produit de a par b par la m\u00e9thode \u00e9gyptienne. ''' if a == 0 : return 0 elif a % 2 == 0 : return multi_egypt ( a // 2 , b * 2 ) else : return b + multi_egypt ( a - 1 , b ) Exercice 6 : r\u00e9cursivit\u00e9 double \u00c9nonc\u00e9 Correction En math\u00e9matiques, la suite de Fibonacci est d\u00e9finie ainsi: \\(F_0=1\\) et \\(F_1=1\\) pour tout entier \\(n \\geqslant 2\\) : \\(F_{n+2} = F_{n+1} + F_n\\) . On a donc par exemple \\(F_2 = 1+1=2\\) , \\(F_3=2+1=3\\) , \\(F_4=3+2=5\\) , etc. Impl\u00e9menter une fonction r\u00e9cursive fibo qui calcule les termes de la suite de Fibonacci. Dessiner sous forme d'un arbre les appels de fibo(6) . D\u00e9but de l'arbre: 1 2 3 4 5 6 7 8 def fibo ( n : int ) -> int : ''' renvoie le n-i\u00e8me nombre de la suite de Fibonacci. ''' if n == 0 or n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Exercice 7 : r\u00e9cursivit\u00e9 crois\u00e9e \u00c9nonc\u00e9 Correction L'objectif est d'\u00e9crire deux fonctions est_pair et est_impair qui testent la parit\u00e9 d'un nombre entier. Seules op\u00e9rations autoris\u00e9es : test de nullit\u00e9 et soustraire 1. 1 2 3 4 5 6 7 8 9 10 11 def est_pair ( n ): if n == 0 : return True else : return est_impair ( n - 1 ) def est_impair ( n ): if n == 0 : return False else : return est_pair ( n - 1 ) Exercice 8: les tours de Hano\u00ef \u00c9nonc\u00e9 Correction Le probl\u00e8me des tours de Hano\u00ef, invent\u00e9 par le math\u00e9maticien \u00c9douard Lucas en 1889, consiste \u00e0 d\u00e9placer des disques de diam\u00e8tres diff\u00e9rents d'une tour de d\u00e9part \u00e0 une tour d'arriv\u00e9e, en passant par une tour interm\u00e9diaire. On ne peut d\u00e9placer qu'un disque \u00e0 la fois, et on ne peut pas placer un disque sur un plus petit que lui. Le but est bien entendu de minimiser le nombre de d\u00e9placements. Essayer de trouver une strat\u00e9gie optimale en s'entra\u00eenant par exemple ici Observer les \u00e9tapes-cl\u00e9s suivantes: \u00c9tape 1 \u00c9tape 2 \u00c9tape 3 \u00c9tape 4 \u00c9crire une fonction r\u00e9cursive hanoi(n, depart, arrivee, inter) affichant les d\u00e9placements successifs (par ex. 1 -> 3 ) pour d\u00e9placer n disques de la tour depart vers la tour arrivee en passant par la tour interm\u00e9diaire inter . 1 2 3 4 5 6 7 def hanoi ( n , depart , arrivee , inter ): if n == 1 : print ( depart , '->' , arrivee ) else : hanoi ( n - 1 , depart , inter , arrivee ) hanoi ( 1 , depart , arrivee , inter ) hanoi ( n - 1 , inter , arrivee , depart ) Exercice 9: rendu de monnaie, le retour \u00c9nonc\u00e9 Indications Correction \u00c9crire une fonction r\u00e9cursive nb_pieces(pieces, somme) o\u00f9 pieces est une liste de valeurs de pieces (tri\u00e9e dans l'ordre d\u00e9croissant) et somme un entier donnant la somme \u00e0 atteindre, et qui renvoie le nombre de pi\u00e8ces minimal. Pour cela, on envisagera la strat\u00e9gie suivante: en notant h le premier \u00e9l\u00e9ment de la liste et t la liste compl\u00e8te priv\u00e9e du premier \u00e9l\u00e9ment, la liste de pi\u00e8ces est [h] + t . on se retrouve face \u00e0 deux options: soit on prend h et il reste \u00e0 faire la somme somme - h avec la liste compl\u00e8te, soit on ne prend pas h et il reste \u00e0 faire la somme somme avec la liste t on choisit le minimum renvoy\u00e9 par ces deux options... Envisager le cas o\u00f9 la somme est n\u00e9gative ou qu'il n'y a pas de pi\u00e8ces \u00e0 prendre. Pour obtenir un nombre arbitrairement grand, on peut utiliser math.inf du module math . Slicing (hors-programme): pour obtenir une liste priv\u00e9e de son premier \u00e9l\u00e9ment, on \u00e9crit liste[1:] . 1 2 3 4 5 6 7 8 9 10 11 import math def nb_pieces ( pieces : list , somme : int ): if somme == 0 : return 0 elif somme < 0 or pieces == []: return math . inf else : option1 = 1 + nb_pieces ( pieces , somme - pieces [ 0 ]) option2 = nb_pieces ( pieces [ 1 :], somme ) return min ( option1 , option2 ) Exercice 10: le sac \u00e0 dos, le retour \u00c9nonc\u00e9 Correction En analysant le probl\u00e8me de fa\u00e7on similaire \u00e0 l'exercice pr\u00e9c\u00e9dent, compl\u00e9ter la fonction r\u00e9cursive suivante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def choix_recursif ( poids : list , valeurs : list , M : int ) -> tuple : ''' Renvoie le poids, la valeur et la s\u00e9lection d'objets sous forme d'un tuple (int, int, list) ''' if poids == []: return ... # Cas o\u00f9 on ne prend pas l'objet 0 poids1 , valeur1 , choix1 = choix_recursif ( ... , ... , ... ) if M >= poids [ 0 ]: # Cas o\u00f9 on prend l'objet 0 poids2 , valeur2 , choix2 = choix_recursif ( ... , ... , ... ) poids2 += ... valeur2 += ... if valeur2 > valeur1 : return ... else : return ... else : return ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def choix_recursif ( poids : list , valeurs : list , M : int ) -> tuple : ''' Renvoie le poids, la valeur et la s\u00e9lection d'objets sous forme d'un tuple (int, int, list) ''' if poids == []: return ( 0 , 0 , []) # Cas o\u00f9 on ne prend pas l'objet 0 poids1 , valeur1 , choix1 = choix_recursif ( poids [ 1 :], valeurs [ 1 :], M ) if M >= poids [ 0 ]: # Cas o\u00f9 on prend l'objet 0 poids2 , valeur2 , choix2 = choix_recursif ( poids [ 1 :], valeurs [ 1 :], M - poids [ 0 ]) poids2 = poids2 + poids [ 0 ] valeur2 = valeur2 + valeurs [ 0 ] if valeur2 > valeur1 : return poids2 , valeur2 , [ 1 ] + choix2 return poids1 , valeur1 , [ 0 ] + choix1 Exercice 11 \u00c9nonc\u00e9 Correction Les coefficients binomiaux se calculent ais\u00e9ment \u00e0 l'aide du triangle de pascal qui permet de les repr\u00e9senter: p=0 p=1 p=2 p=3 p=4 p=5 n=0 1 n=1 1 1 n=2 1 2 1 n=3 1 3 3 1 n=4 1 4 6 4 1 n=5 1 5 10 10 5 1 Le mode de calcul du coefficient \\(C(n, p)\\) est le suivant: \\(C(n,0)=1\\) et \\(C(n,n)=1\\) Dans les autres cas ( \\(0 < p < n\\) ), on a \\(C(n,p)=C(n-1,p-1)+C(n-1,p)\\) . \u00c9crire une fonction r\u00e9cursive C(n, p) qui prend deux entiers en param\u00e8tres et renvoie le coefficient binomial correspondant. 1 2 3 4 5 def C ( n : int , p : int ): if n == 0 or n == p : return 1 else : return C ( n - 1 , p - 1 ) + C ( n - 1 , p ) Pyd\u00e9fis Par ici la monnaie Le cr\u00e9pier (psycho-rigide)","title":"2.2.4 Exercices"},{"location":"T03_Algorithmique/accueil/","text":"Th\u00e8me 3 : Algorithmique \u2693\ufe0e","title":"Th\u00e8me 3 : Algorithmique"},{"location":"T03_Algorithmique/accueil/#theme-3-algorithmique","text":"","title":"Th\u00e8me 3 : Algorithmique"},{"location":"T03_Algorithmique/T3.1_Diviser/T3.1_Diviser/","text":"T3.1 Diviser pour r\u00e9gner \u2693\ufe0e","title":"T3.1 Diviser pour r\u00e9gner"},{"location":"T03_Algorithmique/T3.1_Diviser/T3.1_Diviser/#t31-diviser-pour-regner","text":"","title":"T3.1 Diviser pour r\u00e9gner"},{"location":"T03_Algorithmique/T3.2_ProgDyn/T3.2_ProgDyn/","text":"T3.2 Programmation dynamique \u2693\ufe0e","title":"T3.2 Programmation dynamique"},{"location":"T03_Algorithmique/T3.2_ProgDyn/T3.2_ProgDyn/#t32-programmation-dynamique","text":"","title":"T3.2 Programmation dynamique"},{"location":"T03_Algorithmique/T3.3_Texte/T3.3_RechercheTexte/","text":"T3.3 Recherche textuelle \u2693\ufe0e","title":"T3.3 Recherche textuelle"},{"location":"T03_Algorithmique/T3.3_Texte/T3.3_RechercheTexte/#t33-recherche-textuelle","text":"","title":"T3.3 Recherche textuelle"},{"location":"T04_BasesDonnees/accueil/","text":"Th\u00e8me 4 : Bases de donn\u00e9es \u2693\ufe0e Le d\u00e9veloppement des traitements informatiques n\u00e9cessite la manipulation de donn\u00e9es de plus en plus nombreuses. Leur organisation et leur stockage constituent un enjeu essentiel de performance. Le recours aux bases de donn\u00e9es relationnelles est aujourd\u2019hui une solution tr\u00e8s r\u00e9pandue. Ces bases de donn\u00e9es permettent d\u2019organiser, de stocker, de mettre \u00e0 jour et d\u2019interroger des donn\u00e9es structur\u00e9es volumineuses utilis\u00e9es simultan\u00e9ment par diff\u00e9rents programmes ou diff\u00e9rents utilisateurs. Cela est impossible avec les repr\u00e9sentations tabulaires \u00e9tudi\u00e9es en classe de premi\u00e8re. Des syst\u00e8mes de gestion de bases de donn\u00e9es (SGBD) de tr\u00e8s grande taille (de l\u2019ordre du p\u00e9taoctet) sont au centre de nombreux dispositifs de collecte, de stockage et de production d\u2019informations. L\u2019acc\u00e8s aux donn\u00e9es d\u2019une base de donn\u00e9es relationnelle s\u2019effectue gr\u00e2ce \u00e0 des requ\u00eates d\u2019interrogation et de mise \u00e0 jour qui peuvent par exemple \u00eatre r\u00e9dig\u00e9es dans le langage SQL (Structured Query Language). Les traitements peuvent conjuguer le recours au langage SQL et \u00e0 un langage de programmation.","title":"Th\u00e8me 4 : Bases de donn\u00e9es"},{"location":"T04_BasesDonnees/accueil/#theme-4-bases-de-donnees","text":"Le d\u00e9veloppement des traitements informatiques n\u00e9cessite la manipulation de donn\u00e9es de plus en plus nombreuses. Leur organisation et leur stockage constituent un enjeu essentiel de performance. Le recours aux bases de donn\u00e9es relationnelles est aujourd\u2019hui une solution tr\u00e8s r\u00e9pandue. Ces bases de donn\u00e9es permettent d\u2019organiser, de stocker, de mettre \u00e0 jour et d\u2019interroger des donn\u00e9es structur\u00e9es volumineuses utilis\u00e9es simultan\u00e9ment par diff\u00e9rents programmes ou diff\u00e9rents utilisateurs. Cela est impossible avec les repr\u00e9sentations tabulaires \u00e9tudi\u00e9es en classe de premi\u00e8re. Des syst\u00e8mes de gestion de bases de donn\u00e9es (SGBD) de tr\u00e8s grande taille (de l\u2019ordre du p\u00e9taoctet) sont au centre de nombreux dispositifs de collecte, de stockage et de production d\u2019informations. L\u2019acc\u00e8s aux donn\u00e9es d\u2019une base de donn\u00e9es relationnelle s\u2019effectue gr\u00e2ce \u00e0 des requ\u00eates d\u2019interrogation et de mise \u00e0 jour qui peuvent par exemple \u00eatre r\u00e9dig\u00e9es dans le langage SQL (Structured Query Language). Les traitements peuvent conjuguer le recours au langage SQL et \u00e0 un langage de programmation.","title":"Th\u00e8me 4 : Bases de donn\u00e9es"},{"location":"T04_BasesDonnees/prequel/","text":"Prequel \u2693\ufe0e Imaginons qu'on doive cr\u00e9er un jeu sur le th\u00e8me de l'univers d'\u00abHarry Potter\u00bb. Il va falloir stocker et g\u00e9rer plusieurs informations sur chacun des personnages, comme le statut (\u00e9l\u00e8ve, professeur, cr\u00e9ature...), la moyenne (pour les \u00e9l\u00e8ves),la baguette, la maison (Gryffondor, Serdaigle, Poufsouffle, Serpentard), leur relations d'amiti\u00e9, etc. Sachant qu'\u00e9galement chaque maison poss\u00e8de un professeur r\u00e9f\u00e9rent , un dortoir (qui peut \u00eatre dans une tour ou au sous-sol)... Par exemple: Harry Potter est un \u00e9l\u00e8ve, a 17 de moyenne, poss\u00e8de une baguette en Houx et plume de Ph\u00e9nix, est ami avec Ron Weasley et Hermione Granger, appartient \u00e0 la maison Gryffondor qui a pour r\u00e9f\u00e9rent le professeur MacGonagall et dont le dortoir est dans une tour; Drago Malefoy est un \u00e9l\u00e8ve, a 13 de moyenne, poss\u00e8de une baguette en Aub\u00e9pine et crin de licorne, est ami avec Vincent Crabbe et Gregory Goyle, appartient \u00e0 la maison Serpentard qui a pour r\u00e9f\u00e9rent le professeur Rogue et dont le dortoir est dans un sous-sol; Albus Dumbledore est un professeur, poss\u00e8de la baguette de Sureau, est affili\u00e9 \u00e0 la maison Gryffondor... Probl\u00e9matique Comment stocker et repr\u00e9senter l'ensemble des personnages ainsi que les informations qui leurs sont associ\u00e9es? Comment r\u00e9cup\u00e9rer les membres d'une maison? les personnages dont la baguette est en Bois de vigne? amis avec Neville Londubat?","title":"Prequel"},{"location":"T04_BasesDonnees/prequel/#prequel","text":"Imaginons qu'on doive cr\u00e9er un jeu sur le th\u00e8me de l'univers d'\u00abHarry Potter\u00bb. Il va falloir stocker et g\u00e9rer plusieurs informations sur chacun des personnages, comme le statut (\u00e9l\u00e8ve, professeur, cr\u00e9ature...), la moyenne (pour les \u00e9l\u00e8ves),la baguette, la maison (Gryffondor, Serdaigle, Poufsouffle, Serpentard), leur relations d'amiti\u00e9, etc. Sachant qu'\u00e9galement chaque maison poss\u00e8de un professeur r\u00e9f\u00e9rent , un dortoir (qui peut \u00eatre dans une tour ou au sous-sol)... Par exemple: Harry Potter est un \u00e9l\u00e8ve, a 17 de moyenne, poss\u00e8de une baguette en Houx et plume de Ph\u00e9nix, est ami avec Ron Weasley et Hermione Granger, appartient \u00e0 la maison Gryffondor qui a pour r\u00e9f\u00e9rent le professeur MacGonagall et dont le dortoir est dans une tour; Drago Malefoy est un \u00e9l\u00e8ve, a 13 de moyenne, poss\u00e8de une baguette en Aub\u00e9pine et crin de licorne, est ami avec Vincent Crabbe et Gregory Goyle, appartient \u00e0 la maison Serpentard qui a pour r\u00e9f\u00e9rent le professeur Rogue et dont le dortoir est dans un sous-sol; Albus Dumbledore est un professeur, poss\u00e8de la baguette de Sureau, est affili\u00e9 \u00e0 la maison Gryffondor... Probl\u00e9matique Comment stocker et repr\u00e9senter l'ensemble des personnages ainsi que les informations qui leurs sont associ\u00e9es? Comment r\u00e9cup\u00e9rer les membres d'une maison? les personnages dont la baguette est en Bois de vigne? amis avec Neville Londubat?","title":"Prequel"},{"location":"T04_BasesDonnees/Exercices/Exercices/","text":"Exercices interactifs \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net. Travail sur SELECT, (base de donn\u00e9es Nobel) : ici . Travail sur SUM et COUNT, (base de donn\u00e9es World) : ici . (jusqu'\u00e0 la question 5.) Travail sur JOIN, (base de donn\u00e9es Euro2012) : ici . Exercice 2 Gestion d'un r\u00e9seau d'agences de location de voitures. D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . R\u00e9pondez aux 9 questions sur la relation Agence. (Travail sur SELECT) R\u00e9pondez aux 11 questions sur la relation V\u00e9hicules. (Travail sur SELECT plus des fonctions d'agr\u00e9gation) R\u00e9pondez aux 12 questions sur la relation Locations. (Travail sur des jointures) R\u00e9pondez aux 17 questions sur la relation V\u00e9hicules. (Travail sur UPDATE, INSERT, DELETE) Exercice 3 : The SQL Murder Mystery \u00c9nonc\u00e9 Correction Cet exercice en ligne est propos\u00e9 par le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Rendez-vous sur cette page , et bonne enqu\u00eate \u00e0 coups de requ\u00eates ! Vous pouvez travailler en ligne ou bien dans votre SGBD pr\u00e9f\u00e9r\u00e9, avec la base sql-murder-mystery.db . Attention pour valider votre r\u00e9ponse, il faudra vous rendre en bas de la page officielle.","title":"Exercices interactifs"},{"location":"T04_BasesDonnees/Exercices/Exercices/#exercices-interactifs","text":"Exercice 1 \u00c9nonc\u00e9 Correction Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net. Travail sur SELECT, (base de donn\u00e9es Nobel) : ici . Travail sur SUM et COUNT, (base de donn\u00e9es World) : ici . (jusqu'\u00e0 la question 5.) Travail sur JOIN, (base de donn\u00e9es Euro2012) : ici . Exercice 2 Gestion d'un r\u00e9seau d'agences de location de voitures. D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . R\u00e9pondez aux 9 questions sur la relation Agence. (Travail sur SELECT) R\u00e9pondez aux 11 questions sur la relation V\u00e9hicules. (Travail sur SELECT plus des fonctions d'agr\u00e9gation) R\u00e9pondez aux 12 questions sur la relation Locations. (Travail sur des jointures) R\u00e9pondez aux 17 questions sur la relation V\u00e9hicules. (Travail sur UPDATE, INSERT, DELETE) Exercice 3 : The SQL Murder Mystery \u00c9nonc\u00e9 Correction Cet exercice en ligne est propos\u00e9 par le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Rendez-vous sur cette page , et bonne enqu\u00eate \u00e0 coups de requ\u00eates ! Vous pouvez travailler en ligne ou bien dans votre SGBD pr\u00e9f\u00e9r\u00e9, avec la base sql-murder-mystery.db . Attention pour valider votre r\u00e9ponse, il faudra vous rendre en bas de la page officielle.","title":"Exercices interactifs"},{"location":"T04_BasesDonnees/Exercices/Exo1_22MEJ2/","text":"Exercice BAC 1 : Base de donn\u00e9es musicale \u2693\ufe0e D'apr\u00e8s 2022, M\u00e9tropole, J2, Ex. 4 On pourra utiliser les mots cl\u00e9s SQL suivants : SELECT , FROM , WHERE , JOIN , ON , INSERT , INTO , VALUES , UPDATE , SET , AND . La clause ORDER BY suivie d'un attribut permet de trier les r\u00e9sultats par ordre croissant de l'attribut. L'instruction COUNT ( * ) renvoie le nombre de lignes d'une requ\u00eate. Un musicien souhaite cr\u00e9er une base de donn\u00e9es relationnelle contenant ses morceaux et interpr\u00e8tes pr\u00e9f\u00e9r\u00e9s. Pour cela il utilise le langage SQL. Il cr\u00e9e une table morceaux qui contient entre autres attributs les titres des morceaux et leur ann\u00e9e de sortie : id_morceau titre annee id_interprete 1 Like a Rolling Stone 1965 1 2 Respect 1967 2 3 Imagine 1970 3 4 Hey Jude 1968 4 5 Smells Like Teen Spirit 1991 5 6 I Want To hold Your Hand 1963 4 Il cr\u00e9e la table interpretes qui contient les interpr\u00e8tes et leur pays d'origine : id_interprete nom pays 1 Bob Dylan \u00c9tats-Unis 2 Aretha Franklin \u00c9tats-Unis 3 John Lennon Angleterre 4 The Beatles Angleterre 5 Nirvana \u00c9tats-Unis id_morceau de la table morceaux et id_interprete de la table interpretes sont des cl\u00e9s primaires. L'attribut id_interprete de la table morceaux fait directement r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire de la table interpretes . 1.a. \u00c9crire le r\u00e9sultat de la requ\u00eate suivante : SELECT titre FROM morceaux WHERE id_interprete = 4 ; 1.b. \u00c9crire une requ\u00eate permettant d'afficher les noms des interpr\u00e8tes originaires d'Angleterre. 1.c. \u00c9crire le r\u00e9sultat de la requ\u00eate suivante : SELECT titre , annee FROM morceaux ORDER BY annee ; 1.d. \u00c9crire une requ\u00eate permettant de calculer le nombre de morceaux dans la table morceaux . 1.e. \u00c9crire une requ\u00eate affichant les titres des morceaux par ordre alphab\u00e9tique. 2.a. Citer, en justifiant, la cl\u00e9 \u00e9trang\u00e8re de la table morceaux . 2.b. \u00c9crire un sch\u00e9ma relationnel des tables interpretes et morceaux . 2.c. Expliquer pourquoi la requ\u00eate suivante produit une erreur : INSERT INTO interpretes VALUES ( 1 , 'Trust' , 'France' ); 3.a. Une erreur de saisie a \u00e9t\u00e9 faite. \u00c9crire une requ\u00eate SQL permettant de changer l'ann\u00e9e du titre \u00ab Imagine \u00bb en 1971. 3.b. \u00c9crire une requ\u00eate SQL permettant d'ajouter l'interpr\u00e8te \u00ab The Who \u00bb venant d'Angleterre \u00e0 la table interpretes . On lui donnera un id_interprete \u00e9gal \u00e0 6. 3.c. \u00c9crire une requ\u00eate SQL permettant d'ajouter le titre \u00ab My Generation \u00bb de \u00ab The Who \u00bb \u00e0 la table morceaux . Ce titre est sorti en 1965 et on lui donnera un id_morceau de 7 ainsi que l' id_interprete qui conviendra. 4. \u00c9crire une requ\u00eate permettant de lister les titres des interpr\u00e8tes venant des \u00c9tats-Unis. Proposition de correction 1.a. On obtient les titres 'Hey Jude' et 'I Want To hold Your Hand' . 1.b. SELECT nom FROM interpretes WHERE pays = 'Angleterre' ; 1.c. On obtient : titre annee I Want To hold Your Hand 1963 Like a Rolling Stone 1965 Respect 1967 Hey Jude 1968 Imagine 1970 Smells Like Teen Spirit 1991 1.d. SELECT COUNT ( * ) FROM morceaux ; 1.e. SELECT titre FROM morceaux ORDER BY titre ASC ; 2.a. La cl\u00e9 \u00e9trang\u00e8re est id_interprete qui fait r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire de la table interpretes . 2.b. Sch\u00e9ma des deux relations: interpretes ( id_interprete : INT , nom : TEXT, pays : TEXT) morceaux ( id_morceau : INT , titre : TEXT, annee : INT, #id_interprete : INT) 2.c. Cette requ\u00eate provoque une erreur, car elle essaye d\u2019ajouter \u00e0 la table interpretes une entr\u00e9e ayant pour id_interprete 1. Or, l\u2019attribut id_interprete (qui est une cl\u00e9 primaire) a d\u00e9j\u00e0 une entr\u00e9e avec la valeur 1 (la cl\u00e9 primaire doit \u00eatre unique). 3.a. UPDATE morceaux SET annee = 1971 WHERE titre = 'Imagine' ; 3.b. INSERT INTO interpretes VALUES ( 6 , 'The Who' , 'Angleterre' ); 3.c. INSERT INTO morceaux VALUES ( 7 , 'My Generation' , 1965 , 6 ); 4. SELECT morceaux . titre FROM morceaux JOIN interpretes ON morceaux . id_interprete = interpretes . id_interprete WHERE interpretes . pays = '\u00c9tats-Unis' ;","title":"Exercice BAC 1 : Base de donn\u00e9es musicale"},{"location":"T04_BasesDonnees/Exercices/Exo1_22MEJ2/#exercice-bac-1-base-de-donnees-musicale","text":"D'apr\u00e8s 2022, M\u00e9tropole, J2, Ex. 4 On pourra utiliser les mots cl\u00e9s SQL suivants : SELECT , FROM , WHERE , JOIN , ON , INSERT , INTO , VALUES , UPDATE , SET , AND . La clause ORDER BY suivie d'un attribut permet de trier les r\u00e9sultats par ordre croissant de l'attribut. L'instruction COUNT ( * ) renvoie le nombre de lignes d'une requ\u00eate. Un musicien souhaite cr\u00e9er une base de donn\u00e9es relationnelle contenant ses morceaux et interpr\u00e8tes pr\u00e9f\u00e9r\u00e9s. Pour cela il utilise le langage SQL. Il cr\u00e9e une table morceaux qui contient entre autres attributs les titres des morceaux et leur ann\u00e9e de sortie : id_morceau titre annee id_interprete 1 Like a Rolling Stone 1965 1 2 Respect 1967 2 3 Imagine 1970 3 4 Hey Jude 1968 4 5 Smells Like Teen Spirit 1991 5 6 I Want To hold Your Hand 1963 4 Il cr\u00e9e la table interpretes qui contient les interpr\u00e8tes et leur pays d'origine : id_interprete nom pays 1 Bob Dylan \u00c9tats-Unis 2 Aretha Franklin \u00c9tats-Unis 3 John Lennon Angleterre 4 The Beatles Angleterre 5 Nirvana \u00c9tats-Unis id_morceau de la table morceaux et id_interprete de la table interpretes sont des cl\u00e9s primaires. L'attribut id_interprete de la table morceaux fait directement r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire de la table interpretes . 1.a. \u00c9crire le r\u00e9sultat de la requ\u00eate suivante : SELECT titre FROM morceaux WHERE id_interprete = 4 ; 1.b. \u00c9crire une requ\u00eate permettant d'afficher les noms des interpr\u00e8tes originaires d'Angleterre. 1.c. \u00c9crire le r\u00e9sultat de la requ\u00eate suivante : SELECT titre , annee FROM morceaux ORDER BY annee ; 1.d. \u00c9crire une requ\u00eate permettant de calculer le nombre de morceaux dans la table morceaux . 1.e. \u00c9crire une requ\u00eate affichant les titres des morceaux par ordre alphab\u00e9tique. 2.a. Citer, en justifiant, la cl\u00e9 \u00e9trang\u00e8re de la table morceaux . 2.b. \u00c9crire un sch\u00e9ma relationnel des tables interpretes et morceaux . 2.c. Expliquer pourquoi la requ\u00eate suivante produit une erreur : INSERT INTO interpretes VALUES ( 1 , 'Trust' , 'France' ); 3.a. Une erreur de saisie a \u00e9t\u00e9 faite. \u00c9crire une requ\u00eate SQL permettant de changer l'ann\u00e9e du titre \u00ab Imagine \u00bb en 1971. 3.b. \u00c9crire une requ\u00eate SQL permettant d'ajouter l'interpr\u00e8te \u00ab The Who \u00bb venant d'Angleterre \u00e0 la table interpretes . On lui donnera un id_interprete \u00e9gal \u00e0 6. 3.c. \u00c9crire une requ\u00eate SQL permettant d'ajouter le titre \u00ab My Generation \u00bb de \u00ab The Who \u00bb \u00e0 la table morceaux . Ce titre est sorti en 1965 et on lui donnera un id_morceau de 7 ainsi que l' id_interprete qui conviendra. 4. \u00c9crire une requ\u00eate permettant de lister les titres des interpr\u00e8tes venant des \u00c9tats-Unis. Proposition de correction 1.a. On obtient les titres 'Hey Jude' et 'I Want To hold Your Hand' . 1.b. SELECT nom FROM interpretes WHERE pays = 'Angleterre' ; 1.c. On obtient : titre annee I Want To hold Your Hand 1963 Like a Rolling Stone 1965 Respect 1967 Hey Jude 1968 Imagine 1970 Smells Like Teen Spirit 1991 1.d. SELECT COUNT ( * ) FROM morceaux ; 1.e. SELECT titre FROM morceaux ORDER BY titre ASC ; 2.a. La cl\u00e9 \u00e9trang\u00e8re est id_interprete qui fait r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire de la table interpretes . 2.b. Sch\u00e9ma des deux relations: interpretes ( id_interprete : INT , nom : TEXT, pays : TEXT) morceaux ( id_morceau : INT , titre : TEXT, annee : INT, #id_interprete : INT) 2.c. Cette requ\u00eate provoque une erreur, car elle essaye d\u2019ajouter \u00e0 la table interpretes une entr\u00e9e ayant pour id_interprete 1. Or, l\u2019attribut id_interprete (qui est une cl\u00e9 primaire) a d\u00e9j\u00e0 une entr\u00e9e avec la valeur 1 (la cl\u00e9 primaire doit \u00eatre unique). 3.a. UPDATE morceaux SET annee = 1971 WHERE titre = 'Imagine' ; 3.b. INSERT INTO interpretes VALUES ( 6 , 'The Who' , 'Angleterre' ); 3.c. INSERT INTO morceaux VALUES ( 7 , 'My Generation' , 1965 , 6 ); 4. SELECT morceaux . titre FROM morceaux JOIN interpretes ON morceaux . id_interprete = interpretes . id_interprete WHERE interpretes . pays = '\u00c9tats-Unis' ;","title":"Exercice BAC 1 : Base de donn\u00e9es musicale"},{"location":"T04_BasesDonnees/Exercices/Exo2_22CEJ1/","text":"Exercice BAC 2: Mesures du r\u00e9chauffement climatique \u2693\ufe0e Dans le cadre d'une \u00e9tude sur le r\u00e9chauffement climatique, un centre m\u00e9t\u00e9orologique rassemble des donn\u00e9es. On consid\u00e8re que la base de donn\u00e9es contient deux relations (tables). La relation Centres qui contient l'identifiant des centres m\u00e9t\u00e9orologiques, la ville, la latitude, la longitude et l'altitude du centre. La relation Mesures qui contient l'identifiant de la mesure, l'identifiant du centre, la date de la mesure, la temp\u00e9rature, la pression et la pluviom\u00e9trie mesur\u00e9es. Le sch\u00e9ma relationnel de la relation Centres est le suivant : Centres ( id_centre : INT , nom_ville : VARCHAR , latitude : FLOAT , longitude : FLOAT , altitude : FLOAT ) Le sch\u00e9ma relationnel de la relation Mesures est le suivant : Mesures ( id_mesure : INT , id_centre : INT , date_mesure : DATE , temperature : FLOAT , pression : INT , pluviometrie : INT ) On fournit ci-dessous le contenu des deux relations. Relation Centres id_centre nom_ville latitude longitude altitude 213 Amiens 49.894 2.293 60 138 Grenoble 45.185 5.723 550 263 Brest 48.388 -4.49 52 185 Tignes 45.469 6.909 2594 459 Nice 43.706 7.262 260 126 Le Puy-en-Velay 45.042 3.888 744 317 G\u00e9rardmer 48.073 6.879 855 Relation Mesures id_mesure id_centre date_mesure temperature pression pluviometrie 1566 138 2021-10-29 8.0 1015 3 1568 213 2021-10-29 15.1 1011 0 2174 126 2021-10-30 18.2 1023 0 2200 185 2021-10-30 5.6 989 20 2232 459 2021-10-31 25.0 1035 0 2514 213 2021-10-31 17.4 1020 0 2563 126 2021-11-01 10.1 1005 15 2592 459 2021-11-01 23.3 1028 2 3425 317 2021-11-02 9.0 1012 13 3430 138 2021-11-02 7.5 996 16 3611 263 2021-11-03 13.9 1005 8 3625 126 2021-11-03 10.8 1008 8 1.a. Proposer une cl\u00e9 primaire pour la relation Mesures . Justifier votre choix. 1.b. Avec quel attribut peut-on faire une jointure entre la relation Centres et la relation Mesures ? 2.a. Qu'affiche la requ\u00eate suivante ? SELECT * FROM Centres WHERE altitude > 500 ; 2.b. On souhaite r\u00e9cup\u00e9rer le nom de la ville des centres m\u00e9t\u00e9orologiques situ\u00e9s \u00e0 une altitude comprise entre 700 m et 1200 m. \u00c9crire la requ\u00eate SQL correspondante. 2.c. On souhaite r\u00e9cup\u00e9rer la liste des longitudes et des noms des villes des centres m\u00e9t\u00e9orologiques dont la longitude est sup\u00e9rieure \u00e0 5. La liste devra \u00eatre tri\u00e9e par ordre alphab\u00e9tique des noms de ville. \u00c9crire la requ\u00eate SQL correspondante. 3.a. Qu'affiche la requ\u00eate suivante ? SELECT * FROM Mesures WHERE date_mesure = \"2021-10-30\" ; 3.b. \u00c9crire une requ\u00eate SQL permettant d'ajouter une mesure prise le 8 novembre 2021 dans le centre num\u00e9ro 138, o\u00f9 la temp\u00e9rature \u00e9tait de 11 \u00b0C, la pression de 1013 hPa et la pluviom\u00e9trie de 0 mm. La donn\u00e9e dont l'attribut est id_mesure aura pour valeur 3650. 4.a. Expliquer ce que renvoie la requ\u00eate SQL suivante. SELECT * FROM Centres WHERE latitude = ( SELECT MIN ( latitude ) FROM Centres ); 4.b. \u00c9crire une requ\u00eate SQL donnant la liste des villes dans lesquelles on a enregistr\u00e9 une temp\u00e9rature inf\u00e9rieure \u00e0 10 \u00b0C en octobre 2021. On utilisera le mot cl\u00e9 DISTINCT afin d'\u00e9viter d'avoir des doublons. On rappelle que l'on peut utiliser les op\u00e9rateurs de comparaison avec les dates.","title":"Exercice BAC 2: Mesures du r\u00e9chauffement climatique"},{"location":"T04_BasesDonnees/Exercices/Exo2_22CEJ1/#exercice-bac-2-mesures-du-rechauffement-climatique","text":"Dans le cadre d'une \u00e9tude sur le r\u00e9chauffement climatique, un centre m\u00e9t\u00e9orologique rassemble des donn\u00e9es. On consid\u00e8re que la base de donn\u00e9es contient deux relations (tables). La relation Centres qui contient l'identifiant des centres m\u00e9t\u00e9orologiques, la ville, la latitude, la longitude et l'altitude du centre. La relation Mesures qui contient l'identifiant de la mesure, l'identifiant du centre, la date de la mesure, la temp\u00e9rature, la pression et la pluviom\u00e9trie mesur\u00e9es. Le sch\u00e9ma relationnel de la relation Centres est le suivant : Centres ( id_centre : INT , nom_ville : VARCHAR , latitude : FLOAT , longitude : FLOAT , altitude : FLOAT ) Le sch\u00e9ma relationnel de la relation Mesures est le suivant : Mesures ( id_mesure : INT , id_centre : INT , date_mesure : DATE , temperature : FLOAT , pression : INT , pluviometrie : INT ) On fournit ci-dessous le contenu des deux relations. Relation Centres id_centre nom_ville latitude longitude altitude 213 Amiens 49.894 2.293 60 138 Grenoble 45.185 5.723 550 263 Brest 48.388 -4.49 52 185 Tignes 45.469 6.909 2594 459 Nice 43.706 7.262 260 126 Le Puy-en-Velay 45.042 3.888 744 317 G\u00e9rardmer 48.073 6.879 855 Relation Mesures id_mesure id_centre date_mesure temperature pression pluviometrie 1566 138 2021-10-29 8.0 1015 3 1568 213 2021-10-29 15.1 1011 0 2174 126 2021-10-30 18.2 1023 0 2200 185 2021-10-30 5.6 989 20 2232 459 2021-10-31 25.0 1035 0 2514 213 2021-10-31 17.4 1020 0 2563 126 2021-11-01 10.1 1005 15 2592 459 2021-11-01 23.3 1028 2 3425 317 2021-11-02 9.0 1012 13 3430 138 2021-11-02 7.5 996 16 3611 263 2021-11-03 13.9 1005 8 3625 126 2021-11-03 10.8 1008 8 1.a. Proposer une cl\u00e9 primaire pour la relation Mesures . Justifier votre choix. 1.b. Avec quel attribut peut-on faire une jointure entre la relation Centres et la relation Mesures ? 2.a. Qu'affiche la requ\u00eate suivante ? SELECT * FROM Centres WHERE altitude > 500 ; 2.b. On souhaite r\u00e9cup\u00e9rer le nom de la ville des centres m\u00e9t\u00e9orologiques situ\u00e9s \u00e0 une altitude comprise entre 700 m et 1200 m. \u00c9crire la requ\u00eate SQL correspondante. 2.c. On souhaite r\u00e9cup\u00e9rer la liste des longitudes et des noms des villes des centres m\u00e9t\u00e9orologiques dont la longitude est sup\u00e9rieure \u00e0 5. La liste devra \u00eatre tri\u00e9e par ordre alphab\u00e9tique des noms de ville. \u00c9crire la requ\u00eate SQL correspondante. 3.a. Qu'affiche la requ\u00eate suivante ? SELECT * FROM Mesures WHERE date_mesure = \"2021-10-30\" ; 3.b. \u00c9crire une requ\u00eate SQL permettant d'ajouter une mesure prise le 8 novembre 2021 dans le centre num\u00e9ro 138, o\u00f9 la temp\u00e9rature \u00e9tait de 11 \u00b0C, la pression de 1013 hPa et la pluviom\u00e9trie de 0 mm. La donn\u00e9e dont l'attribut est id_mesure aura pour valeur 3650. 4.a. Expliquer ce que renvoie la requ\u00eate SQL suivante. SELECT * FROM Centres WHERE latitude = ( SELECT MIN ( latitude ) FROM Centres ); 4.b. \u00c9crire une requ\u00eate SQL donnant la liste des villes dans lesquelles on a enregistr\u00e9 une temp\u00e9rature inf\u00e9rieure \u00e0 10 \u00b0C en octobre 2021. On utilisera le mot cl\u00e9 DISTINCT afin d'\u00e9viter d'avoir des doublons. On rappelle que l'on peut utiliser les op\u00e9rateurs de comparaison avec les dates.","title":"Exercice BAC 2: Mesures du r\u00e9chauffement climatique"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/","text":"T4.1 Mod\u00e8le relationnel \u2693\ufe0e En classe de premi\u00e8re nous avons commenc\u00e9 \u00e0 appr\u00e9hender les tables de donn\u00e9es , sous forme (plate) d'une liste de dictionnaires. Nous avons \u00e9galement vu que la manipulation de ces donn\u00e9es ainsi structur\u00e9es n'est pas toujours pratique. Aujourd'hui, on doit stocker et manipuler rapidement des donn\u00e9es de tailles gigantesques et il faut donc adopter un mod\u00e8le plus efficace : le mod\u00e8le relationnel . Histoire de l'informatique Th\u00e9oris\u00e9 en 1970 par le Britannique Edgar F. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels. 4.1.1 Le mod\u00e8le relationnel \u2693\ufe0e Exemple-type: la base de donn\u00e9e \u00abBiblioth\u00e8que\u00bb Pour illustrer ce chapitre, on s'int\u00e9ressera \u00e0 l'exemple classique de la gestion des emprunts dans une biblioth\u00e8que. Ce syst\u00e8me d'information - syst\u00e8me technique (informatique) permettant de g\u00e9rer de l'information - contient plusieurs cat\u00e9gories d'\u00abobjets\u00bb: des livres : par exemple \u00abAlgorithmes, notions de base\u00bb, Thomas H. Cormen, Dunod, 2013, 978-2-10-070151-3 des usagers : Alice Martin, amartin@protonmail.fr, n\u00b0 abonn\u00e9 125 des emprunts : \u00abAlgorithmes, notions de base\u00bb, Alice Martin, 14/11/2022 Vocabulaire Dans le mod\u00e8le relationnel, on d\u00e9crit chaque objet - appel\u00e9 plut\u00f4t entit\u00e9 ou enregistrement - de chaque cat\u00e9gorie - appel\u00e9e relation - par un n-uplet de valeurs (qui peuvent \u00eatre des chaines de caract\u00e8res, des nombres, etc.) associ\u00e9es \u00e0 des attributs . Une relation est donc un ensemble de n-uplets dont les valeurs appartiennent aux domaines des attributs, qu'on repr\u00e9sente sous forme de table (on confond parfois les termes de table et de relation ). Le cardinal d'une relation R est le nombre d'\u00e9l\u00e9ments (ou enregistrements ou entit\u00e9s) qu'elle contient. On le note #R. Dans l'exemple-type, on a donc trois relations. Dans la premi\u00e8re relation, les \u00ablivres\u00bb, on d\u00e9crit une entit\u00e9 par 5 attributs: le titre, domaine : String l'auteur (ou les auteurs), domaine : String l'\u00e9diteur, domaine : String l'ann\u00e9e de parution, domaine : Int l'ISBN, domaine : String Domaines Les domaines sont des ensembles de valeurs que peut prendre une donn\u00e9e (comme les types en Python): chaines de caract\u00e8res, entiers, flottants, bool\u00e9ens, dates, temps... Table/relation \u00abLivres\u00bb Dans cette table, ('Histoire des codes secrets', 'Simon Singh', 'Le livre de poche', 1999, '978-2-253-15097-8') est un \u00e9l\u00e9ment/enregistrement/entit\u00e9 de la relation sous forme d'un n-uplet. Sch\u00e9ma d'une relation / sch\u00e9ma relationnel On appelle sch\u00e9ma d'une relation l'ensemble ordonn\u00e9 de ses attributs sous la forme : nom domaine . Exemple: Livres (titre String , auteur String , \u00e9diteur String , ann\u00e9e Int , ISBN String ) Lorsqu'une base de donn\u00e9es contient plusieurs relations, l'ensemble des sch\u00e9mas des relations constitue le sch\u00e9ma relationnel de la base de donn\u00e9es. Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire ce que pourraient \u00eatre les sch\u00e9mas des relations Usagers et Emprunts de la base de donn\u00e9es \u00abBiblioth\u00e8que\u00bb. Emprunts (nom String , prenom String , id_usager Int ) Emprunts (ISBN String , id_usager Int , retour Date ) Mod\u00e9lisation et contraintes d'une base de donn\u00e9es Mod\u00e9liser des donn\u00e9es avec pour but de construire une base de donn\u00e9es se fait en plusieurs \u00e9tapes: D\u00e9terminer les entit\u00e9s que l'on souhaite manipuler; Regrouper les entit\u00e9s en relations/tables en choisissant les domaines ad\u00e9quats pour les attributs; D\u00e9finir les contraintes (d'int\u00e9grit\u00e9) de la base de donn\u00e9es, c'est-\u00e0-dire les r\u00e8gles qui assurent la coh\u00e9rence logique des donn\u00e9es. 4.1.2 Cl\u00e9s primaires et \u00e9trang\u00e8res \u2693\ufe0e Cl\u00e9 primaire Une des premi\u00e8res contraintes dont il faut s'occuper, c'est la contrainte de relation : les donn\u00e9es doivent pouvoir \u00eatre identifi\u00e9es de mani\u00e8re unique. Pour cela, chaque relation doit poss\u00e9der un attribut (ou parfois un ensemble d'attributs) dont la valeur va permettre d'identifier chaque entit\u00e9 de mani\u00e8re unique. On l'appelle cl\u00e9 primaire de la relation, et on la souligne dans le sch\u00e9ma de la relation. Si lors de la mod\u00e9lisation on ne dispose pas d'attribut pouvant servir de cl\u00e9 primaire, on cr\u00e9e la plupart du temps une valeur num\u00e9rique servant de cl\u00e9 primaire: un num\u00e9ro d'identifiant. Sch\u00e9ma de la relation \u00abLivres\u00bb Le seul attribut de cette relation pouvant servir de cl\u00e9 primaire est l'ISBN (c'est d'ailleurs sa raison d'\u00eatre ...) On \u00e9crit donc le sch\u00e9ma en soulignant la cl\u00e9 primaire: Livres (titre String , auteur String , \u00e9diteur String , ann\u00e9e Int , ISBN String ) Exercice 2 \u00c9nonc\u00e9 Correction Quelles sont les cl\u00e9s primaires des relations Usagers et Emprunts ? La cl\u00e9 primaire de la relation Usagers est l'attribut id_usager et celle de la relation Emprunts est ISBN . Les cl\u00e9s primaires servent \u00e9galement \u00e0 cr\u00e9er des r\u00e9f\u00e9rences entre diff\u00e9rentes tables. Par exemple, l'utilisation d'un attribut \u00abnom\u00bb dans la relation Emprunts peut causer une erreur ou anomalie dans la base de donn\u00e9es si deux personnes homonymes figurent dans la relation Usagers . Il est donc pr\u00e9f\u00e9rable d'utiliser la cl\u00e9 primaire de la table Usagers pour identifier l'emprunteur dans la relation Emprunts . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re d'une relation est un attribut qui sert \u00e0 caract\u00e9riser une entit\u00e9 et qui est une cl\u00e9 primaire dans une relation li\u00e9e. Dans le sch\u00e9ma d'une relation, on indique les cl\u00e9s \u00e9trang\u00e8res en les soulignant en pointill\u00e9s ou pr\u00e9c\u00e9d\u00e9es d'un # . Les cl\u00e9s \u00e9trang\u00e8res servent \u00e0 v\u00e9rifier les contraintes d'int\u00e9grit\u00e9 r\u00e9f\u00e9rentielles . Exemple Une cl\u00e9 \u00e9trang\u00e8re peut \u00eatre \u00e9galement cl\u00e9 primaire. Emprunts ( #ISBN String , #id_usager Int , retour Date ) 4.1.3 Normalisation des bases de donn\u00e9es : redondance et atomicit\u00e9 des donn\u00e9es \u2693\ufe0e Outre les contraintes d'int\u00e9grit\u00e9, on souhaite respecter certains principes pour \u00e9viter les anomalies dans une base de donn\u00e9es: on parle de normalisation de la base. Parmi ces principes, il faut s'assurer de la non-redondance des donn\u00e9es (les donn\u00e9es ne doivent pas appara\u00eetre plusieurs fois) et de l' atomicit\u00e9 des donn\u00e9es (les donn\u00e9es doivent \u00eatre ins\u00e9cables, pas de listes par exemple). Exemple de redondance des donn\u00e9es \u2693\ufe0e Consid\u00e9rons une autre conception de la relation Emprunts : id_usager date_retour Nom Pr\u00e9nom titre auteur ISBN 845 27/11/2022 DURAND Bob Histoire des codes secrets Simon Singh 978-2-253-15097-8 125 03/12/2022 MARTIN Alice La disparition Georges Perec 978-2-07-071523-7 125 03/12/2022 MARTIN Alice La loi des s\u00e9ries Manu Larcenet 978-2-85-815217-9 En quoi cette relation contredit le principe de non-redondance des donn\u00e9es? Atomicit\u00e9 des donn\u00e9es \u2693\ufe0e Comme on l'a vu en introduction, il est plut\u00f4t compliqu\u00e9 de devoir faire des recherches dans des donn\u00e9es compos\u00e9es (comme des listes par exemple). Si l'on veut faire une requ\u00eate dans notre base de donn\u00e9es sur les ouvrages \u00e9crits par J.K. Rowling par exemple, on constate que dans la relation Livres appara\u00eet un livre comportant plusieurs auteurs, dont J.K. Rowling. Pour am\u00e9liorer les performances de la base de donn\u00e9es, il faut \u00e9viter cela : on parle d' atomicit\u00e9 des donn\u00e9es . Pour y rem\u00e9dier, on va simplifier la relation Livres en supprimant les auteurs: titre \u00e9diteur ann\u00e9e ISBN Algorithmes, notions de base Dunod 2013 978-2-10-070151-3 Harry Potter \u00e0 l\u2019\u00e9cole des sorciers, version illustr\u00e9e Gallimard Jeunesse 2015 978-2-07-066907-3 Harry Potter et la coupe de feu Gallimard Jeunesse 2017 978-2-07-058520-4 Histoire des codes secrets Le livre de Poche 1999 978-2-253-15097-8 La disparition Gallimard 1989 978-2-07-071523-7 La loi des s\u00e9ries Dargaud 1999 978-2-85-815217-9 Puis construire une relation Auteurs et une relation Auteur_de qui relie les auteurs \u00e0 leurs ouvrages. Exercice 3 \u00c9nonc\u00e9 Correction Proposer un sch\u00e9ma de chacune de ces relations, puis construire les tables. 4.1.4 Contraintes d'int\u00e9grit\u00e9 \u2693\ufe0e Pour terminer, r\u00e9capitulons les diff\u00e9rentes contraintes d'int\u00e9grit\u00e9, c'est-\u00e0-dire les r\u00e8gles qui assurent la coh\u00e9rence des donn\u00e9es au sein de la base de donn\u00e9es. Contrainte de relation : chaque entit\u00e9 est identifi\u00e9e de mani\u00e8re unique, \u00e0 l'aide d'une cl\u00e9 primaire. Contrainte de domaine : les valeurs d'un attribut sont restreintes \u00e0 un domaine, ce qui \u00e9vite qu'on puisse donner une valeur ill\u00e9gale. Contrainte de r\u00e9f\u00e9rence : dans deux relations associ\u00e9es, la cl\u00e9 \u00e9trang\u00e8re permet de garantir l'existence d'une entit\u00e9 dans la relation primaire. En particulier: une cl\u00e9 \u00e9trang\u00e8re est imp\u00e9rativement une cl\u00e9 primaire dans la relation \u00e0 laquelle elle se r\u00e9f\u00e8re; une entit\u00e9 de la relation primaire ne peut pas \u00eatre supprim\u00e9e si elle poss\u00e8de des entit\u00e9s li\u00e9es; si des entit\u00e9s sont li\u00e9s, la cl\u00e9 primaire ne peut pas \u00eatre chang\u00e9e . 4.1.5 Exercices \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence Ville D\u00e9partement 1 Poitiers 86 2 La Rochelle 17 3 Angoul\u00eame 16 4 Cognac 16 Voitures id_voiture Marque Mod\u00e8le Kilom\u00e9trage Couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 206 22000 Noir 3 3 Toyota Yaris 33500 Rouge 3 Quelle relation a pour cardinal 3 ? Peut-on ajouter une entit\u00e9 (2, 'Rochefort', 17) \u00e0 la relation Agences ? Pourquoi? Donner le sch\u00e9ma de chaque relation. Quelle table peut contenir des donn\u00e9es redondantes? Comment y rem\u00e9dier? Exercice 5 \u00c9nonc\u00e9 Correction On souhaite mod\u00e9liser un annuaire t\u00e9l\u00e9phonique dans lequel chaque personne est repr\u00e9sent\u00e9e par son nom, son pr\u00e9nom et son num\u00e9ro de t\u00e9l\u00e9phone. Proposer un sch\u00e9ma de cette relation, en pr\u00e9cisant la cl\u00e9 primaire. Annuaire ( num\u00e9ro STRING , nom STRING, pr\u00e9nom STRING) Exercice 6 \u00c9nonc\u00e9 Correction Donner la mod\u00e9lisation relationnelle d'un bulletin scolaire. Pr\u00e9ciser les cl\u00e9s primaires et \u00e9trang\u00e8res. On doit pouvoir repr\u00e9senter: des \u00e9l\u00e8ves, poss\u00e9dant un num\u00e9ro d'\u00e9tudiant alphanum\u00e9rique (INE); des mati\u00e8res; au plus une note sur 20, par mati\u00e8re et par \u00e9l\u00e8ve. Exercice 7 \u00c9nonc\u00e9 Correction Donner la mod\u00e9lisation relationnelle correspondant \u00e0 la situation du \u00abPrequel\u00bb. Peupler chaque table de quelques enregistrements pour illustrer.","title":"T4.1 Mod\u00e8le relationnel"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#t41-modele-relationnel","text":"En classe de premi\u00e8re nous avons commenc\u00e9 \u00e0 appr\u00e9hender les tables de donn\u00e9es , sous forme (plate) d'une liste de dictionnaires. Nous avons \u00e9galement vu que la manipulation de ces donn\u00e9es ainsi structur\u00e9es n'est pas toujours pratique. Aujourd'hui, on doit stocker et manipuler rapidement des donn\u00e9es de tailles gigantesques et il faut donc adopter un mod\u00e8le plus efficace : le mod\u00e8le relationnel . Histoire de l'informatique Th\u00e9oris\u00e9 en 1970 par le Britannique Edgar F. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels.","title":"T4.1 Mod\u00e8le relationnel"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#411-le-modele-relationnel","text":"Exemple-type: la base de donn\u00e9e \u00abBiblioth\u00e8que\u00bb Pour illustrer ce chapitre, on s'int\u00e9ressera \u00e0 l'exemple classique de la gestion des emprunts dans une biblioth\u00e8que. Ce syst\u00e8me d'information - syst\u00e8me technique (informatique) permettant de g\u00e9rer de l'information - contient plusieurs cat\u00e9gories d'\u00abobjets\u00bb: des livres : par exemple \u00abAlgorithmes, notions de base\u00bb, Thomas H. Cormen, Dunod, 2013, 978-2-10-070151-3 des usagers : Alice Martin, amartin@protonmail.fr, n\u00b0 abonn\u00e9 125 des emprunts : \u00abAlgorithmes, notions de base\u00bb, Alice Martin, 14/11/2022 Vocabulaire Dans le mod\u00e8le relationnel, on d\u00e9crit chaque objet - appel\u00e9 plut\u00f4t entit\u00e9 ou enregistrement - de chaque cat\u00e9gorie - appel\u00e9e relation - par un n-uplet de valeurs (qui peuvent \u00eatre des chaines de caract\u00e8res, des nombres, etc.) associ\u00e9es \u00e0 des attributs . Une relation est donc un ensemble de n-uplets dont les valeurs appartiennent aux domaines des attributs, qu'on repr\u00e9sente sous forme de table (on confond parfois les termes de table et de relation ). Le cardinal d'une relation R est le nombre d'\u00e9l\u00e9ments (ou enregistrements ou entit\u00e9s) qu'elle contient. On le note #R. Dans l'exemple-type, on a donc trois relations. Dans la premi\u00e8re relation, les \u00ablivres\u00bb, on d\u00e9crit une entit\u00e9 par 5 attributs: le titre, domaine : String l'auteur (ou les auteurs), domaine : String l'\u00e9diteur, domaine : String l'ann\u00e9e de parution, domaine : Int l'ISBN, domaine : String Domaines Les domaines sont des ensembles de valeurs que peut prendre une donn\u00e9e (comme les types en Python): chaines de caract\u00e8res, entiers, flottants, bool\u00e9ens, dates, temps... Table/relation \u00abLivres\u00bb Dans cette table, ('Histoire des codes secrets', 'Simon Singh', 'Le livre de poche', 1999, '978-2-253-15097-8') est un \u00e9l\u00e9ment/enregistrement/entit\u00e9 de la relation sous forme d'un n-uplet. Sch\u00e9ma d'une relation / sch\u00e9ma relationnel On appelle sch\u00e9ma d'une relation l'ensemble ordonn\u00e9 de ses attributs sous la forme : nom domaine . Exemple: Livres (titre String , auteur String , \u00e9diteur String , ann\u00e9e Int , ISBN String ) Lorsqu'une base de donn\u00e9es contient plusieurs relations, l'ensemble des sch\u00e9mas des relations constitue le sch\u00e9ma relationnel de la base de donn\u00e9es. Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire ce que pourraient \u00eatre les sch\u00e9mas des relations Usagers et Emprunts de la base de donn\u00e9es \u00abBiblioth\u00e8que\u00bb. Emprunts (nom String , prenom String , id_usager Int ) Emprunts (ISBN String , id_usager Int , retour Date ) Mod\u00e9lisation et contraintes d'une base de donn\u00e9es Mod\u00e9liser des donn\u00e9es avec pour but de construire une base de donn\u00e9es se fait en plusieurs \u00e9tapes: D\u00e9terminer les entit\u00e9s que l'on souhaite manipuler; Regrouper les entit\u00e9s en relations/tables en choisissant les domaines ad\u00e9quats pour les attributs; D\u00e9finir les contraintes (d'int\u00e9grit\u00e9) de la base de donn\u00e9es, c'est-\u00e0-dire les r\u00e8gles qui assurent la coh\u00e9rence logique des donn\u00e9es.","title":"4.1.1 Le mod\u00e8le relationnel"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#412-cles-primaires-et-etrangeres","text":"Cl\u00e9 primaire Une des premi\u00e8res contraintes dont il faut s'occuper, c'est la contrainte de relation : les donn\u00e9es doivent pouvoir \u00eatre identifi\u00e9es de mani\u00e8re unique. Pour cela, chaque relation doit poss\u00e9der un attribut (ou parfois un ensemble d'attributs) dont la valeur va permettre d'identifier chaque entit\u00e9 de mani\u00e8re unique. On l'appelle cl\u00e9 primaire de la relation, et on la souligne dans le sch\u00e9ma de la relation. Si lors de la mod\u00e9lisation on ne dispose pas d'attribut pouvant servir de cl\u00e9 primaire, on cr\u00e9e la plupart du temps une valeur num\u00e9rique servant de cl\u00e9 primaire: un num\u00e9ro d'identifiant. Sch\u00e9ma de la relation \u00abLivres\u00bb Le seul attribut de cette relation pouvant servir de cl\u00e9 primaire est l'ISBN (c'est d'ailleurs sa raison d'\u00eatre ...) On \u00e9crit donc le sch\u00e9ma en soulignant la cl\u00e9 primaire: Livres (titre String , auteur String , \u00e9diteur String , ann\u00e9e Int , ISBN String ) Exercice 2 \u00c9nonc\u00e9 Correction Quelles sont les cl\u00e9s primaires des relations Usagers et Emprunts ? La cl\u00e9 primaire de la relation Usagers est l'attribut id_usager et celle de la relation Emprunts est ISBN . Les cl\u00e9s primaires servent \u00e9galement \u00e0 cr\u00e9er des r\u00e9f\u00e9rences entre diff\u00e9rentes tables. Par exemple, l'utilisation d'un attribut \u00abnom\u00bb dans la relation Emprunts peut causer une erreur ou anomalie dans la base de donn\u00e9es si deux personnes homonymes figurent dans la relation Usagers . Il est donc pr\u00e9f\u00e9rable d'utiliser la cl\u00e9 primaire de la table Usagers pour identifier l'emprunteur dans la relation Emprunts . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re d'une relation est un attribut qui sert \u00e0 caract\u00e9riser une entit\u00e9 et qui est une cl\u00e9 primaire dans une relation li\u00e9e. Dans le sch\u00e9ma d'une relation, on indique les cl\u00e9s \u00e9trang\u00e8res en les soulignant en pointill\u00e9s ou pr\u00e9c\u00e9d\u00e9es d'un # . Les cl\u00e9s \u00e9trang\u00e8res servent \u00e0 v\u00e9rifier les contraintes d'int\u00e9grit\u00e9 r\u00e9f\u00e9rentielles . Exemple Une cl\u00e9 \u00e9trang\u00e8re peut \u00eatre \u00e9galement cl\u00e9 primaire. Emprunts ( #ISBN String , #id_usager Int , retour Date )","title":"4.1.2 Cl\u00e9s primaires et \u00e9trang\u00e8res"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#413-normalisation-des-bases-de-donnees-redondance-et-atomicite-des-donnees","text":"Outre les contraintes d'int\u00e9grit\u00e9, on souhaite respecter certains principes pour \u00e9viter les anomalies dans une base de donn\u00e9es: on parle de normalisation de la base. Parmi ces principes, il faut s'assurer de la non-redondance des donn\u00e9es (les donn\u00e9es ne doivent pas appara\u00eetre plusieurs fois) et de l' atomicit\u00e9 des donn\u00e9es (les donn\u00e9es doivent \u00eatre ins\u00e9cables, pas de listes par exemple).","title":"4.1.3 Normalisation des bases de donn\u00e9es : redondance et atomicit\u00e9 des donn\u00e9es"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#exemple-de-redondance-des-donnees","text":"Consid\u00e9rons une autre conception de la relation Emprunts : id_usager date_retour Nom Pr\u00e9nom titre auteur ISBN 845 27/11/2022 DURAND Bob Histoire des codes secrets Simon Singh 978-2-253-15097-8 125 03/12/2022 MARTIN Alice La disparition Georges Perec 978-2-07-071523-7 125 03/12/2022 MARTIN Alice La loi des s\u00e9ries Manu Larcenet 978-2-85-815217-9 En quoi cette relation contredit le principe de non-redondance des donn\u00e9es?","title":"Exemple de redondance des donn\u00e9es"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#atomicite-des-donnees","text":"Comme on l'a vu en introduction, il est plut\u00f4t compliqu\u00e9 de devoir faire des recherches dans des donn\u00e9es compos\u00e9es (comme des listes par exemple). Si l'on veut faire une requ\u00eate dans notre base de donn\u00e9es sur les ouvrages \u00e9crits par J.K. Rowling par exemple, on constate que dans la relation Livres appara\u00eet un livre comportant plusieurs auteurs, dont J.K. Rowling. Pour am\u00e9liorer les performances de la base de donn\u00e9es, il faut \u00e9viter cela : on parle d' atomicit\u00e9 des donn\u00e9es . Pour y rem\u00e9dier, on va simplifier la relation Livres en supprimant les auteurs: titre \u00e9diteur ann\u00e9e ISBN Algorithmes, notions de base Dunod 2013 978-2-10-070151-3 Harry Potter \u00e0 l\u2019\u00e9cole des sorciers, version illustr\u00e9e Gallimard Jeunesse 2015 978-2-07-066907-3 Harry Potter et la coupe de feu Gallimard Jeunesse 2017 978-2-07-058520-4 Histoire des codes secrets Le livre de Poche 1999 978-2-253-15097-8 La disparition Gallimard 1989 978-2-07-071523-7 La loi des s\u00e9ries Dargaud 1999 978-2-85-815217-9 Puis construire une relation Auteurs et une relation Auteur_de qui relie les auteurs \u00e0 leurs ouvrages. Exercice 3 \u00c9nonc\u00e9 Correction Proposer un sch\u00e9ma de chacune de ces relations, puis construire les tables.","title":"Atomicit\u00e9 des donn\u00e9es"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#414-contraintes-dintegrite","text":"Pour terminer, r\u00e9capitulons les diff\u00e9rentes contraintes d'int\u00e9grit\u00e9, c'est-\u00e0-dire les r\u00e8gles qui assurent la coh\u00e9rence des donn\u00e9es au sein de la base de donn\u00e9es. Contrainte de relation : chaque entit\u00e9 est identifi\u00e9e de mani\u00e8re unique, \u00e0 l'aide d'une cl\u00e9 primaire. Contrainte de domaine : les valeurs d'un attribut sont restreintes \u00e0 un domaine, ce qui \u00e9vite qu'on puisse donner une valeur ill\u00e9gale. Contrainte de r\u00e9f\u00e9rence : dans deux relations associ\u00e9es, la cl\u00e9 \u00e9trang\u00e8re permet de garantir l'existence d'une entit\u00e9 dans la relation primaire. En particulier: une cl\u00e9 \u00e9trang\u00e8re est imp\u00e9rativement une cl\u00e9 primaire dans la relation \u00e0 laquelle elle se r\u00e9f\u00e8re; une entit\u00e9 de la relation primaire ne peut pas \u00eatre supprim\u00e9e si elle poss\u00e8de des entit\u00e9s li\u00e9es; si des entit\u00e9s sont li\u00e9s, la cl\u00e9 primaire ne peut pas \u00eatre chang\u00e9e .","title":"4.1.4 Contraintes d'int\u00e9grit\u00e9"},{"location":"T04_BasesDonnees/T4.1_ModeleRel/T4.1_ModeleRel/#415-exercices","text":"Exercice 4 \u00c9nonc\u00e9 Correction Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence Ville D\u00e9partement 1 Poitiers 86 2 La Rochelle 17 3 Angoul\u00eame 16 4 Cognac 16 Voitures id_voiture Marque Mod\u00e8le Kilom\u00e9trage Couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 206 22000 Noir 3 3 Toyota Yaris 33500 Rouge 3 Quelle relation a pour cardinal 3 ? Peut-on ajouter une entit\u00e9 (2, 'Rochefort', 17) \u00e0 la relation Agences ? Pourquoi? Donner le sch\u00e9ma de chaque relation. Quelle table peut contenir des donn\u00e9es redondantes? Comment y rem\u00e9dier? Exercice 5 \u00c9nonc\u00e9 Correction On souhaite mod\u00e9liser un annuaire t\u00e9l\u00e9phonique dans lequel chaque personne est repr\u00e9sent\u00e9e par son nom, son pr\u00e9nom et son num\u00e9ro de t\u00e9l\u00e9phone. Proposer un sch\u00e9ma de cette relation, en pr\u00e9cisant la cl\u00e9 primaire. Annuaire ( num\u00e9ro STRING , nom STRING, pr\u00e9nom STRING) Exercice 6 \u00c9nonc\u00e9 Correction Donner la mod\u00e9lisation relationnelle d'un bulletin scolaire. Pr\u00e9ciser les cl\u00e9s primaires et \u00e9trang\u00e8res. On doit pouvoir repr\u00e9senter: des \u00e9l\u00e8ves, poss\u00e9dant un num\u00e9ro d'\u00e9tudiant alphanum\u00e9rique (INE); des mati\u00e8res; au plus une note sur 20, par mati\u00e8re et par \u00e9l\u00e8ve. Exercice 7 \u00c9nonc\u00e9 Correction Donner la mod\u00e9lisation relationnelle correspondant \u00e0 la situation du \u00abPrequel\u00bb. Peupler chaque table de quelques enregistrements pour illustrer.","title":"4.1.5 Exercices"},{"location":"T04_BasesDonnees/T4.2_SBGD/T4.2_SGBD/","text":"T4.2 SGBD \u2693\ufe0e 4.2.1 Diff\u00e9rents SGBD \u2693\ufe0e Comme son nom l'indique, un SGBD - pour Syst\u00e8me de Gestion de Bases de Donn\u00e9es - est un logiciel qui permet de g\u00e9rer les bases de donn\u00e9es, c'est-\u00e0-dire: cr\u00e9er et supprimer des relations (ou tables); mettre \u00e0 jour les tables (cr\u00e9ation, modification, suppression d'enregitrements dans les tables); rechercher des donn\u00e9es particuli\u00e8res selon plusieurs crit\u00e8res... Ces actions sur les bases de donn\u00e9es s'appellent des requ\u00eates et on utilise le langage SQL (pour Structured Query Language) pour communiquer ces requ\u00eates au SGBD, qui s'assure de pr\u00e9server l'int\u00e9grit\u00e9 de la base de donn\u00e9es. La majorit\u00e9 des SGBD les plus utilis\u00e9s s'appuient sur le mod\u00e8le relationnel : Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La plupart des SGBD sont bas\u00e9s sur le sch\u00e9ma client-serveur : les bases de donn\u00e9es et le SGBD sont situ\u00e9s sur un serveur et le client est un programme qui effectue les requ\u00eates en se connectant au serveur. En NSI, nous utiliserons SQLite qui ne reproduit pas ce sch\u00e9ma et qui sera plus simple d'utilisation, \u00e0 travers une interface graphique DB Browser for SQLite (ou Capytale). 4.2.2 Utilisation de SQLite \u2693\ufe0e Avec DB Browser for SQLite Ouvrir un terminal puis entrer la ligne de commande (mot de passe nsi ): sudo apt-get update Installer le logiciel par: sudo apt-get install sqlitebrowser On pourra ensuite cr\u00e9er une nouvelle base de donn\u00e9es ou en ouvrir une (au format .db ), consulter la structure (le sch\u00e9ma relationnel), parcourir les donn\u00e9es (visualiser le contenu des tables) et \u00e9x\u00e9cuter du code SQL (lancer des ordres). Dans le terminal, sans environnement graphique On utilise l'interpr\u00e9teur sqlite3 , dont les commandes sont toutes pr\u00e9fix\u00e9es par un point, sans ; en fin de ligne. Les commandes que l'on peut utiliser (voir ici pour plus de commandes) sont .open , .import , .mode , .headers , .schema , .exit . Installer sqlite3 par : sudo apt-get install sqlite3","title":"T4.2 SGBD"},{"location":"T04_BasesDonnees/T4.2_SBGD/T4.2_SGBD/#t42-sgbd","text":"","title":"T4.2 SGBD"},{"location":"T04_BasesDonnees/T4.2_SBGD/T4.2_SGBD/#421-differents-sgbd","text":"Comme son nom l'indique, un SGBD - pour Syst\u00e8me de Gestion de Bases de Donn\u00e9es - est un logiciel qui permet de g\u00e9rer les bases de donn\u00e9es, c'est-\u00e0-dire: cr\u00e9er et supprimer des relations (ou tables); mettre \u00e0 jour les tables (cr\u00e9ation, modification, suppression d'enregitrements dans les tables); rechercher des donn\u00e9es particuli\u00e8res selon plusieurs crit\u00e8res... Ces actions sur les bases de donn\u00e9es s'appellent des requ\u00eates et on utilise le langage SQL (pour Structured Query Language) pour communiquer ces requ\u00eates au SGBD, qui s'assure de pr\u00e9server l'int\u00e9grit\u00e9 de la base de donn\u00e9es. La majorit\u00e9 des SGBD les plus utilis\u00e9s s'appuient sur le mod\u00e8le relationnel : Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La plupart des SGBD sont bas\u00e9s sur le sch\u00e9ma client-serveur : les bases de donn\u00e9es et le SGBD sont situ\u00e9s sur un serveur et le client est un programme qui effectue les requ\u00eates en se connectant au serveur. En NSI, nous utiliserons SQLite qui ne reproduit pas ce sch\u00e9ma et qui sera plus simple d'utilisation, \u00e0 travers une interface graphique DB Browser for SQLite (ou Capytale).","title":"4.2.1 Diff\u00e9rents SGBD"},{"location":"T04_BasesDonnees/T4.2_SBGD/T4.2_SGBD/#422-utilisation-de-sqlite","text":"Avec DB Browser for SQLite Ouvrir un terminal puis entrer la ligne de commande (mot de passe nsi ): sudo apt-get update Installer le logiciel par: sudo apt-get install sqlitebrowser On pourra ensuite cr\u00e9er une nouvelle base de donn\u00e9es ou en ouvrir une (au format .db ), consulter la structure (le sch\u00e9ma relationnel), parcourir les donn\u00e9es (visualiser le contenu des tables) et \u00e9x\u00e9cuter du code SQL (lancer des ordres). Dans le terminal, sans environnement graphique On utilise l'interpr\u00e9teur sqlite3 , dont les commandes sont toutes pr\u00e9fix\u00e9es par un point, sans ; en fin de ligne. Les commandes que l'on peut utiliser (voir ici pour plus de commandes) sont .open , .import , .mode , .headers , .schema , .exit . Installer sqlite3 par : sudo apt-get install sqlite3","title":"4.2.2 Utilisation de SQLite"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/","text":"T4.3 Langage SQL (partie 1) \u2693\ufe0e Le langage SQL permet de communiquer avec le SGBD pour exploiter une base de donn\u00e9es \u00e0 l'aide de requ\u00eates . Il comporte plusieurs parties, dont la partie langage de d\u00e9finition des donn\u00e9es (LDD) et la partie langage de manipulation des donn\u00e9es (LMD) qui sont au programme de NSI (plus ou moins explicitement...). 4.3.1 La d\u00e9finition des donn\u00e9es (LDD) \u2693\ufe0e \u25b6 Les types de donn\u00e9es (Domaines) \u2693\ufe0e Non standardisation Les diff\u00e9rents types de donn\u00e9es peuvent varier d'un SGBD \u00e0 l'autre... Dans le tableau suivant, on donne les types les plus traditionnels (tels qu'on les manipulera avec SQLite et donn\u00e9s dans les sujets de BAC). Classe de stockage Type de donn\u00e9e repr\u00e9sent\u00e9e INTEGER Nombre entier (sur n bits, selon la taille) REAL Nombre flottant (8 bits, norme IEEE-754) DATE Format date, norme ISO AAAA-MM-JJ DATETIME Format date et heure, norme ISO AAAA-MM-JJ HH:MM:SS.SSS TEXT Cha\u00eene de caract\u00e8res cod\u00e9es selon l\u2019encodage sp\u00e9cifi\u00e9 (UTF-8, ...) VARCHAR ( n ) Cha\u00eene de caract\u00e8res limit\u00e9e \u00e0 n caract\u00e8res BLOB Donn\u00e9es brutes, octets, images\u2026 stock\u00e9es au format binaire. \u25b6 CREATE TABLE \u2693\ufe0e Le mot-cl\u00e9 CREATE TABLE permet de cr\u00e9er une table (\u00e9tonnant, non?) en pr\u00e9cisant son sch\u00e9ma. Exemple de cr\u00e9ation d'une table CREATE TABLE livre ( titre TEXT , editeur VARCHAR ( 45 ), annee INTEGER , isbn VARCHAR ( 17 ) PRIMARY KEY ); Syntaxe Si dans une requ\u00eate SQL la casse n'est pas importante (on aurait tr\u00e8s bien pu \u00e9crire Create Table ou create table ), il ne faut pas oublier le \u00ab ; \u00bb en fin de requ\u00eate ! Exercice 1 \u00c9nonc\u00e9 Correction Lancer DB Browser for SQLite et cr\u00e9er une nouvelle base de donn\u00e9e bibliotheque.db (ne pas oublier l'extension). Fermer la fen\u00eatre de cr\u00e9ation. Dans l'onglet Ex\u00e9cuter le SQL , copier-coller le code pr\u00e9c\u00e9dent, puis ex\u00e9cuter le code (bouton \u25b6 ou F5). Dans l'onglet Structure de la Base de Donn\u00e9es , v\u00e9rifier le sch\u00e9ma de cette table livre . De la m\u00eame fa\u00e7on, cr\u00e9er la table usager en reprenant le sch\u00e9ma du chapitre T4.1 . CREATE TABLE usager ( nom VARCHAR ( 45 ), prenom VARCHAR ( 30 ), id_usager INTEGER PRIMARY KEY ); Pour d\u00e9finir une cl\u00e9 \u00e9trang\u00e8re dans la cr\u00e9ation d'une table, on utilisera le mot-cl\u00e9 REFERENCES en indiquant la table et l'attribut auquel la cl\u00e9 fait r\u00e9f\u00e9rence. Par exemple, pour cr\u00e9er la table emprunt , on commencera par: CREATE TABLE emprunt ( isbn VARCHAR ( 17 ) PRIMARY KEY REFERENCES livre ( isbn ), ... ); Exercice 2 \u00c9nonc\u00e9 Correction Terminer la requ\u00eate de cr\u00e9ation de la table emprunt . CREATE TABLE emprunt ( isbn VARCHAR ( 17 ) PRIMARY KEY REFERENCES livre ( isbn ), id_usager INTEGER REFERENCES usager ( id_usager ), date_retour DATE ); \u25b6 DROP TABLE \u2693\ufe0e Le mot-cl\u00e9 DROP TABLE permet de supprimer une table. Script SQL pour effacer la base de donn\u00e9es DROP TABLE emprunt ; DROP TABLE usager ; DROP TABLE livre ; 4.3.2 La manipulation des donn\u00e9es (LMD) : Requ\u00eates de mise \u00e0 jour \u2693\ufe0e Commen\u00e7ons par cr\u00e9er la table \u00e9l\u00e8ve suivante (je sais, il y a des erreurs): id_eleve pr\u00e9nom nom moyenne maison 1 Harry Potter 17 Gryffondor 2 Hermione Granger 9 Gryffondor 3 Luna Lovegood 13 Serdaigle 4 Drago Malefoy 15 Poufsouffle \u25b6 INSERT \u2693\ufe0e Pour ins\u00e9rer dans une table une ligne (un enregistrement, une entit\u00e9) sous la forme d'un n-uplet de valeurs, on utilise les mots-cl\u00e9s INSERT INTO ... VALUES ... . Exemple d'insertion dans une table INSERT INTO eleve VALUES ( 1 , 'Harry' , 'Potter' , 17 , 'Gryffondor' ); On peut \u00e9galement ins\u00e9rer plusieurs lignes \u00e0 la fois, en s\u00e9parant les n-uplets par des virgules: Exemple d'insertion multiple dans une table INSERT INTO eleve VALUES ( 2 , 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 3 , 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ); Exercice 3 \u00c9nonc\u00e9 Correction Dans une nouvelle base de donn\u00e9es, cr\u00e9er la table \u00e9l\u00e8ve . Ins\u00e9rer les valeurs dans la table. Ajouter la ligne ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ) . Que se passe-t-il? Pourquoi? Ajouter la ligne en rectifiant. -- 1. CREATE TABLE eleve ( id_eleve INTEGER PRIMARY KEY , prenom VARCHAR ( 30 ), nom VARCHAR ( 30 ), moyenne REAL , maison VARCHAR ( 15 ) REFERENCES maison ( nom ) ); -- 2. INSERT INTO eleve VALUES ( 1 , 'Harry' , 'Potter' , 17 , 'Gryffondor' ), ( 2 , 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 3 , 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ), ( 4 , 'Drago' , 'Malefoy' , 15 , 'Poufsouffle' ); -- 3. INSERT INTO eleve VALUES ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ); -- 4. INSERT INTO eleve VALUES ( 5 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ); L'insertion de la ligne ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ) provoque une erreur (violation de la contrainte de relation) car une valeur de 4 existe d\u00e9j\u00e0 dans la table eleve pour l'attribut id_eleve qui est une cl\u00e9 primaire. Astuce hors-programme On peut d\u00e9l\u00e9guer la gestion des cl\u00e9s primaires avec l'instruction AUTOINCREMENT . CREATE TABLE eleve ( id INTEGER PRIMARY KEY AUTOINCREMENT , prenom VARCHAR ( 30 ), nom VARCHAR ( 30 ), moyenne REAL , maison VARCHAR ( 12 ) ); INSERT INTO eleve ( prenom , nom , moyenne , maison ) VALUES ( 'Harry' , 'Potter' , 17 , 'Gryffondor' ), ( 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ), ( 'Drago' , 'Malefoy' , 15 , 'Poufsouffle' ); Exercice 4 \u00c9nonc\u00e9 Correction Dans la base de donn\u00e9es pr\u00e9c\u00e9dente, cr\u00e9er les tables professeur puis maison en suivant les sch\u00e9mas: professeur ( id_prof Int , nom String , cours String ) maison ( nom String , dortoir String , #id_prof Int ) Ins\u00e9rer dans la table professeur les lignes (1, 'Rogue', 'potion'), (2, 'Macgonagall', 'm\u00e9tamorphose'), (3, 'Flitwick', 'sortil\u00e8ge'), (4, 'Chourave', 'botanique') . Ins\u00e9rer dans la table maison les lignes ('Gryffondor', 'tour', 2), ('Poufsouffle', 'sous-sol', 4), ('Serpentard', 'cachot', 1) . Ins\u00e9rer dans la table maison la ligne ('Serdaigle', 'tour', 5) . Que se passe-t-il? Pourquoi? -- 1. CREATE TABLE professeur ( id_prof INTEGER PRIMARY KEY , nom VARCHAR ( 30 ), cours VARCHAR ( 25 ) ); CREATE TABLE maison ( nom VARCHAR ( 15 ) PRIMARY KEY , dortoir VARCHAR ( 15 ), id_prof INTEGER REFERENCES professeur ( id_prof ) ); -- 2. INSERT INTO professeur VALUES ( 1 , 'Rogue' , 'potion' ), ( 2 , 'Macgonagall' , 'm\u00e9tamorphose' ), ( 3 , 'Flitwick' , 'sortil\u00e8ge' ), ( 4 , 'Chourave' , 'botanique' ) ; -- 3. INSERT INTO maison VALUES ( 'Gryffondor' , 'tour' , 2 ), ( 'Poufsouffle' , 'sous-sol' , 4 ), ( 'Serpentard' , 'cachot' , 1 ) ; -- 4. INSERT INTO maison VALUES ( 'Serdaigle' , 'tour' , 5 ); L'insertion provoque une erreur (violation de la contrainte de r\u00e9f\u00e9rence) car id_prof est une cl\u00e9 \u00e9trang\u00e8re et la valeur 5 n'existe pas dans la table professeur \u00e0 laquelle elle fait r\u00e9f\u00e9rence. \u25b6 UPDATE \u2693\ufe0e Le mot-cl\u00e9 UPDATE permet d'actualiser une ou plusieurs valeurs d'une ligne (ou de plusieurs lignes). Exemple de modification d'une valeur UPDATE eleve SET moyenne = 19 WHERE nom = 'Granger' ; Remarques On a pr\u00e9cis\u00e9 la ligne o\u00f9 la modification doit avoir lieu avec la clause WHERE . Sans cette clause, toutes les valeurs de l'attribut moyenne auraient \u00e9t\u00e9 modifi\u00e9es. On peut modifier plusieurs attributs en les s\u00e9parant par une virgule apr\u00e8s le mot-cl\u00e9 SET . Exercice 5 \u00c9nonc\u00e9 Correction Rectifier la maison de Drago Malefoy (Serpentard, pour les incultes). En une seule requ\u00eate, rectifier l'orthographe de Ron Weasley et augmenter sa moyenne de 0.5 point (on peut faire un calcul sur l'attribut). -- 1. UPDATE eleve SET maison = 'Serpentard' WHERE prenom = 'Drago' ; -- 2. UPDATE eleve SET nom = 'Weasley' , moyenne = moyenne + 0 . 5 WHERE id = 5 ; \u25b6 DELETE \u2693\ufe0e \u00c0 utiliser avec pr\u00e9caution, le mot-cl\u00e9 DELETE permet de supprimer une ou plusieurs lignes. Exemple de suppression d'une ligne DELETE FROM eleve WHERE nom = 'Malefoy' ; Sans la clause WHERE , toutes les lignes de la table auraient \u00e9t\u00e9 supprim\u00e9es par la requ\u00eate DELETE FROM eleve ; . Exercice 6 \u00c9nonc\u00e9 Correction Supprimer tous les \u00e9l\u00e8ves qui ne sont pas de la maison Gryffondor. DELETE FROM eleve WHERE maison != 'Gryffondor' ;","title":"T4.3 Langage SQL (partie 1)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#t43-langage-sql-partie-1","text":"Le langage SQL permet de communiquer avec le SGBD pour exploiter une base de donn\u00e9es \u00e0 l'aide de requ\u00eates . Il comporte plusieurs parties, dont la partie langage de d\u00e9finition des donn\u00e9es (LDD) et la partie langage de manipulation des donn\u00e9es (LMD) qui sont au programme de NSI (plus ou moins explicitement...).","title":"T4.3 Langage SQL (partie 1)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#431-la-definition-des-donnees-ldd","text":"","title":"4.3.1 La d\u00e9finition des donn\u00e9es (LDD)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#les-types-de-donnees-domaines","text":"Non standardisation Les diff\u00e9rents types de donn\u00e9es peuvent varier d'un SGBD \u00e0 l'autre... Dans le tableau suivant, on donne les types les plus traditionnels (tels qu'on les manipulera avec SQLite et donn\u00e9s dans les sujets de BAC). Classe de stockage Type de donn\u00e9e repr\u00e9sent\u00e9e INTEGER Nombre entier (sur n bits, selon la taille) REAL Nombre flottant (8 bits, norme IEEE-754) DATE Format date, norme ISO AAAA-MM-JJ DATETIME Format date et heure, norme ISO AAAA-MM-JJ HH:MM:SS.SSS TEXT Cha\u00eene de caract\u00e8res cod\u00e9es selon l\u2019encodage sp\u00e9cifi\u00e9 (UTF-8, ...) VARCHAR ( n ) Cha\u00eene de caract\u00e8res limit\u00e9e \u00e0 n caract\u00e8res BLOB Donn\u00e9es brutes, octets, images\u2026 stock\u00e9es au format binaire.","title":"\u25b6 Les types de donn\u00e9es (Domaines)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#create-table","text":"Le mot-cl\u00e9 CREATE TABLE permet de cr\u00e9er une table (\u00e9tonnant, non?) en pr\u00e9cisant son sch\u00e9ma. Exemple de cr\u00e9ation d'une table CREATE TABLE livre ( titre TEXT , editeur VARCHAR ( 45 ), annee INTEGER , isbn VARCHAR ( 17 ) PRIMARY KEY ); Syntaxe Si dans une requ\u00eate SQL la casse n'est pas importante (on aurait tr\u00e8s bien pu \u00e9crire Create Table ou create table ), il ne faut pas oublier le \u00ab ; \u00bb en fin de requ\u00eate ! Exercice 1 \u00c9nonc\u00e9 Correction Lancer DB Browser for SQLite et cr\u00e9er une nouvelle base de donn\u00e9e bibliotheque.db (ne pas oublier l'extension). Fermer la fen\u00eatre de cr\u00e9ation. Dans l'onglet Ex\u00e9cuter le SQL , copier-coller le code pr\u00e9c\u00e9dent, puis ex\u00e9cuter le code (bouton \u25b6 ou F5). Dans l'onglet Structure de la Base de Donn\u00e9es , v\u00e9rifier le sch\u00e9ma de cette table livre . De la m\u00eame fa\u00e7on, cr\u00e9er la table usager en reprenant le sch\u00e9ma du chapitre T4.1 . CREATE TABLE usager ( nom VARCHAR ( 45 ), prenom VARCHAR ( 30 ), id_usager INTEGER PRIMARY KEY ); Pour d\u00e9finir une cl\u00e9 \u00e9trang\u00e8re dans la cr\u00e9ation d'une table, on utilisera le mot-cl\u00e9 REFERENCES en indiquant la table et l'attribut auquel la cl\u00e9 fait r\u00e9f\u00e9rence. Par exemple, pour cr\u00e9er la table emprunt , on commencera par: CREATE TABLE emprunt ( isbn VARCHAR ( 17 ) PRIMARY KEY REFERENCES livre ( isbn ), ... ); Exercice 2 \u00c9nonc\u00e9 Correction Terminer la requ\u00eate de cr\u00e9ation de la table emprunt . CREATE TABLE emprunt ( isbn VARCHAR ( 17 ) PRIMARY KEY REFERENCES livre ( isbn ), id_usager INTEGER REFERENCES usager ( id_usager ), date_retour DATE );","title":"\u25b6 CREATE TABLE"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#drop-table","text":"Le mot-cl\u00e9 DROP TABLE permet de supprimer une table. Script SQL pour effacer la base de donn\u00e9es DROP TABLE emprunt ; DROP TABLE usager ; DROP TABLE livre ;","title":"\u25b6 DROP TABLE"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#432-la-manipulation-des-donnees-lmd-requetes-de-mise-a-jour","text":"Commen\u00e7ons par cr\u00e9er la table \u00e9l\u00e8ve suivante (je sais, il y a des erreurs): id_eleve pr\u00e9nom nom moyenne maison 1 Harry Potter 17 Gryffondor 2 Hermione Granger 9 Gryffondor 3 Luna Lovegood 13 Serdaigle 4 Drago Malefoy 15 Poufsouffle","title":"4.3.2 La manipulation des donn\u00e9es (LMD) : Requ\u00eates de mise \u00e0 jour"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#insert","text":"Pour ins\u00e9rer dans une table une ligne (un enregistrement, une entit\u00e9) sous la forme d'un n-uplet de valeurs, on utilise les mots-cl\u00e9s INSERT INTO ... VALUES ... . Exemple d'insertion dans une table INSERT INTO eleve VALUES ( 1 , 'Harry' , 'Potter' , 17 , 'Gryffondor' ); On peut \u00e9galement ins\u00e9rer plusieurs lignes \u00e0 la fois, en s\u00e9parant les n-uplets par des virgules: Exemple d'insertion multiple dans une table INSERT INTO eleve VALUES ( 2 , 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 3 , 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ); Exercice 3 \u00c9nonc\u00e9 Correction Dans une nouvelle base de donn\u00e9es, cr\u00e9er la table \u00e9l\u00e8ve . Ins\u00e9rer les valeurs dans la table. Ajouter la ligne ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ) . Que se passe-t-il? Pourquoi? Ajouter la ligne en rectifiant. -- 1. CREATE TABLE eleve ( id_eleve INTEGER PRIMARY KEY , prenom VARCHAR ( 30 ), nom VARCHAR ( 30 ), moyenne REAL , maison VARCHAR ( 15 ) REFERENCES maison ( nom ) ); -- 2. INSERT INTO eleve VALUES ( 1 , 'Harry' , 'Potter' , 17 , 'Gryffondor' ), ( 2 , 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 3 , 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ), ( 4 , 'Drago' , 'Malefoy' , 15 , 'Poufsouffle' ); -- 3. INSERT INTO eleve VALUES ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ); -- 4. INSERT INTO eleve VALUES ( 5 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ); L'insertion de la ligne ( 4 , 'Ron' , 'Wisley' , 16 , 'Gryffondor' ) provoque une erreur (violation de la contrainte de relation) car une valeur de 4 existe d\u00e9j\u00e0 dans la table eleve pour l'attribut id_eleve qui est une cl\u00e9 primaire. Astuce hors-programme On peut d\u00e9l\u00e9guer la gestion des cl\u00e9s primaires avec l'instruction AUTOINCREMENT . CREATE TABLE eleve ( id INTEGER PRIMARY KEY AUTOINCREMENT , prenom VARCHAR ( 30 ), nom VARCHAR ( 30 ), moyenne REAL , maison VARCHAR ( 12 ) ); INSERT INTO eleve ( prenom , nom , moyenne , maison ) VALUES ( 'Harry' , 'Potter' , 17 , 'Gryffondor' ), ( 'Hermione' , 'Granger' , 9 , 'Gryffondor' ), ( 'Luna' , 'Lovegood' , 13 , 'Serdaigle' ), ( 'Drago' , 'Malefoy' , 15 , 'Poufsouffle' ); Exercice 4 \u00c9nonc\u00e9 Correction Dans la base de donn\u00e9es pr\u00e9c\u00e9dente, cr\u00e9er les tables professeur puis maison en suivant les sch\u00e9mas: professeur ( id_prof Int , nom String , cours String ) maison ( nom String , dortoir String , #id_prof Int ) Ins\u00e9rer dans la table professeur les lignes (1, 'Rogue', 'potion'), (2, 'Macgonagall', 'm\u00e9tamorphose'), (3, 'Flitwick', 'sortil\u00e8ge'), (4, 'Chourave', 'botanique') . Ins\u00e9rer dans la table maison les lignes ('Gryffondor', 'tour', 2), ('Poufsouffle', 'sous-sol', 4), ('Serpentard', 'cachot', 1) . Ins\u00e9rer dans la table maison la ligne ('Serdaigle', 'tour', 5) . Que se passe-t-il? Pourquoi? -- 1. CREATE TABLE professeur ( id_prof INTEGER PRIMARY KEY , nom VARCHAR ( 30 ), cours VARCHAR ( 25 ) ); CREATE TABLE maison ( nom VARCHAR ( 15 ) PRIMARY KEY , dortoir VARCHAR ( 15 ), id_prof INTEGER REFERENCES professeur ( id_prof ) ); -- 2. INSERT INTO professeur VALUES ( 1 , 'Rogue' , 'potion' ), ( 2 , 'Macgonagall' , 'm\u00e9tamorphose' ), ( 3 , 'Flitwick' , 'sortil\u00e8ge' ), ( 4 , 'Chourave' , 'botanique' ) ; -- 3. INSERT INTO maison VALUES ( 'Gryffondor' , 'tour' , 2 ), ( 'Poufsouffle' , 'sous-sol' , 4 ), ( 'Serpentard' , 'cachot' , 1 ) ; -- 4. INSERT INTO maison VALUES ( 'Serdaigle' , 'tour' , 5 ); L'insertion provoque une erreur (violation de la contrainte de r\u00e9f\u00e9rence) car id_prof est une cl\u00e9 \u00e9trang\u00e8re et la valeur 5 n'existe pas dans la table professeur \u00e0 laquelle elle fait r\u00e9f\u00e9rence.","title":"\u25b6 INSERT"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#update","text":"Le mot-cl\u00e9 UPDATE permet d'actualiser une ou plusieurs valeurs d'une ligne (ou de plusieurs lignes). Exemple de modification d'une valeur UPDATE eleve SET moyenne = 19 WHERE nom = 'Granger' ; Remarques On a pr\u00e9cis\u00e9 la ligne o\u00f9 la modification doit avoir lieu avec la clause WHERE . Sans cette clause, toutes les valeurs de l'attribut moyenne auraient \u00e9t\u00e9 modifi\u00e9es. On peut modifier plusieurs attributs en les s\u00e9parant par une virgule apr\u00e8s le mot-cl\u00e9 SET . Exercice 5 \u00c9nonc\u00e9 Correction Rectifier la maison de Drago Malefoy (Serpentard, pour les incultes). En une seule requ\u00eate, rectifier l'orthographe de Ron Weasley et augmenter sa moyenne de 0.5 point (on peut faire un calcul sur l'attribut). -- 1. UPDATE eleve SET maison = 'Serpentard' WHERE prenom = 'Drago' ; -- 2. UPDATE eleve SET nom = 'Weasley' , moyenne = moyenne + 0 . 5 WHERE id = 5 ;","title":"\u25b6 UPDATE"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL1/#delete","text":"\u00c0 utiliser avec pr\u00e9caution, le mot-cl\u00e9 DELETE permet de supprimer une ou plusieurs lignes. Exemple de suppression d'une ligne DELETE FROM eleve WHERE nom = 'Malefoy' ; Sans la clause WHERE , toutes les lignes de la table auraient \u00e9t\u00e9 supprim\u00e9es par la requ\u00eate DELETE FROM eleve ; . Exercice 6 \u00c9nonc\u00e9 Correction Supprimer tous les \u00e9l\u00e8ves qui ne sont pas de la maison Gryffondor. DELETE FROM eleve WHERE maison != 'Gryffondor' ;","title":"\u25b6 DELETE"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/","text":"T4.3 Langage SQL (partie 2) \u2693\ufe0e 4.3.3 La manipulation des donn\u00e9es (LMD) : Requ\u00eates d'interrogation avec SELECT \u2693\ufe0e SELECT est le mot-cl\u00e9 le plus important et le plus utilis\u00e9 en SQL : il permet de s\u00e9lectionner des lignes, des colonnes d'une ou plusieurs tables, mais aussi transformer des donn\u00e9es par l'utilisation de fonction ou encore r\u00e9aliser des calculs. Exemple-type Tous les exemples de ce chapitre sont \u00e0 tester \u00e0 partir de la base de donn\u00e9es livres.db issue de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie dans les sources du site, qui reprend (\u00e0 peu-pr\u00e8s) le sch\u00e9ma de la base biblioth\u00e8que \u00e9tudi\u00e9e aux chapitres pr\u00e9c\u00e9dents. Syntaxe g\u00e9n\u00e9rale SELECT colonnes ou \u00e9 l\u00e9ments d ' extraction FROM table ( s ) WHERE condition ( s ) - optionnel ORDER BY tri ( s ) - optionnel ; 1. S\u00e9lection et projection \u2693\ufe0e S\u00e9lectionner des lignes Sans condition Avec une condition Avec des conditions Avec un tri Requ\u00eate approch\u00e9e On obtient alors l'int\u00e9gralit\u00e9 de la table. On utilise l'ast\u00e9risque * pour indiquer qu'on souhaite toutes les colonnes. S\u00e9lectionner tous les usagers SELECT * FROM usager ; On utilise la clause WHERE pour indiquer une condition sur la s\u00e9lection des lignes. S\u00e9lectionner les usagers vivant dans le 15e arrondissement de Paris SELECT * FROM usager WHERE cp = '75005' ; On peut utiliser des op\u00e9rateurs bool\u00e9ens dans l'\u00e9criture de la condition. S\u00e9lectionner les livres parus entre 2000 et 2005 SELECT * FROM livre WHERE annee >= 2000 AND annee <= 2005 ; On peut ajouter un tri sur les r\u00e9sultats, en pr\u00e9cisant l'attribut sur lequel s'effectue le tri et \u00e9ventuellement l'ordre de tri par les mots-cl\u00e9s ASC (par d\u00e9faut) ou DESC . S\u00e9lectionner les livres parus entre 2000 et 2005 et les trier par editeur SELECT * FROM livre WHERE annee >= 2000 AND annee <= 2005 ORDER BY editeur ; Si la condition de recherche porte sur une cha\u00eene de caract\u00e8res, l'op\u00e9rateur = peut ne pas \u00eatre appropri\u00e9. On utilise alors plut\u00f4t le mot-cl\u00e9 LIKE , avec une cha\u00eene de caract\u00e8re compos\u00e9e d'un motif utilisant des jokers % pour remplacer une cha\u00eene de caract\u00e8res quelconque. S\u00e9lectionner les lignes dont le titre contient la cha\u00eene `Ast\u00e9rix` SELECT * FROM livre WHERE titre LIKE '%Ast\u00e9rix%' ; Exercice 1 \u00c9nonc\u00e9 Correction Effectuer les requ\u00eates suivantes: S\u00e9lectionner les livres qui ne sont pas parus en 2008, class\u00e9s du plus r\u00e9cent au plus vieux. S\u00e9lectionner les usagers dont le pr\u00e9nom est JULIEN ou DAVID. S\u00e9lectionner les auteurs dont le pr\u00e9nom commence par un M. SELECT * FROM livre WHERE annee != 2008 ORDER BY annee DESC ; SELECT * FROM usager WHERE prenom = 'JULIEN' OR Prenom = 'DAVID' ; SELECT * FROM auteur WHERE prenom LIKE 'M%' ORDER BY prenom ; S\u00e9lectionner des colonnes (projection) Plut\u00f4t que de s\u00e9lectionner toutes les colonnes avec le joker * on peut pr\u00e9ciser quels attributs on souhaite afficher dans les r\u00e9sultats de la requ\u00eate. On nomme cette op\u00e9ration projection . Une colonne Plusieurs colonnes Gestion des doublons S\u00e9lectionner uniquement les titres des livres parus en 2000 SELECT titre FROM livre WHERE annee = 2000 ; S\u00e9lectionner les titres et l'ann\u00e9e de parution des livres parus avant 2000 SELECT titre , annee FROM livre WHERE annee < 2000 ; Si on s\u00e9lectionne la colonne (l'attribut) editeur de la table livre par la requ\u00eate suivante, on s'aper\u00e7oit qu'on obtient plusieurs fois les m\u00eames noms d'\u00e9diteur. SELECT editeur FROM livre ; Pour obtenir uniquement les valeurs diff\u00e9rentes de cette colonne, on utilise le mot-cl\u00e9 DISTINCT (le tri est facultatif, il est pr\u00e9sent ici pour bien visualiser l'absence des doublons): SELECT DISTINCT editeur FROM livre ORDER BY editeur ; Exercice 2 \u00c9nonc\u00e9 Correction Effectuer les requ\u00eates suivantes sur la table livre : S\u00e9lectionner les titres et les ISBN des livres parus \u00e0 partir de 1990. S\u00e9lectionner les ann\u00e9es (sans doublon) pour lesquelles un livre est paru chez Flammarion, tri\u00e9es dans l'ordre croissant. SELECT titre , isbn FROM livre WHERE annee >= 1990 ; SELECT DISTINCT annee FROM livre WHERE editeur = 'Flammarion' ORDER BY annee ; 2. Agr\u00e9gation \u2693\ufe0e Une autre utilisation de la clause SELECT est d'appeler une fonction d'agr\u00e9gation , c'est-\u00e0-dire une fonction que l'on applique \u00e0 l'ensemble des valeurs d'une colonne et qui renvoie une table r\u00e9duite \u00e0 une cellule contenant le r\u00e9sultat du calcul. On peut par exemple compter le nombre de valeurs (mot-cl\u00e9 COUNT ), faire une somme ( SUM ), calculer une moyenne ( AVG ) ou encore trouver un minimum/maximum ( MIN , MAX ). Agr\u00e9gation COUNT SUM , AVG MIN , MAX Compter le nombre d'usagers SELECT COUNT ( * ) FROM usager ; Remarque: on peut utiliser un alias avec AS pour nommer le r\u00e9sultat: Avec utilisation d'un alias SELECT COUNT ( * ) AS total FROM usager ; Les fonctions SUM et AVG s'utilisent de la m\u00eame fa\u00e7on, ici un exemple (totalement d\u00e9nu\u00e9 de sens) pour illustrer AVG : Calculer l'ann\u00e9e moyenne de parution SELECT AVG ( annee ) FROM livre ; D\u00e9terminer l'ann\u00e9e de parution la plus r\u00e9cente parmi les livres \u00e9dit\u00e9s par Dargaud SELECT MAX ( annee ) FROM livre WHERE editeur LIKE 'Dargaud' ; Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une requ\u00eate SQL qui permet de r\u00e9cup\u00e9rer le nombre de livres parus en 2012. \u00c9crire une requ\u00eate SQL qui permet de r\u00e9cup\u00e9rer la date de retour la plus ancienne en la nommant 'retard_max' -- 1. SELECT COUNT ( * ) FROM livre WHERE annee = 2012 ; -- 2. SELECT MIN ( retour ) AS 'retard_max' FROM emprunt ; 3. Jointures \u2693\ufe0e Jusqu'\u00e0 pr\u00e9sent les requ\u00eates effectu\u00e9es sont relativement simples puisqu'elles ne concernent qu'une seule table \u00e0 la fois. Mais int\u00e9ressons-nous par exemple \u00e0 une requ\u00eate - pertinente - de savoir qui est en retard dans son emprunt. L'interrogation de la table emprunt permet de r\u00e9cup\u00e9rer les valeurs de l'attribut code_barre , mais ce n'est pas tr\u00e8s parlant pour un \u00eatre humain, le nom de la personne serait plus judicieux. Or ce nom se situe dans une autre table, la table usager ... Il faut donc croiser les donn\u00e9es situ\u00e9es dans deux tables diff\u00e9rentes. Cette manipulation de fusion de plusieurs tables se nomme une jointure et s'effectue \u00e0 l'aide du mot-cl\u00e9 JOIN ... ON ... . Jointure Exemple de jointure sur l'attribut commun *code_barre* SELECT * FROM usager JOIN emprunt ON usager . code_barre = emprunt . code_barre ; Remarques: On constate que la table renvoy\u00e9e par cette requ\u00eate contient autant de fois la ligne correspondant \u00e0 un usager que ce dernier a emprunt\u00e9 de ligne. De m\u00eame un usager n'ayant pas fait d'emprunt ne figure pas dans le r\u00e9sultat de la requ\u00eate. On doit pr\u00e9fixer les attributs de la table \u00e0 laquelle ils appartiennent. Il suffit maintenant d'ajouter un filtre sur la date de retour, et de n'afficher que le nom de l'usager, l'isbn et la date de retour. Sans alias Avec alias SELECT usager . nom , emprunt . isbn , emprunt . retour FROM usager JOIN emprunt ON usager . code_barre = emprunt . code_barre WHERE emprunt . retour < '2022-12-01' ; SELECT u . nom , e . isbn , e . retour FROM usager AS u JOIN emprunt AS e ON u . code_barre = e . code_barre WHERE e . retour < '2022-12-01' ; On peut \u00e9galement effectuer une jointure sur plus de deux tables, par exemple si on souhaite afficher le titre du livre emprunt\u00e9 plut\u00f4t que son isbn... On r\u00e9fl\u00e9chit d'abord... SELECT u . nom , l . titre , e . retour FROM usager AS u JOIN emprunt AS e ON u . code_barre = e . code_barre JOIN livre AS l ON l . isbn = e . isbn WHERE e . retour < '2022-12-01' ; Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire les requ\u00eates SQL suivantes: Le titre des livres emprunt\u00e9s. Le nom et le pr\u00e9nom de l'auteur du livre 1984 . Les titre des livres publi\u00e9s strictement avant Dune (penser d'abord \u00e0 \u00e9crire une requ\u00eate donnant l'ann\u00e9e de parution de Dune ). Les noms et pr\u00e9noms des auteurs des livres trouv\u00e9s \u00e0 la requ\u00eate pr\u00e9c\u00e9dente. M\u00eame requ\u00eate que pr\u00e9c\u00e9demment, sans doublon. Le nombre de r\u00e9sultats trouv\u00e9s \u00e0 la question pr\u00e9c\u00e9dente. -- 1. SELECT livre . titre FROM livre JOIN emprunt ON livre . isbn = emprunt . isbn ; -- 2. SELECT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . titre = '1984' ; -- 3. SELECT titre FROM livre WHERE annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 4. SELECT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 5. SELECT DISTINCT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 6. SELECT COUNT ( * ) FROM ( SELECT DISTINCT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' )) ; Exercice 5 \u00c9nonc\u00e9 Correction On consid\u00e8re les trois tables d\u00e9crites ci-dessous. Pour chaque requ\u00eate SQL suivantes, calculer son r\u00e9sultat (\u00e0 la main). SELECT * FROM x WHERE b > 3 ; SELECT DISTINCT e FROM z WHERE e > 10 AND e < 50 ; SELECT * FROM y WHERE c % 2 = 0 ORDER BY d ASC ; SELECT x . a , x . b FROM x JOIN z ON z . a = x . a WHERE z . e < 9 ; SELECT DISTINCT x . b , z . c FROM x JOIN z ON z . a = x . a ;","title":"T4.3 Langage SQL (partie 2)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/#t43-langage-sql-partie-2","text":"","title":"T4.3 Langage SQL (partie 2)"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/#433-la-manipulation-des-donnees-lmd-requetes-dinterrogation-avec-select","text":"SELECT est le mot-cl\u00e9 le plus important et le plus utilis\u00e9 en SQL : il permet de s\u00e9lectionner des lignes, des colonnes d'une ou plusieurs tables, mais aussi transformer des donn\u00e9es par l'utilisation de fonction ou encore r\u00e9aliser des calculs. Exemple-type Tous les exemples de ce chapitre sont \u00e0 tester \u00e0 partir de la base de donn\u00e9es livres.db issue de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie dans les sources du site, qui reprend (\u00e0 peu-pr\u00e8s) le sch\u00e9ma de la base biblioth\u00e8que \u00e9tudi\u00e9e aux chapitres pr\u00e9c\u00e9dents. Syntaxe g\u00e9n\u00e9rale SELECT colonnes ou \u00e9 l\u00e9ments d ' extraction FROM table ( s ) WHERE condition ( s ) - optionnel ORDER BY tri ( s ) - optionnel ;","title":"4.3.3 La manipulation des donn\u00e9es (LMD) : Requ\u00eates d'interrogation avec SELECT"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/#1-selection-et-projection","text":"S\u00e9lectionner des lignes Sans condition Avec une condition Avec des conditions Avec un tri Requ\u00eate approch\u00e9e On obtient alors l'int\u00e9gralit\u00e9 de la table. On utilise l'ast\u00e9risque * pour indiquer qu'on souhaite toutes les colonnes. S\u00e9lectionner tous les usagers SELECT * FROM usager ; On utilise la clause WHERE pour indiquer une condition sur la s\u00e9lection des lignes. S\u00e9lectionner les usagers vivant dans le 15e arrondissement de Paris SELECT * FROM usager WHERE cp = '75005' ; On peut utiliser des op\u00e9rateurs bool\u00e9ens dans l'\u00e9criture de la condition. S\u00e9lectionner les livres parus entre 2000 et 2005 SELECT * FROM livre WHERE annee >= 2000 AND annee <= 2005 ; On peut ajouter un tri sur les r\u00e9sultats, en pr\u00e9cisant l'attribut sur lequel s'effectue le tri et \u00e9ventuellement l'ordre de tri par les mots-cl\u00e9s ASC (par d\u00e9faut) ou DESC . S\u00e9lectionner les livres parus entre 2000 et 2005 et les trier par editeur SELECT * FROM livre WHERE annee >= 2000 AND annee <= 2005 ORDER BY editeur ; Si la condition de recherche porte sur une cha\u00eene de caract\u00e8res, l'op\u00e9rateur = peut ne pas \u00eatre appropri\u00e9. On utilise alors plut\u00f4t le mot-cl\u00e9 LIKE , avec une cha\u00eene de caract\u00e8re compos\u00e9e d'un motif utilisant des jokers % pour remplacer une cha\u00eene de caract\u00e8res quelconque. S\u00e9lectionner les lignes dont le titre contient la cha\u00eene `Ast\u00e9rix` SELECT * FROM livre WHERE titre LIKE '%Ast\u00e9rix%' ; Exercice 1 \u00c9nonc\u00e9 Correction Effectuer les requ\u00eates suivantes: S\u00e9lectionner les livres qui ne sont pas parus en 2008, class\u00e9s du plus r\u00e9cent au plus vieux. S\u00e9lectionner les usagers dont le pr\u00e9nom est JULIEN ou DAVID. S\u00e9lectionner les auteurs dont le pr\u00e9nom commence par un M. SELECT * FROM livre WHERE annee != 2008 ORDER BY annee DESC ; SELECT * FROM usager WHERE prenom = 'JULIEN' OR Prenom = 'DAVID' ; SELECT * FROM auteur WHERE prenom LIKE 'M%' ORDER BY prenom ; S\u00e9lectionner des colonnes (projection) Plut\u00f4t que de s\u00e9lectionner toutes les colonnes avec le joker * on peut pr\u00e9ciser quels attributs on souhaite afficher dans les r\u00e9sultats de la requ\u00eate. On nomme cette op\u00e9ration projection . Une colonne Plusieurs colonnes Gestion des doublons S\u00e9lectionner uniquement les titres des livres parus en 2000 SELECT titre FROM livre WHERE annee = 2000 ; S\u00e9lectionner les titres et l'ann\u00e9e de parution des livres parus avant 2000 SELECT titre , annee FROM livre WHERE annee < 2000 ; Si on s\u00e9lectionne la colonne (l'attribut) editeur de la table livre par la requ\u00eate suivante, on s'aper\u00e7oit qu'on obtient plusieurs fois les m\u00eames noms d'\u00e9diteur. SELECT editeur FROM livre ; Pour obtenir uniquement les valeurs diff\u00e9rentes de cette colonne, on utilise le mot-cl\u00e9 DISTINCT (le tri est facultatif, il est pr\u00e9sent ici pour bien visualiser l'absence des doublons): SELECT DISTINCT editeur FROM livre ORDER BY editeur ; Exercice 2 \u00c9nonc\u00e9 Correction Effectuer les requ\u00eates suivantes sur la table livre : S\u00e9lectionner les titres et les ISBN des livres parus \u00e0 partir de 1990. S\u00e9lectionner les ann\u00e9es (sans doublon) pour lesquelles un livre est paru chez Flammarion, tri\u00e9es dans l'ordre croissant. SELECT titre , isbn FROM livre WHERE annee >= 1990 ; SELECT DISTINCT annee FROM livre WHERE editeur = 'Flammarion' ORDER BY annee ;","title":"1. S\u00e9lection et projection"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/#2-agregation","text":"Une autre utilisation de la clause SELECT est d'appeler une fonction d'agr\u00e9gation , c'est-\u00e0-dire une fonction que l'on applique \u00e0 l'ensemble des valeurs d'une colonne et qui renvoie une table r\u00e9duite \u00e0 une cellule contenant le r\u00e9sultat du calcul. On peut par exemple compter le nombre de valeurs (mot-cl\u00e9 COUNT ), faire une somme ( SUM ), calculer une moyenne ( AVG ) ou encore trouver un minimum/maximum ( MIN , MAX ). Agr\u00e9gation COUNT SUM , AVG MIN , MAX Compter le nombre d'usagers SELECT COUNT ( * ) FROM usager ; Remarque: on peut utiliser un alias avec AS pour nommer le r\u00e9sultat: Avec utilisation d'un alias SELECT COUNT ( * ) AS total FROM usager ; Les fonctions SUM et AVG s'utilisent de la m\u00eame fa\u00e7on, ici un exemple (totalement d\u00e9nu\u00e9 de sens) pour illustrer AVG : Calculer l'ann\u00e9e moyenne de parution SELECT AVG ( annee ) FROM livre ; D\u00e9terminer l'ann\u00e9e de parution la plus r\u00e9cente parmi les livres \u00e9dit\u00e9s par Dargaud SELECT MAX ( annee ) FROM livre WHERE editeur LIKE 'Dargaud' ; Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une requ\u00eate SQL qui permet de r\u00e9cup\u00e9rer le nombre de livres parus en 2012. \u00c9crire une requ\u00eate SQL qui permet de r\u00e9cup\u00e9rer la date de retour la plus ancienne en la nommant 'retard_max' -- 1. SELECT COUNT ( * ) FROM livre WHERE annee = 2012 ; -- 2. SELECT MIN ( retour ) AS 'retard_max' FROM emprunt ;","title":"2. Agr\u00e9gation"},{"location":"T04_BasesDonnees/T4.3_SQL/T4.3_SQL2/#3-jointures","text":"Jusqu'\u00e0 pr\u00e9sent les requ\u00eates effectu\u00e9es sont relativement simples puisqu'elles ne concernent qu'une seule table \u00e0 la fois. Mais int\u00e9ressons-nous par exemple \u00e0 une requ\u00eate - pertinente - de savoir qui est en retard dans son emprunt. L'interrogation de la table emprunt permet de r\u00e9cup\u00e9rer les valeurs de l'attribut code_barre , mais ce n'est pas tr\u00e8s parlant pour un \u00eatre humain, le nom de la personne serait plus judicieux. Or ce nom se situe dans une autre table, la table usager ... Il faut donc croiser les donn\u00e9es situ\u00e9es dans deux tables diff\u00e9rentes. Cette manipulation de fusion de plusieurs tables se nomme une jointure et s'effectue \u00e0 l'aide du mot-cl\u00e9 JOIN ... ON ... . Jointure Exemple de jointure sur l'attribut commun *code_barre* SELECT * FROM usager JOIN emprunt ON usager . code_barre = emprunt . code_barre ; Remarques: On constate que la table renvoy\u00e9e par cette requ\u00eate contient autant de fois la ligne correspondant \u00e0 un usager que ce dernier a emprunt\u00e9 de ligne. De m\u00eame un usager n'ayant pas fait d'emprunt ne figure pas dans le r\u00e9sultat de la requ\u00eate. On doit pr\u00e9fixer les attributs de la table \u00e0 laquelle ils appartiennent. Il suffit maintenant d'ajouter un filtre sur la date de retour, et de n'afficher que le nom de l'usager, l'isbn et la date de retour. Sans alias Avec alias SELECT usager . nom , emprunt . isbn , emprunt . retour FROM usager JOIN emprunt ON usager . code_barre = emprunt . code_barre WHERE emprunt . retour < '2022-12-01' ; SELECT u . nom , e . isbn , e . retour FROM usager AS u JOIN emprunt AS e ON u . code_barre = e . code_barre WHERE e . retour < '2022-12-01' ; On peut \u00e9galement effectuer une jointure sur plus de deux tables, par exemple si on souhaite afficher le titre du livre emprunt\u00e9 plut\u00f4t que son isbn... On r\u00e9fl\u00e9chit d'abord... SELECT u . nom , l . titre , e . retour FROM usager AS u JOIN emprunt AS e ON u . code_barre = e . code_barre JOIN livre AS l ON l . isbn = e . isbn WHERE e . retour < '2022-12-01' ; Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire les requ\u00eates SQL suivantes: Le titre des livres emprunt\u00e9s. Le nom et le pr\u00e9nom de l'auteur du livre 1984 . Les titre des livres publi\u00e9s strictement avant Dune (penser d'abord \u00e0 \u00e9crire une requ\u00eate donnant l'ann\u00e9e de parution de Dune ). Les noms et pr\u00e9noms des auteurs des livres trouv\u00e9s \u00e0 la requ\u00eate pr\u00e9c\u00e9dente. M\u00eame requ\u00eate que pr\u00e9c\u00e9demment, sans doublon. Le nombre de r\u00e9sultats trouv\u00e9s \u00e0 la question pr\u00e9c\u00e9dente. -- 1. SELECT livre . titre FROM livre JOIN emprunt ON livre . isbn = emprunt . isbn ; -- 2. SELECT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . titre = '1984' ; -- 3. SELECT titre FROM livre WHERE annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 4. SELECT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 5. SELECT DISTINCT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' ) ; -- 6. SELECT COUNT ( * ) FROM ( SELECT DISTINCT auteur . nom , auteur . prenom FROM auteur JOIN auteur_de ON auteur . a_id = auteur_de . a_id JOIN livre ON livre . isbn = auteur_de . isbn WHERE livre . annee < ( SELECT annee FROM livre WHERE titre = 'Dune' )) ; Exercice 5 \u00c9nonc\u00e9 Correction On consid\u00e8re les trois tables d\u00e9crites ci-dessous. Pour chaque requ\u00eate SQL suivantes, calculer son r\u00e9sultat (\u00e0 la main). SELECT * FROM x WHERE b > 3 ; SELECT DISTINCT e FROM z WHERE e > 10 AND e < 50 ; SELECT * FROM y WHERE c % 2 = 0 ORDER BY d ASC ; SELECT x . a , x . b FROM x JOIN z ON z . a = x . a WHERE z . e < 9 ; SELECT DISTINCT x . b , z . c FROM x JOIN z ON z . a = x . a ;","title":"3. Jointures"},{"location":"T04_BasesDonnees/TP_Python_SQL/Python_SQL/","text":"TP Python et SQL \u2693\ufe0e Dans ce TP, nous allons voir comment utiliser Python pour cr\u00e9er une base de donn\u00e9es, cr\u00e9er des tables et effectuer des requ\u00eates en SQL sur cette base de donn\u00e9es. Ex\u00e9cuter le code suivant et contr\u00f4ler en m\u00eame temps avec DB Browser . Mod\u00e8le-type d'un script Python-SQL Module sqlite3 Connexion \u00e0 la base de donn\u00e9es Curseur Requ\u00eates Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () La ligne 4 permet d'ouvrir une base de donn\u00e9es, ou d'en cr\u00e9er une si le fichier .db n'existe pas, et de cr\u00e9er une connexion \u00e0 cette base de donn\u00e9es. La ligne 39 met fin \u00e0 cette connexion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () On cr\u00e9e ensuite ligne 7 un objet de type cursor qui va permettre d'envoyer des requ\u00eates sur la base donn\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Requ\u00eate simple Requ\u00eate multiple R\u00e9cup\u00e9rer des r\u00e9sultats d'une requ\u00eate SELECT La m\u00e9thode execute permet d'effectuer une requ\u00eate, que l'on passe en argument sous forme d'une cha\u00eene de caract\u00e8res. Si on souhaite l'\u00e9crire sur plusieurs lignes, on l'\u00e9crit entre triples double-quotes . \u00c0 noter l'option IF NOT EXISTS qui permet de ne pas \u00e9craser une table d\u00e9j\u00e0 existante. La m\u00e9thode executemany permet d'effectuer plusieurs requ\u00eates, une par \u00e9l\u00e9ment d'une liste pass\u00e9e en argument. On utilise des placeholders ? pour indiquer o\u00f9 remplacer par les valeurs des \u00e9l\u00e9ments de la liste. On stocke la table des r\u00e9sultats d'une requ\u00eate SELECT dans une variable, sur laquelle on peut ensuite it\u00e9rer: fetchone renvoie la premi\u00e8re ligne, et passe \u00e0 la suivante. fetchall renvoie l'ensemble des lignes, sous forme d'une liste. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () On valide ligne 36 les requ\u00eates pour ex\u00e9cution sur la base de donn\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Exercice \u00c9nonc\u00e9 Correction \u00c9crire un programme qui cr\u00e9e une table devoir (nom String , note Int ) et qui demande ensuite en boucle un nom et une note en les ajoutant \u00e0 la table. Le programme stoppe d\u00e8s qu'on entre comme nom q ou Q . Am\u00e9liorer le programme pr\u00e9c\u00e9dent pour permettre de rentrer des notes ou des consulter des notes. import sqlite3 def insertion (): go = True while go : nom = input ( 'Nom ? ' ) if nom . lower () == 'q' : go = False else : note = input ( 'Note ? ' ) c . execute ( \"INSERT INTO devoir VALUES (?, ?);\" , ( nom , note )) def consultation (): go = True while go : nom = input ( 'Nom ? ' ) if nom . lower () == 'q' : go = False else : rq = c . execute ( \"SELECT note FROM devoir WHERE nom = ?;\" , [ nom ]) note = rq . fetchone () if note is None : print ( \"\u00c9l\u00e8ve inconnu\" ) else : print ( \"Note : \" , note [ 0 ]) #Connexion connexion = sqlite3 . connect ( 'devoir.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS devoir( nom TEXT, note INTEGER); \"\"\" ) go = True while go : choix = input ( \"Menu \\n 1. Saisir des notes \\n 2. Consulter des notes \\n 3. Quitter \\n Votre choix: \" ) if choix == '1' : insertion () elif choix == '2' : consultation () else : go = False # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Mini-Projet \u00c9nonc\u00e9 Proposition de correction Dans ce mini-projet, vous devez \u00e9crire un syst\u00e8me d'authentification par login/mot de passe \u00e0 un service qui permet de stocker une phrase secr\u00e8te. Comme pr\u00e9c\u00e9demment le menu doit contenir trois choix: login : s'authentifier puis afficher la phrase secr\u00e8te. Proposer de changer cette phrase. register : s'enregistrer puis saisir la phrase secr\u00e8te \u00e0 stocker. quit : pour ... quitter le programme. Remarques: les donn\u00e9es doivent bien entendu \u00eatre stock\u00e9es dans une base de donn\u00e9es. on ne doit pas pouvoir choisir un login d\u00e9j\u00e0 utilis\u00e9. les mots de passe doivent \u00eatre hach\u00e9s. Voir ici pour le principe et ici pour la fonction de hachage \u00e0 utiliser. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import sqlite3 import hashlib def hachage ( chaine : str ) -> str : ''' renvoie le condens\u00e9 de chaine en utilisant la fonction de hachage md5 du module hashlib. ''' return hashlib . md5 ( chaine . encode ()) . hexdigest () def register (): go = True while go : nom = input ( \"Choix de l'identifiant : \" ) rq = c . execute ( \"SELECT * FROM users WHERE pseudo = ?;\" , [ nom ]) resultat = rq . fetchone () if resultat is None : mdp = input ( \"Choix du mdp : \" ) ps = input ( \"Saisissez votre phrase secr\u00e8te : \" ) c . execute ( \"INSERT INTO users VALUES (?, ?, ?);\" , [ nom , hachage ( mdp ), ps ]) go = False else : print ( \"Identifiant d\u00e9j\u00e0 attribu\u00e9. Veuillez recommencer.\" ) def login (): nom = input ( 'Identifiant ? ' ) rq = c . execute ( \"SELECT * FROM users WHERE pseudo = ?;\" , [ nom ]) resultat = rq . fetchone () if resultat is None : print ( \"Identifiant inconnu\" ) else : mdp = input ( 'Mot de passe ? ' ) mdp_hash = hachage ( mdp ) if mdp_hash == resultat [ 1 ]: print ( 'Authentification r\u00e9ussie' ) menu_login ( nom ) else : print ( 'Mot de passe erron\u00e9' ) def menu_login ( user ): go = True while go : print ( 15 * \"-\" + \" \\n 1. Consulter la phrase secr\u00e8te \\n 2. Modifier la phrase secr\u00e8te \\n 3. Quitter \\n \" + 15 * \"-\" ) choix = input ( \"Votre choix: \" ) if choix == '1' : consulter ( user ) elif choix == '2' : modifier ( user ) else : go = False def consulter ( user ): rq = c . execute ( \"SELECT content FROM users WHERE pseudo = ?;\" , [ user ]) print ( f \"Phrase secr\u00e8te: { rq . fetchone ()[ 0 ] } \" ) def modifier ( user ): ps = input ( \"Saisissez votre nouvelle phrase secr\u00e8te : \" ) c . execute ( \"UPDATE users SET content = ? WHERE pseudo = ?;\" , [ ps , user ]) print ( \"Modification effectu\u00e9e\" ) #Connexion connexion = sqlite3 . connect ( 'miniprojet.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS users( pseudo TEXT PRIMARY KEY, mdp INTEGER, content TEXT); \"\"\" ) go = True while go : print ( 15 * \"-\" + \" \\n Menu \\n 1. login \\n 2. register \\n 3. quit \\n \" + 15 * \"-\" ) choix = input ( \"Votre choix: \" ) if choix == '1' : login () elif choix == '2' : register () else : go = False # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close ()","title":"TP Python et SQL"},{"location":"T04_BasesDonnees/TP_Python_SQL/Python_SQL/#tp-python-et-sql","text":"Dans ce TP, nous allons voir comment utiliser Python pour cr\u00e9er une base de donn\u00e9es, cr\u00e9er des tables et effectuer des requ\u00eates en SQL sur cette base de donn\u00e9es. Ex\u00e9cuter le code suivant et contr\u00f4ler en m\u00eame temps avec DB Browser . Mod\u00e8le-type d'un script Python-SQL Module sqlite3 Connexion \u00e0 la base de donn\u00e9es Curseur Requ\u00eates Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () La ligne 4 permet d'ouvrir une base de donn\u00e9es, ou d'en cr\u00e9er une si le fichier .db n'existe pas, et de cr\u00e9er une connexion \u00e0 cette base de donn\u00e9es. La ligne 39 met fin \u00e0 cette connexion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () On cr\u00e9e ensuite ligne 7 un objet de type cursor qui va permettre d'envoyer des requ\u00eates sur la base donn\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Requ\u00eate simple Requ\u00eate multiple R\u00e9cup\u00e9rer des r\u00e9sultats d'une requ\u00eate SELECT La m\u00e9thode execute permet d'effectuer une requ\u00eate, que l'on passe en argument sous forme d'une cha\u00eene de caract\u00e8res. Si on souhaite l'\u00e9crire sur plusieurs lignes, on l'\u00e9crit entre triples double-quotes . \u00c0 noter l'option IF NOT EXISTS qui permet de ne pas \u00e9craser une table d\u00e9j\u00e0 existante. La m\u00e9thode executemany permet d'effectuer plusieurs requ\u00eates, une par \u00e9l\u00e9ment d'une liste pass\u00e9e en argument. On utilise des placeholders ? pour indiquer o\u00f9 remplacer par les valeurs des \u00e9l\u00e9ments de la liste. On stocke la table des r\u00e9sultats d'une requ\u00eate SELECT dans une variable, sur laquelle on peut ensuite it\u00e9rer: fetchone renvoie la premi\u00e8re ligne, et passe \u00e0 la suivante. fetchall renvoie l'ensemble des lignes, sous forme d'une liste. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () On valide ligne 36 les requ\u00eates pour ex\u00e9cution sur la base de donn\u00e9es. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS prof( id INTEGER, nom TEXT, mati\u00e8re TEXT); \"\"\" ) #Insertion de valeurs c . execute ( \"INSERT INTO prof VALUES (1, 'Gouygou', 'NSI');\" ) autre_profs = [( 2 , 'Morel' , 'Maths' ), ( 3 , 'Philippe' , 'Maths' ), ( 4 , 'Atingdobe' , 'Philosophie' ), ( 5 , 'Renault' , 'Arts Plastiques' ), ( 6 , 'Sartorel' , 'Histoire-G\u00e9ographie' ), ( 7 , 'Touchais' , 'Anglais' ), ( 8 , 'Gouygou' , 'Maths' )] c . executemany ( \"INSERT INTO prof VALUES (?, ?, ?)\" , autre_profs ) requete = c . execute ( \"SELECT id, nom FROM prof WHERE mati\u00e8re = 'Maths';\" ) print ( requete . fetchone ()) print ( requete . fetchall ()) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Exercice \u00c9nonc\u00e9 Correction \u00c9crire un programme qui cr\u00e9e une table devoir (nom String , note Int ) et qui demande ensuite en boucle un nom et une note en les ajoutant \u00e0 la table. Le programme stoppe d\u00e8s qu'on entre comme nom q ou Q . Am\u00e9liorer le programme pr\u00e9c\u00e9dent pour permettre de rentrer des notes ou des consulter des notes. import sqlite3 def insertion (): go = True while go : nom = input ( 'Nom ? ' ) if nom . lower () == 'q' : go = False else : note = input ( 'Note ? ' ) c . execute ( \"INSERT INTO devoir VALUES (?, ?);\" , ( nom , note )) def consultation (): go = True while go : nom = input ( 'Nom ? ' ) if nom . lower () == 'q' : go = False else : rq = c . execute ( \"SELECT note FROM devoir WHERE nom = ?;\" , [ nom ]) note = rq . fetchone () if note is None : print ( \"\u00c9l\u00e8ve inconnu\" ) else : print ( \"Note : \" , note [ 0 ]) #Connexion connexion = sqlite3 . connect ( 'devoir.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS devoir( nom TEXT, note INTEGER); \"\"\" ) go = True while go : choix = input ( \"Menu \\n 1. Saisir des notes \\n 2. Consulter des notes \\n 3. Quitter \\n Votre choix: \" ) if choix == '1' : insertion () elif choix == '2' : consultation () else : go = False # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Mini-Projet \u00c9nonc\u00e9 Proposition de correction Dans ce mini-projet, vous devez \u00e9crire un syst\u00e8me d'authentification par login/mot de passe \u00e0 un service qui permet de stocker une phrase secr\u00e8te. Comme pr\u00e9c\u00e9demment le menu doit contenir trois choix: login : s'authentifier puis afficher la phrase secr\u00e8te. Proposer de changer cette phrase. register : s'enregistrer puis saisir la phrase secr\u00e8te \u00e0 stocker. quit : pour ... quitter le programme. Remarques: les donn\u00e9es doivent bien entendu \u00eatre stock\u00e9es dans une base de donn\u00e9es. on ne doit pas pouvoir choisir un login d\u00e9j\u00e0 utilis\u00e9. les mots de passe doivent \u00eatre hach\u00e9s. Voir ici pour le principe et ici pour la fonction de hachage \u00e0 utiliser. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import sqlite3 import hashlib def hachage ( chaine : str ) -> str : ''' renvoie le condens\u00e9 de chaine en utilisant la fonction de hachage md5 du module hashlib. ''' return hashlib . md5 ( chaine . encode ()) . hexdigest () def register (): go = True while go : nom = input ( \"Choix de l'identifiant : \" ) rq = c . execute ( \"SELECT * FROM users WHERE pseudo = ?;\" , [ nom ]) resultat = rq . fetchone () if resultat is None : mdp = input ( \"Choix du mdp : \" ) ps = input ( \"Saisissez votre phrase secr\u00e8te : \" ) c . execute ( \"INSERT INTO users VALUES (?, ?, ?);\" , [ nom , hachage ( mdp ), ps ]) go = False else : print ( \"Identifiant d\u00e9j\u00e0 attribu\u00e9. Veuillez recommencer.\" ) def login (): nom = input ( 'Identifiant ? ' ) rq = c . execute ( \"SELECT * FROM users WHERE pseudo = ?;\" , [ nom ]) resultat = rq . fetchone () if resultat is None : print ( \"Identifiant inconnu\" ) else : mdp = input ( 'Mot de passe ? ' ) mdp_hash = hachage ( mdp ) if mdp_hash == resultat [ 1 ]: print ( 'Authentification r\u00e9ussie' ) menu_login ( nom ) else : print ( 'Mot de passe erron\u00e9' ) def menu_login ( user ): go = True while go : print ( 15 * \"-\" + \" \\n 1. Consulter la phrase secr\u00e8te \\n 2. Modifier la phrase secr\u00e8te \\n 3. Quitter \\n \" + 15 * \"-\" ) choix = input ( \"Votre choix: \" ) if choix == '1' : consulter ( user ) elif choix == '2' : modifier ( user ) else : go = False def consulter ( user ): rq = c . execute ( \"SELECT content FROM users WHERE pseudo = ?;\" , [ user ]) print ( f \"Phrase secr\u00e8te: { rq . fetchone ()[ 0 ] } \" ) def modifier ( user ): ps = input ( \"Saisissez votre nouvelle phrase secr\u00e8te : \" ) c . execute ( \"UPDATE users SET content = ? WHERE pseudo = ?;\" , [ ps , user ]) print ( \"Modification effectu\u00e9e\" ) #Connexion connexion = sqlite3 . connect ( 'miniprojet.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation d'une table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS users( pseudo TEXT PRIMARY KEY, mdp INTEGER, content TEXT); \"\"\" ) go = True while go : print ( 15 * \"-\" + \" \\n Menu \\n 1. login \\n 2. register \\n 3. quit \\n \" + 15 * \"-\" ) choix = input ( \"Votre choix: \" ) if choix == '1' : login () elif choix == '2' : register () else : go = False # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close ()","title":"TP Python et SQL"},{"location":"T05_ArchiMaterielle/accueil/","text":"Th\u00e8me 5 : Architecture mat\u00e9rielle \u2693\ufe0e","title":"Th\u00e8me 5 : Architecture mat\u00e9rielle"},{"location":"T05_ArchiMaterielle/accueil/#theme-5-architecture-materielle","text":"","title":"Th\u00e8me 5 : Architecture mat\u00e9rielle"},{"location":"T05_ArchiMaterielle/T5.1_Puce/T5.1_Puce/","text":"T5.1 Syst\u00e8mes sur puce \u2693\ufe0e","title":"T5.1 Syst\u00e8mes sur puce"},{"location":"T05_ArchiMaterielle/T5.1_Puce/T5.1_Puce/#t51-systemes-sur-puce","text":"","title":"T5.1 Syst\u00e8mes sur puce"},{"location":"T06_BAC/bac/","text":"BAC NSI \u2693\ufe0e \u00c9preuve \u00e9crite \u2693\ufe0e L'\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9 NSI dure 3h30. Elle comporte trois exercices not\u00e9s chacun sur 4 points, pour un total donc de 12 points. Les exercices portent sur les chapitres du programme signal\u00e9s par \u2192 BAC sur la page d'accueil. \u00c9preuve pratique \u2693\ufe0e L'\u00e9preuve pratique de sp\u00e9cialit\u00e9 NSI dure 1h. Elle comporte deux exercices de programmation not\u00e9s chacun sur 4 points, pour un total donc de 8 points. Vous pouvez retrouver en libre acc\u00e8s tous les sujets de la session 2022 \u00e0 l'\u00e9preuve pratique de NSI: https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi . Ou bien tous les t\u00e9l\u00e9charger en un seul fichier pdf (718 ko). Grand Oral \u2693\ufe0e Vous devez pr\u00e9parer deux sujets, dont au moins un a un rapport avec le programme de NSI. Ce sujet peut \u00eatre crois\u00e9 avec l'autre sp\u00e9cialit\u00e9. L'oral dure 20 minutes (5 minutes d'expos\u00e9 et 15 minutes d'\u00e9changes avec le jury).","title":"BAC NSI"},{"location":"T06_BAC/bac/#bac-nsi","text":"","title":"BAC NSI"},{"location":"T06_BAC/bac/#epreuve-ecrite","text":"L'\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9 NSI dure 3h30. Elle comporte trois exercices not\u00e9s chacun sur 4 points, pour un total donc de 12 points. Les exercices portent sur les chapitres du programme signal\u00e9s par \u2192 BAC sur la page d'accueil.","title":"\u00c9preuve \u00e9crite"},{"location":"T06_BAC/bac/#epreuve-pratique","text":"L'\u00e9preuve pratique de sp\u00e9cialit\u00e9 NSI dure 1h. Elle comporte deux exercices de programmation not\u00e9s chacun sur 4 points, pour un total donc de 8 points. Vous pouvez retrouver en libre acc\u00e8s tous les sujets de la session 2022 \u00e0 l'\u00e9preuve pratique de NSI: https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi . Ou bien tous les t\u00e9l\u00e9charger en un seul fichier pdf (718 ko).","title":"\u00c9preuve pratique"},{"location":"T06_BAC/bac/#grand-oral","text":"Vous devez pr\u00e9parer deux sujets, dont au moins un a un rapport avec le programme de NSI. Ce sujet peut \u00eatre crois\u00e9 avec l'autre sp\u00e9cialit\u00e9. L'oral dure 20 minutes (5 minutes d'expos\u00e9 et 15 minutes d'\u00e9changes avec le jury).","title":"Grand Oral"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/","text":"DL 0001 : le masque jetable \u2693\ufe0e Histoire de l'informatique L'algorithme de cryptographie du masque jetable est le seul qui offre une s\u00e9curit\u00e9 th\u00e9orique absolue. Cela a \u00e9t\u00e9 prouv\u00e9 en 1949 par Claude Shannon . Cependant pour que cet algorithme soit parfaitement s\u00fbr, il faut respecter 3 r\u00e8gles: la cl\u00e9 doit \u00eatre aussi longue que le message \u00e0 chiffrer; la cl\u00e9 doit \u00eatre g\u00e9n\u00e9r\u00e9e de fa\u00e7on al\u00e9atoire ; la cl\u00e9 doit \u00eatre \u00e0 usage unique . Ces r\u00e8gles emp\u00eachent un usage pratique de cette m\u00e9thode, car il est tr\u00e8s compliqu\u00e9 de communiquer les cl\u00e9s. Certains gouvernements l'utilisent parfois, en faisant passer les cl\u00e9s par valise diplomatique . Pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs. Introduction \u2693\ufe0e Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : x y x XOR y F F F F V V V F V V V F Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b . Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Exemple: On souhaite chiffrer le message 'nsi' avec la cl\u00e9 'BAC' . On convertit chaque caract\u00e8re en binaire: n s i Unicode (d\u00e9cimal) 110 115 105 Unicode (hexad\u00e9cimal) 6E 73 69 Binaire 0b 0110 1110 0b 0111 0011 0b 0110 1001 B A C Unicode (d\u00e9cimal) 66 65 67 Unicode (hexad\u00e9cimal) 42 41 43 Binaire 0b 0100 0010 0b 0100 0001 0b 0100 0011 On obtient donc en binaire : 'nsi' \u2192 0b 0110 1110 0111 0011 0110 1001 et 'BAC' \u2192 0b 0100 0010 0100 0001 0100 0011 . On effectue un XOR bit \u00e0 bit : 'nsi' XOR 'BAC' \u2192 0b 0010 1100 0011 0010 0010 1010 On r\u00e9cup\u00e8re les codes Unicode des 3 caract\u00e8res: 2C 32 2A , donc le message chiffr\u00e9 est : ',2*' \u00c9nonc\u00e9 \u2693\ufe0e Partie 1 \u2693\ufe0e Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s sur 8 bits: d\u00e9terminer quels sont ces caract\u00e8res. Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (x XOR y) XOR y . Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Le v\u00e9rifier. Partie 2 - Python \u2693\ufe0e En Python, l'op\u00e9rateur XOR est ^ . On peut faire un XOR directement sur deux nombres entiers, le XOR bit \u00e0 bit se fait implicitement: >>> 110 ^ 66 44 >>> hex ( 44 ) '0x2c' Cet exemple montre que le ou exclusif sur 'n' et 'B' donne bien ',' (cf. introduction). Les fonctions Python permettant d'obtenir le code Unicode d'un caract\u00e8re et r\u00e9ciproquement sont ord et chr : >>> ord ( 'n' ) 110 >>> chr ( 66 ) 'B' \u00c9crire une fonction xor qui prend deux caract\u00e8res en param\u00e8tre et renvoie le caract\u00e8re correspondant au ou exclusif sur leurs codes Unicode. \u00c9crire une fonction masque_jetable qui correspond \u00e0 la sp\u00e9cification ci-dessous: 1 2 3 4 5 6 7 8 9 def masque_jetable ( message : str , cle : str ) -> str : ''' renvoie la cha\u00eene chiffr\u00e9e par la m\u00e9thode du masque jetable. message: cha\u00eene \u00e0 chiffrer cle: cl\u00e9 de chiffrement Si la longueur de cle est inf\u00e9rieure \u00e0 celle de message, on revient au d\u00e9but de cle. ''' pass Partie 3 - Bonus \u2693\ufe0e R\u00e9soudre le pyd\u00e9fi suivant : La cl\u00e9 endommag\u00e9e","title":"DL 0001 : le masque jetable"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#dl-0001-le-masque-jetable","text":"Histoire de l'informatique L'algorithme de cryptographie du masque jetable est le seul qui offre une s\u00e9curit\u00e9 th\u00e9orique absolue. Cela a \u00e9t\u00e9 prouv\u00e9 en 1949 par Claude Shannon . Cependant pour que cet algorithme soit parfaitement s\u00fbr, il faut respecter 3 r\u00e8gles: la cl\u00e9 doit \u00eatre aussi longue que le message \u00e0 chiffrer; la cl\u00e9 doit \u00eatre g\u00e9n\u00e9r\u00e9e de fa\u00e7on al\u00e9atoire ; la cl\u00e9 doit \u00eatre \u00e0 usage unique . Ces r\u00e8gles emp\u00eachent un usage pratique de cette m\u00e9thode, car il est tr\u00e8s compliqu\u00e9 de communiquer les cl\u00e9s. Certains gouvernements l'utilisent parfois, en faisant passer les cl\u00e9s par valise diplomatique . Pour une meilleure lisibilit\u00e9, des espaces sont plac\u00e9es dans les \u00e9critures binaires des nombres. Il ne faut pas les prendre en compte dans les calculs.","title":"DL 0001 : le masque jetable"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#introduction","text":"Pour chiffrer un message, une m\u00e9thode, dite du masque jetable, consiste \u00e0 le combiner avec une cha\u00eene de caract\u00e8res de longueur comparable. Une impl\u00e9mentation possible utilise l\u2019op\u00e9rateur XOR (ou exclusif) dont voici la table de v\u00e9rit\u00e9 : x y x XOR y F F F F V V V F V V V F Dans la suite, les nombres \u00e9crits en binaire seront pr\u00e9c\u00e9d\u00e9s du pr\u00e9fixe 0b . Pour chiffrer un message, on convertit chacun de ses caract\u00e8res en binaire (\u00e0 l\u2019aide du format Unicode), et on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9. On fournit pour cela la table ci-dessous qui associe \u00e0 l\u2019\u00e9criture hexad\u00e9cimale d\u2019un octet le caract\u00e8re correspondant (figure 2). Exemple de lecture : le caract\u00e8re correspondant \u00e0 l\u2019octet cod\u00e9 4A en hexad\u00e9cimal est la lettre J. Exemple: On souhaite chiffrer le message 'nsi' avec la cl\u00e9 'BAC' . On convertit chaque caract\u00e8re en binaire: n s i Unicode (d\u00e9cimal) 110 115 105 Unicode (hexad\u00e9cimal) 6E 73 69 Binaire 0b 0110 1110 0b 0111 0011 0b 0110 1001 B A C Unicode (d\u00e9cimal) 66 65 67 Unicode (hexad\u00e9cimal) 42 41 43 Binaire 0b 0100 0010 0b 0100 0001 0b 0100 0011 On obtient donc en binaire : 'nsi' \u2192 0b 0110 1110 0111 0011 0110 1001 et 'BAC' \u2192 0b 0100 0010 0100 0001 0100 0011 . On effectue un XOR bit \u00e0 bit : 'nsi' XOR 'BAC' \u2192 0b 0010 1100 0011 0010 0010 1010 On r\u00e9cup\u00e8re les codes Unicode des 3 caract\u00e8res: 2C 32 2A , donc le message chiffr\u00e9 est : ',2*'","title":"Introduction"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#enonce","text":"","title":"\u00c9nonc\u00e9"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#partie-1","text":"Apr\u00e8s conversion en binaire, et avant que l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 n\u2019ait \u00e9t\u00e9 effectu\u00e9e, Alice obtient le message suivant : m = 0b 0110 0011 0100 0110 Le message m correspond \u00e0 deux caract\u00e8res cod\u00e9s sur 8 bits: d\u00e9terminer quels sont ces caract\u00e8res. Pour chiffrer le message d\u2019Alice, on r\u00e9alise l\u2019op\u00e9ration XOR bit \u00e0 bit avec la cl\u00e9 suivante : k = 0b 1110 1110 1111 0000 Donner l\u2019\u00e9criture binaire du message obtenu. Dresser la table de v\u00e9rit\u00e9 de l\u2019expression bool\u00e9enne suivante : (x XOR y) XOR y . Bob conna\u00eet la cha\u00eene de caract\u00e8res utilis\u00e9e par Alice pour chiffrer le message. Quelle op\u00e9ration doit-il r\u00e9aliser pour d\u00e9chiffrer son message ? Le v\u00e9rifier.","title":"Partie 1"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#partie-2-python","text":"En Python, l'op\u00e9rateur XOR est ^ . On peut faire un XOR directement sur deux nombres entiers, le XOR bit \u00e0 bit se fait implicitement: >>> 110 ^ 66 44 >>> hex ( 44 ) '0x2c' Cet exemple montre que le ou exclusif sur 'n' et 'B' donne bien ',' (cf. introduction). Les fonctions Python permettant d'obtenir le code Unicode d'un caract\u00e8re et r\u00e9ciproquement sont ord et chr : >>> ord ( 'n' ) 110 >>> chr ( 66 ) 'B' \u00c9crire une fonction xor qui prend deux caract\u00e8res en param\u00e8tre et renvoie le caract\u00e8re correspondant au ou exclusif sur leurs codes Unicode. \u00c9crire une fonction masque_jetable qui correspond \u00e0 la sp\u00e9cification ci-dessous: 1 2 3 4 5 6 7 8 9 def masque_jetable ( message : str , cle : str ) -> str : ''' renvoie la cha\u00eene chiffr\u00e9e par la m\u00e9thode du masque jetable. message: cha\u00eene \u00e0 chiffrer cle: cl\u00e9 de chiffrement Si la longueur de cle est inf\u00e9rieure \u00e0 celle de message, on revient au d\u00e9but de cle. ''' pass","title":"Partie 2 - Python"},{"location":"T07_Evaluations/Devoirs_Libres/DL1/#partie-3-bonus","text":"R\u00e9soudre le pyd\u00e9fi suivant : La cl\u00e9 endommag\u00e9e","title":"Partie 3 - Bonus"},{"location":"T07_Evaluations/Devoirs_Libres/DL2/","text":"DL 0010 : Travail sur les tableaux/listes (rappels) \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction \u00c0 rendre sur Capytale . \u00c9crire une fonction maximum qui prend en param\u00e8tre un tableau (type list ) d'entiers et qui renvoie le plus grand \u00e9l\u00e9ment du tableau). Si le tableau est vide, la fonction doit renvoyer None . Exemples >>> maximum ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ]) 42 >>> maximum ([ 4 , 4 , 4 ]) 4 >>> maximum ([]) None On peut parcourir le tableau sur ses \u00e9l\u00e9ments: def maximum ( tab : list ) -> int : if tab == []: return None maxi = tab [ 0 ] for elt in tab : # parcours de liste sur les \u00e9l\u00e9ments if elt > maxi : maxi = elt return maxi Ou bien sur les indices: def maximum ( tab : list ) -> int : if tab == []: return None maxi = tab [ 0 ] for i in range ( len ( tab )): # parcours de liste sur les indices if tab [ i ] > maxi : maxi = tab [ i ] return maxi Exercice 2 \u00c9nonc\u00e9 Correction \u00c0 rendre sur Capytale \u00c9crire une fonction indice qui prend en param\u00e8tre un tableau (type list ) d'entiers et un entier, et qui renvoie l'indice de la premi\u00e8re occurence de l'entier dans le tableau. Si l'entier n'appartient pas \u00e0 la liste, la fonction doit renvoyer None . Exemples >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 42 ) 4 >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 8 ) 2 >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 5 ) None def indice ( tab : list , n : int ) -> int : for i in range ( len ( tab )): if tab [ i ] == n : return i return None","title":"DL 0010 : Travail sur les tableaux/listes (rappels)"},{"location":"T07_Evaluations/Devoirs_Libres/DL2/#dl-0010-travail-sur-les-tableauxlistes-rappels","text":"Exercice 1 \u00c9nonc\u00e9 Correction \u00c0 rendre sur Capytale . \u00c9crire une fonction maximum qui prend en param\u00e8tre un tableau (type list ) d'entiers et qui renvoie le plus grand \u00e9l\u00e9ment du tableau). Si le tableau est vide, la fonction doit renvoyer None . Exemples >>> maximum ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ]) 42 >>> maximum ([ 4 , 4 , 4 ]) 4 >>> maximum ([]) None On peut parcourir le tableau sur ses \u00e9l\u00e9ments: def maximum ( tab : list ) -> int : if tab == []: return None maxi = tab [ 0 ] for elt in tab : # parcours de liste sur les \u00e9l\u00e9ments if elt > maxi : maxi = elt return maxi Ou bien sur les indices: def maximum ( tab : list ) -> int : if tab == []: return None maxi = tab [ 0 ] for i in range ( len ( tab )): # parcours de liste sur les indices if tab [ i ] > maxi : maxi = tab [ i ] return maxi Exercice 2 \u00c9nonc\u00e9 Correction \u00c0 rendre sur Capytale \u00c9crire une fonction indice qui prend en param\u00e8tre un tableau (type list ) d'entiers et un entier, et qui renvoie l'indice de la premi\u00e8re occurence de l'entier dans le tableau. Si l'entier n'appartient pas \u00e0 la liste, la fonction doit renvoyer None . Exemples >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 42 ) 4 >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 8 ) 2 >>> indice ([ 2 , 1 , 8 , 0 , 42 , 8 , 12 ], 5 ) None def indice ( tab : list , n : int ) -> int : for i in range ( len ( tab )): if tab [ i ] == n : return i return None","title":"DL 0010 : Travail sur les tableaux/listes (rappels)"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/","text":"DL 0011 \u2693\ufe0e Exercice 1 (rappel sur les listes en compr\u00e9hension) \u2693\ufe0e (Re)Lire le cours de Premi\u00e8re sur les listes en compr\u00e9hension . D\u00e9finir chacune des listes suivantes en compr\u00e9hension . a) Liste des entiers pairs entre 0 et 100 liste_pairs = [ p for p in range ( 0 , 101 , 2 )] b) Liste des \u00e9lements de la liste tab dont les indices sont compris entre 2 (inclus) et 10 (exclus) tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_2_10 = [ tab [ i ] for i in range ( 2 , 10 )] c) Liste des \u00e9lements de la liste tab dont les indices sont impairs tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_impairs = [ tab [ i ] for i in range ( len ( tab )) if i % 2 == 1 ] d) Liste des \u00e9lements de la liste tab qui sont divisibles par 7 tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_div_7 = [ t for t in tab if t % 7 == 0 ] Exercice 2 (Sujet BNS 2022 - n\u00b028, ex 1) \u2693\ufe0e \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab : list ) -> float : somme = 0 for t in tab : somme += t return t / len ( tab ) Exercice 3 (Sujet BNS 2022 - n\u00b028, ex 2) \u2693\ufe0e On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. Exemples: >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' Compl\u00e9ter le code ci-dessous. N'oubliez pas de convertir vos entiers en cha\u00eenes de caract\u00e8res avec la fonction str() . \u00c9nonc\u00e9 Correction 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while ... : bin_a = ... + bin_a a = ... return bin_a 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Exercice 4 \u2693\ufe0e Proposer une version r\u00e9cursive de la fonction dec_to_bin pr\u00e9c\u00e9dente. 1 2 3 4 5 def dec_to_bin_rec ( n ): if n // 2 == 0 : return str ( n % 2 ) else : return bin_rec ( n // 2 ) + str ( n % 2 )","title":"DL 0011"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/#dl-0011","text":"","title":"DL 0011"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/#exercice-1-rappel-sur-les-listes-en-comprehension","text":"(Re)Lire le cours de Premi\u00e8re sur les listes en compr\u00e9hension . D\u00e9finir chacune des listes suivantes en compr\u00e9hension . a) Liste des entiers pairs entre 0 et 100 liste_pairs = [ p for p in range ( 0 , 101 , 2 )] b) Liste des \u00e9lements de la liste tab dont les indices sont compris entre 2 (inclus) et 10 (exclus) tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_2_10 = [ tab [ i ] for i in range ( 2 , 10 )] c) Liste des \u00e9lements de la liste tab dont les indices sont impairs tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_impairs = [ tab [ i ] for i in range ( len ( tab )) if i % 2 == 1 ] d) Liste des \u00e9lements de la liste tab qui sont divisibles par 7 tab = [ 3 , - 1 , 7 , 0 , 8 , - 5 , 23 , 12 , - 42 , 1001 , 78 , - 98 , 72 , 50 ] liste_div_7 = [ t for t in tab if t % 7 == 0 ]","title":"Exercice 1 (rappel sur les listes en compr\u00e9hension)"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/#exercice-2-sujet-bns-2022-n28-ex-1","text":"\u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 1 2 3 4 5 def moyenne ( tab : list ) -> float : somme = 0 for t in tab : somme += t return t / len ( tab )","title":"Exercice 2 (Sujet BNS 2022 - n\u00b028, ex 1)"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/#exercice-3-sujet-bns-2022-n28-ex-2","text":"On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. Exemples: >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' Compl\u00e9ter le code ci-dessous. N'oubliez pas de convertir vos entiers en cha\u00eenes de caract\u00e8res avec la fonction str() . \u00c9nonc\u00e9 Correction 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while ... : bin_a = ... + bin_a a = ... return bin_a 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a","title":"Exercice 3 (Sujet BNS 2022 - n\u00b028, ex 2)"},{"location":"T07_Evaluations/Devoirs_Libres/DL3/#exercice-4","text":"Proposer une version r\u00e9cursive de la fonction dec_to_bin pr\u00e9c\u00e9dente. 1 2 3 4 5 def dec_to_bin_rec ( n ): if n // 2 == 0 : return str ( n % 2 ) else : return bin_rec ( n // 2 ) + str ( n % 2 )","title":"Exercice 4"},{"location":"T07_Evaluations/Devoirs_Libres/DL4/","text":"DL 0100: files d'attente \u2693\ufe0e Pour rappel, l'\u00e9nonc\u00e9 est ici (ex 7) Proposition de correction Il est n\u00e9cessaire d'avoir une classe File dans un fichier nomm\u00e9 TAD.py . import random from TAD import File ################## Simulation avec une seule file d'attente #################### def simul_file_unique ( nb_guichets , temps_attente_max , N ): dispo = nb_guichets * [ 0 ] cumul_temps_attente = 0 file = File () nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): file . enfiler ( arrivant ) for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not file . est_vide (): sortant = file . defiler () cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ###### Simulation avec une file d'attente par guichet, et choix al\u00e9atoire ###### def simul_alea ( nb_guichets , temps_attente_max , N ): dispo = nb_guichets * [ 0 ] cumul_temps_attente = 0 files = [ File () for _ in range ( nb_guichets )] nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): guichet = random . randint ( 1 , nb_guichets ) files [ guichet - 1 ] . enfiler ( arrivant ) for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not files [ k ] . est_vide (): sortant = files [ k ] . defiler () cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ####### Simulation avec une file d'attente par guichet et choix glouton ######## def simul_glouton ( nb_guichets , temps_attente_max , N ): cumul_temps_attente = 0 files = [ File () for _ in range ( nb_guichets )] taille_files = [ 0 for _ in range ( nb_guichets )] nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): i = taille_files . index ( min ( taille_files )) files [ i ] . enfiler ( arrivant ) taille_files [ i ] += 1 for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not files [ k ] . est_vide (): sortant = files [ k ] . defiler () taille_files [ k ] -= 1 cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ## Lancement et affichage des simulations nb_simul = 10000 tps_max = 5 nb_g = 5 print ( f \"Temps d'attente moyen avec une seule file : { simul_file_unique ( nb_g , tps_max , nb_simul ) } \" ) print ( f \"Temps d'attente moyen avec une file par guichet (al\u00e9atoire): { simul_alea ( nb_g , tps_max , nb_simul ) } \" ) print ( f \"Temps d'attente moyen avec une file par guichet (glouton): { simul_glouton ( nb_g , tps_max , nb_simul ) } \" )","title":"DL 0100: files d'attente"},{"location":"T07_Evaluations/Devoirs_Libres/DL4/#dl-0100-files-dattente","text":"Pour rappel, l'\u00e9nonc\u00e9 est ici (ex 7) Proposition de correction Il est n\u00e9cessaire d'avoir une classe File dans un fichier nomm\u00e9 TAD.py . import random from TAD import File ################## Simulation avec une seule file d'attente #################### def simul_file_unique ( nb_guichets , temps_attente_max , N ): dispo = nb_guichets * [ 0 ] cumul_temps_attente = 0 file = File () nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): file . enfiler ( arrivant ) for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not file . est_vide (): sortant = file . defiler () cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ###### Simulation avec une file d'attente par guichet, et choix al\u00e9atoire ###### def simul_alea ( nb_guichets , temps_attente_max , N ): dispo = nb_guichets * [ 0 ] cumul_temps_attente = 0 files = [ File () for _ in range ( nb_guichets )] nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): guichet = random . randint ( 1 , nb_guichets ) files [ guichet - 1 ] . enfiler ( arrivant ) for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not files [ k ] . est_vide (): sortant = files [ k ] . defiler () cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ####### Simulation avec une file d'attente par guichet et choix glouton ######## def simul_glouton ( nb_guichets , temps_attente_max , N ): cumul_temps_attente = 0 files = [ File () for _ in range ( nb_guichets )] taille_files = [ 0 for _ in range ( nb_guichets )] nb_clients_servis = 0 for arrivant in range ( 1 , N + 1 ): i = taille_files . index ( min ( taille_files )) files [ i ] . enfiler ( arrivant ) taille_files [ i ] += 1 for k in range ( nb_guichets ): if dispo [ k ] == 0 : if not files [ k ] . est_vide (): sortant = files [ k ] . defiler () taille_files [ k ] -= 1 cumul_temps_attente += arrivant - sortant dispo [ k ] = random . randint ( 1 , temps_attente_max ) nb_clients_servis += 1 else : dispo [ k ] -= 1 return cumul_temps_attente / nb_clients_servis ## Lancement et affichage des simulations nb_simul = 10000 tps_max = 5 nb_g = 5 print ( f \"Temps d'attente moyen avec une seule file : { simul_file_unique ( nb_g , tps_max , nb_simul ) } \" ) print ( f \"Temps d'attente moyen avec une file par guichet (al\u00e9atoire): { simul_alea ( nb_g , tps_max , nb_simul ) } \" ) print ( f \"Temps d'attente moyen avec une file par guichet (glouton): { simul_glouton ( nb_g , tps_max , nb_simul ) } \" )","title":"DL 0100: files d'attente"},{"location":"T07_Evaluations/Devoirs_Libres/DL5/","text":"DL 0101: AOC22 day 7 \u2693\ufe0e Lien vers l'activit\u00e9 Capytale Devoir \u00e0 faire et \u00e0 rendre ici : https://capytale2.ac-paris.fr/web/c/f1db-1133073 L'objectif de ce DL est de r\u00e9soudre l'\u00e9preuve du day 7 d'AOC 2022 . Les donn\u00e9es d'entr\u00e9e sont dans ce fichier . Strat\u00e9gie R\u00e9pr\u00e9senter les donn\u00e9es avec un mod\u00e8le adapt\u00e9. Parcourir le fichier pour construire les donn\u00e9es. Analyser les donn\u00e9es pour trouver la solution. Indications Lecture du fichier Repr\u00e9sentation des donn\u00e9es Parcours des donn\u00e9es Analyse des donn\u00e9es On lit le fichier et on r\u00e9cup\u00e8re les lignes dans une liste data (par ex.) avec: data = open ( \"input_day7.txt\" ) . read () . splitlines () On cr\u00e9e une classe Repertoire , qui poss\u00e8de 4 attributs (\u00e0 vous de les trouver) et plusieurs m\u00e9thodes: une m\u00e9thode pour ajouter un fichier au r\u00e9pertoire; une m\u00e9thode pour ajouter un (sous-)r\u00e9pertoire au r\u00e9pertoire; une m\u00e9thode pour calculer la taille du r\u00e9pertoire (m\u00e9thode r\u00e9cursive), qui correspond \u00e0 la somme de la taille de ses fichiers et des tailles de ses sous-r\u00e9pertoires; une m\u00e9thode pour r\u00e9cup\u00e8rer un sous-r\u00e9pertoire \u00e0 partir de son nom. On parcourt les donn\u00e9es pour construire l'arborescence du r\u00e9pertoire \u00abhome\u00bb \\ , en identifiant les actions \u00e0 effectuer en fonction de la cha\u00eene de caract\u00e8re sur chaque ligne. Penser \u00e0 g\u00e9rer le r\u00e9pertoire courant . Aide pour le parcours : compl\u00e9ter les actions \u00e0 effectuer en fonction de ce qui est lu dans le fichier (sachant qu'il n'y a rien \u00e0 faire si la commande est $ ls ) et que le else correspond au dernier cas non envisag\u00e9... 1 2 3 4 5 6 7 8 9 10 11 12 for line in data [ 1 :]: if line == '$ cd ..' : ... elif line [: 5 ] == '$ cd ' : dir_name = line . split ()[ - 1 ] ... elif line == '$ ls' : pass elif line [: 3 ] == 'dir' : ... else : ... Cr\u00e9er une fonction r\u00e9cursive qui prend en param\u00e8tre un r\u00e9pertoire, ajoute sa taille (si elle convient) \u00e0 une variable (de type list ) globale puis examine ses sous-dossiers de la m\u00eame fa\u00e7on. Aide pour la fonction r\u00e9cursive 1 2 3 4 5 6 7 8 9 10 11 tailles = [] def exploration ( rep : Repertoire ) -> None : t = rep . size () if t ... : tailles . append ( .. ) for sous_rep in ... : ... ( sous_rep ) exploration ( home ) print ( sum ( ... )) Test du programme Comme indiqu\u00e9 dans l'\u00e9nonc\u00e9 sur le site d'AOC 2022, avec le fichier d'entr\u00e9e d'exemple , vous devez obtenir deux valeurs (94853 et 584) pour une r\u00e9ponse finale de 95437.","title":"DL 0101: AOC22 day 7"},{"location":"T07_Evaluations/Devoirs_Libres/DL5/#dl-0101-aoc22-day-7","text":"Lien vers l'activit\u00e9 Capytale Devoir \u00e0 faire et \u00e0 rendre ici : https://capytale2.ac-paris.fr/web/c/f1db-1133073 L'objectif de ce DL est de r\u00e9soudre l'\u00e9preuve du day 7 d'AOC 2022 . Les donn\u00e9es d'entr\u00e9e sont dans ce fichier . Strat\u00e9gie R\u00e9pr\u00e9senter les donn\u00e9es avec un mod\u00e8le adapt\u00e9. Parcourir le fichier pour construire les donn\u00e9es. Analyser les donn\u00e9es pour trouver la solution. Indications Lecture du fichier Repr\u00e9sentation des donn\u00e9es Parcours des donn\u00e9es Analyse des donn\u00e9es On lit le fichier et on r\u00e9cup\u00e8re les lignes dans une liste data (par ex.) avec: data = open ( \"input_day7.txt\" ) . read () . splitlines () On cr\u00e9e une classe Repertoire , qui poss\u00e8de 4 attributs (\u00e0 vous de les trouver) et plusieurs m\u00e9thodes: une m\u00e9thode pour ajouter un fichier au r\u00e9pertoire; une m\u00e9thode pour ajouter un (sous-)r\u00e9pertoire au r\u00e9pertoire; une m\u00e9thode pour calculer la taille du r\u00e9pertoire (m\u00e9thode r\u00e9cursive), qui correspond \u00e0 la somme de la taille de ses fichiers et des tailles de ses sous-r\u00e9pertoires; une m\u00e9thode pour r\u00e9cup\u00e8rer un sous-r\u00e9pertoire \u00e0 partir de son nom. On parcourt les donn\u00e9es pour construire l'arborescence du r\u00e9pertoire \u00abhome\u00bb \\ , en identifiant les actions \u00e0 effectuer en fonction de la cha\u00eene de caract\u00e8re sur chaque ligne. Penser \u00e0 g\u00e9rer le r\u00e9pertoire courant . Aide pour le parcours : compl\u00e9ter les actions \u00e0 effectuer en fonction de ce qui est lu dans le fichier (sachant qu'il n'y a rien \u00e0 faire si la commande est $ ls ) et que le else correspond au dernier cas non envisag\u00e9... 1 2 3 4 5 6 7 8 9 10 11 12 for line in data [ 1 :]: if line == '$ cd ..' : ... elif line [: 5 ] == '$ cd ' : dir_name = line . split ()[ - 1 ] ... elif line == '$ ls' : pass elif line [: 3 ] == 'dir' : ... else : ... Cr\u00e9er une fonction r\u00e9cursive qui prend en param\u00e8tre un r\u00e9pertoire, ajoute sa taille (si elle convient) \u00e0 une variable (de type list ) globale puis examine ses sous-dossiers de la m\u00eame fa\u00e7on. Aide pour la fonction r\u00e9cursive 1 2 3 4 5 6 7 8 9 10 11 tailles = [] def exploration ( rep : Repertoire ) -> None : t = rep . size () if t ... : tailles . append ( .. ) for sous_rep in ... : ... ( sous_rep ) exploration ( home ) print ( sum ( ... )) Test du programme Comme indiqu\u00e9 dans l'\u00e9nonc\u00e9 sur le site d'AOC 2022, avec le fichier d'entr\u00e9e d'exemple , vous devez obtenir deux valeurs (94853 et 584) pour une r\u00e9ponse finale de 95437.","title":"DL 0101: AOC22 day 7"},{"location":"T07_Evaluations/Devoirs_Libres/DL5bis/","text":"DL 0101 (bis) : carr\u00e9s magiques \u2693\ufe0e Lien vers l'activit\u00e9 Capytale Devoir \u00e0 faire et \u00e0 rendre ici : https://capytale2.ac-paris.fr/web/c/ec89-1139771 Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. Le carr\u00e9 c4 n\u2019est en revanche pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter les fonctions somme_ligne et somme_colonne . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( ... ) def somme_colonne ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ ... ][ ... ] for ... in range ( self . ordre )]) Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 (une instance de Carre ) et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... 3. Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4.","title":"DL 0101 (bis) : carr\u00e9s magiques"},{"location":"T07_Evaluations/Devoirs_Libres/DL5bis/#dl-0101-bis-carres-magiques","text":"Lien vers l'activit\u00e9 Capytale Devoir \u00e0 faire et \u00e0 rendre ici : https://capytale2.ac-paris.fr/web/c/ec89-1139771 Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. Le carr\u00e9 c4 n\u2019est en revanche pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter les fonctions somme_ligne et somme_colonne . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( ... ) def somme_colonne ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ ... ][ ... ] for ... in range ( self . ordre )]) Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 (une instance de Carre ) et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... 3. Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4.","title":"DL 0101 (bis) : carr\u00e9s magiques"},{"location":"T07_Evaluations/Devoirs_Libres/DL6/","text":"DL 0110 \u2693\ufe0e","title":"DL 0110"},{"location":"T07_Evaluations/Devoirs_Libres/DL6/#dl-0110","text":"","title":"DL 0110"},{"location":"T07_Evaluations/Devoirs_Libres/accueil/","text":"Devoirs en temps libre \u2693\ufe0e Ces devoirs ont plusieurs objectifs: r\u00e9viser un ancien chapitre; pr\u00e9parer un nouveau chapitre pour gagner du temps en classe; s'exercer et progresser en vue des \u00e9preuves finales. Vous devez donc les travailler (ce qui ne signifie pas tout r\u00e9ussir \u00e0 chaque fois) de fa\u00e7on personnelle . Ce que je ne veux pas voir dans votre travail:","title":"Devoirs en temps libre"},{"location":"T07_Evaluations/Devoirs_Libres/accueil/#devoirs-en-temps-libre","text":"Ces devoirs ont plusieurs objectifs: r\u00e9viser un ancien chapitre; pr\u00e9parer un nouveau chapitre pour gagner du temps en classe; s'exercer et progresser en vue des \u00e9preuves finales. Vous devez donc les travailler (ce qui ne signifie pas tout r\u00e9ussir \u00e0 chaque fois) de fa\u00e7on personnelle . Ce que je ne veux pas voir dans votre travail:","title":"Devoirs en temps libre"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS1/","text":"DS 0001 \u2693\ufe0e","title":"DS 0001"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS1/#ds-0001","text":"","title":"DS 0001"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/","text":"DS 0010 - 20/10/2022 - Corrig\u00e9 \u2693\ufe0e Partie I \u2693\ufe0e Exercice 1 (tableaux/listes) \u2693\ufe0e \u00c9crire une fonction tranche qui prend en param\u00e8tre une liste lst et renvoie la liste priv\u00e9e de son premier \u00e9l\u00e9ment (c'est-\u00e0-dire d'indice 0) et de son dernier (c'est-\u00e0-dire d'indice len(lst)-1 ). Proposition de correction # Construction en extension def tranche ( lst : list ) -> list : nouvelle_liste = [] for k in range ( 1 , len ( lst ) - 1 ): nouvelle_liste . append ( lst [ k ]) return nouvelle_liste # Construction en compr\u00e9hension def tranche ( lst : list ) -> list : return [ lst [ k ] for k in range ( 1 , len ( lst ) - 1 )] Proposer un jeu de tests (c'est-\u00e0-dire des exemples d'appels pour tester la fonction, avec le r\u00e9sultat attendu pour chaque appel). Proposition de correction >>> tranche ([ 3 , 5 , 7 , 12 , 23 ]) [ 5 , 7 , 12 ] >>> tranche ([ 3 , 5 ]) [] >>> tranche ([ 3 ]) [] >>> tranche ([]) [] Exercice 2 (Programmation Orient\u00e9e Objet) \u2693\ufe0e Un coffre fort contient un montant d'argent. Ce montant est nul si le coffre est vide. Le coffre peut \u00eatre ouvert ou ferm\u00e9. Pour ouvrir le coffre, on doit saisir un code (entier \u00e0 4 chiffres), mais ce code n'est pas n\u00e9cessaire pour le fermer. Si le coffre est ouvert, on peut le consulter, y d\u00e9poser de l\u2019argent ou en retirer. Si le coffre est ferm\u00e9, ces op\u00e9rations sont impossibles. On ne peut pas retirer plus que ce que contient le coffre. D\u00e9crire la classe Coffre en pr\u00e9cisant ses attributs et ses m\u00e9thodes. Pr\u00e9ciser les types des attributs, des \u00e9ventuels param\u00e8tres des m\u00e9thodes et des valeurs \u00e9ventuellement renvooy\u00e9es par ces m\u00e9thodes. Proposition de correction Classe : Coffre Attributs: code: int ouvert: bool montant: int M\u00e9thodes: ouvrir( int ) -> None fermer() -> None consulter() -> str deposer( int ) -> str retirer( int ) -> str \u00c9crire un sc\u00e9nario utilisant cette classe pour tester les diff\u00e9rentes m\u00e9thodes. Proposition de correction >>> c = Coffre ( 1234 ) >>> c . consulter () 'Le coffre est ferm\u00e9.' >>> c . ouvrir ( 1238 ) Mauvais code >>> c . ouvrir ( 1234 ) Coffre ouvert >>> c . consulter () 'Le coffre contient un montant de 0.' >>> c . deposer ( 100 ) 'montant d\u00e9pos\u00e9: 100 ' >>> c . consulter () 'Le coffre contient un montant de 100.' >>> c . retirer ( 20 ) 'montant retir\u00e9: 20 ' >>> c . retirer ( 200 ) \"il n'y a pas assez d'argent dans le coffre\" >>> c . fermer () >>> c . deposer ( 50 ) 'montant d\u00e9pos\u00e9: 0' >>> c . retirer ( 30 ) 'montant retir\u00e9: 0' Partie II (machine) \u2693\ufe0e Exercice 1 (r\u00e9cursivit\u00e9) \u2693\ufe0e Un palindrome est un mot qui peut \u00eatre lu dans les deux sens de la m\u00eame fa\u00e7on. Par exemple, \u00abkayak\u00bb, \u00abradar\u00bb, \u00abgag\u00bb ou \u00abABBA\u00bb sont des palindromes, mais pas \u00abtoto\u00bb. \u00c9crire une fonction r\u00e9cursive est_palindrome qui prend en param\u00e8tre une cha\u00eene de caract\u00e8re et renvoie un bool\u00e9en qui d\u00e9termine si la cha\u00eene est un palindrome ou non. Exemples: >>> est_palindrome ( \"toto\" ) False >>> est_palindrome ( \"kayak\" ) True >>> est_palindrome ( \"\" ) True >>> est_palindrome ( \"abcdeedcba\" ) True Rappel: - on peut r\u00e9cup\u00e9rer les \u00e9lements d'une cha\u00eene de caract\u00e8res (type str ) comme un tableau, par leur indice. Par exemple, si mot est de type str , mot[0] renvoie le premier caract\u00e8re et mot[-1] le dernier. - pour obtenir une cha\u00eene de caract\u00e8res priv\u00e9e de son premier et de son dernier caract\u00e8re, on peut utiliser mot[1:-1] . Indication: r\u00e9fl\u00e9chir \u00e0 quelle condition sur la premi\u00e8re et la derni\u00e8re lettres un mot est un palindrome... Proposition de correction 1 2 3 4 5 6 7 def est_palindrome ( mot : str ) -> bool : if len ( mot ) == 0 : return True elif mot [ 0 ] != mot [ - 1 ]: return False else : return est_palindrome ( mot [ 1 : - 1 ]) Exercice 2 (POO) \u2693\ufe0e Un coffre fort contient un montant d'argent. Ce montant est nul si le coffre est vide. Le coffre peut \u00eatre ouvert ou ferm\u00e9. Pour ouvrir le coffre, on doit saisir un code (entier \u00e0 4 chiffres), mais ce code n'est pas n\u00e9cessaire pour le fermer. Si le coffre est ouvert, on peut le consulter, y d\u00e9poser de l\u2019argent ou en retirer. Si le coffre est ferm\u00e9, ces op\u00e9rations sont impossibles. On ne peut pas retirer plus que ce que contient le coffre. Compl\u00e9ter le code suivant pour impl\u00e9menter la classe Coffre . Remarque: enlever les pass au fur et \u00e0 mesure pour tester le code. Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Coffre : \"\"\" Une classe pour les coffres-forts attributs : ouvert : bool code : int contenu : float \"\"\" def __init__ ( self , c ) : \"\"\" Coffre(code) , cr\u00e9e un coffre ferm\u00e9 et vide, et c comme code d'ouverture \"\"\" self . code = c self . ouvert = False self . montant = 0 def ouvrir ( self , c ) -> None : \"\"\" met le coffre en etat ouvert, en v\u00e9rifiant le code c donn\u00e9. \"\"\" if c == self . code : self . ouvert = True print ( \"Coffre ouvert\" ) else : print ( \"Mauvais code\" ) def fermer ( self ) -> None : \"\"\" met le coffre en etat ferm\u00e9 \"\"\" self . ouvert = False def consulter ( self ) -> str : \"\"\" donne le contenu du coffre s'il est ouvert, 'coffre ferm\u00e9' sinon\"\"\" if self . ouvert : return f \"Le coffre contient un montant de { self . montant } .\" else : return \"Le coffre est ferm\u00e9.\" def deposer ( self , montant ) -> str : \"\"\" Ajoute le montant au contenu si le coffre est ouvert. Renvoie une cha\u00eene de caract\u00e8res pr\u00e9cisant le montant d\u00e9pos\u00e9 (0 si ferm\u00e9). \"\"\" if self . ouvert : self . montant += montant return f \"montant d\u00e9pos\u00e9: { montant } \" else : return \"montant d\u00e9pos\u00e9: 0\" def retirer ( self , montant ) -> str : \"\"\" Retire le montant du coffre s'il est ouvert. Renvoie une cha\u00eene de caract\u00e8res pr\u00e9cisant le montant retir\u00e9 (0 si ferm\u00e9). \"\"\" if self . ouvert : if montant <= self . montant : self . montant -= montant return f \"montant retir\u00e9: { montant } \" else : return \"il n'y a pas assez d'argent dans le coffre\" else : return \"montant retir\u00e9: 0\" Voir 2. de l'exercice 2 - Partie I.","title":"DS 0010 - 20/10/2022 - Corrig\u00e9"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#ds-0010-20102022-corrige","text":"","title":"DS 0010 - 20/10/2022 - Corrig\u00e9"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#partie-i","text":"","title":"Partie I"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#exercice-1-tableauxlistes","text":"\u00c9crire une fonction tranche qui prend en param\u00e8tre une liste lst et renvoie la liste priv\u00e9e de son premier \u00e9l\u00e9ment (c'est-\u00e0-dire d'indice 0) et de son dernier (c'est-\u00e0-dire d'indice len(lst)-1 ). Proposition de correction # Construction en extension def tranche ( lst : list ) -> list : nouvelle_liste = [] for k in range ( 1 , len ( lst ) - 1 ): nouvelle_liste . append ( lst [ k ]) return nouvelle_liste # Construction en compr\u00e9hension def tranche ( lst : list ) -> list : return [ lst [ k ] for k in range ( 1 , len ( lst ) - 1 )] Proposer un jeu de tests (c'est-\u00e0-dire des exemples d'appels pour tester la fonction, avec le r\u00e9sultat attendu pour chaque appel). Proposition de correction >>> tranche ([ 3 , 5 , 7 , 12 , 23 ]) [ 5 , 7 , 12 ] >>> tranche ([ 3 , 5 ]) [] >>> tranche ([ 3 ]) [] >>> tranche ([]) []","title":"Exercice 1 (tableaux/listes)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#exercice-2-programmation-orientee-objet","text":"Un coffre fort contient un montant d'argent. Ce montant est nul si le coffre est vide. Le coffre peut \u00eatre ouvert ou ferm\u00e9. Pour ouvrir le coffre, on doit saisir un code (entier \u00e0 4 chiffres), mais ce code n'est pas n\u00e9cessaire pour le fermer. Si le coffre est ouvert, on peut le consulter, y d\u00e9poser de l\u2019argent ou en retirer. Si le coffre est ferm\u00e9, ces op\u00e9rations sont impossibles. On ne peut pas retirer plus que ce que contient le coffre. D\u00e9crire la classe Coffre en pr\u00e9cisant ses attributs et ses m\u00e9thodes. Pr\u00e9ciser les types des attributs, des \u00e9ventuels param\u00e8tres des m\u00e9thodes et des valeurs \u00e9ventuellement renvooy\u00e9es par ces m\u00e9thodes. Proposition de correction Classe : Coffre Attributs: code: int ouvert: bool montant: int M\u00e9thodes: ouvrir( int ) -> None fermer() -> None consulter() -> str deposer( int ) -> str retirer( int ) -> str \u00c9crire un sc\u00e9nario utilisant cette classe pour tester les diff\u00e9rentes m\u00e9thodes. Proposition de correction >>> c = Coffre ( 1234 ) >>> c . consulter () 'Le coffre est ferm\u00e9.' >>> c . ouvrir ( 1238 ) Mauvais code >>> c . ouvrir ( 1234 ) Coffre ouvert >>> c . consulter () 'Le coffre contient un montant de 0.' >>> c . deposer ( 100 ) 'montant d\u00e9pos\u00e9: 100 ' >>> c . consulter () 'Le coffre contient un montant de 100.' >>> c . retirer ( 20 ) 'montant retir\u00e9: 20 ' >>> c . retirer ( 200 ) \"il n'y a pas assez d'argent dans le coffre\" >>> c . fermer () >>> c . deposer ( 50 ) 'montant d\u00e9pos\u00e9: 0' >>> c . retirer ( 30 ) 'montant retir\u00e9: 0'","title":"Exercice 2 (Programmation Orient\u00e9e Objet)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#partie-ii-machine","text":"","title":"Partie II (machine)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#exercice-1-recursivite","text":"Un palindrome est un mot qui peut \u00eatre lu dans les deux sens de la m\u00eame fa\u00e7on. Par exemple, \u00abkayak\u00bb, \u00abradar\u00bb, \u00abgag\u00bb ou \u00abABBA\u00bb sont des palindromes, mais pas \u00abtoto\u00bb. \u00c9crire une fonction r\u00e9cursive est_palindrome qui prend en param\u00e8tre une cha\u00eene de caract\u00e8re et renvoie un bool\u00e9en qui d\u00e9termine si la cha\u00eene est un palindrome ou non. Exemples: >>> est_palindrome ( \"toto\" ) False >>> est_palindrome ( \"kayak\" ) True >>> est_palindrome ( \"\" ) True >>> est_palindrome ( \"abcdeedcba\" ) True Rappel: - on peut r\u00e9cup\u00e9rer les \u00e9lements d'une cha\u00eene de caract\u00e8res (type str ) comme un tableau, par leur indice. Par exemple, si mot est de type str , mot[0] renvoie le premier caract\u00e8re et mot[-1] le dernier. - pour obtenir une cha\u00eene de caract\u00e8res priv\u00e9e de son premier et de son dernier caract\u00e8re, on peut utiliser mot[1:-1] . Indication: r\u00e9fl\u00e9chir \u00e0 quelle condition sur la premi\u00e8re et la derni\u00e8re lettres un mot est un palindrome... Proposition de correction 1 2 3 4 5 6 7 def est_palindrome ( mot : str ) -> bool : if len ( mot ) == 0 : return True elif mot [ 0 ] != mot [ - 1 ]: return False else : return est_palindrome ( mot [ 1 : - 1 ])","title":"Exercice 1 (r\u00e9cursivit\u00e9)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS2/#exercice-2-poo","text":"Un coffre fort contient un montant d'argent. Ce montant est nul si le coffre est vide. Le coffre peut \u00eatre ouvert ou ferm\u00e9. Pour ouvrir le coffre, on doit saisir un code (entier \u00e0 4 chiffres), mais ce code n'est pas n\u00e9cessaire pour le fermer. Si le coffre est ouvert, on peut le consulter, y d\u00e9poser de l\u2019argent ou en retirer. Si le coffre est ferm\u00e9, ces op\u00e9rations sont impossibles. On ne peut pas retirer plus que ce que contient le coffre. Compl\u00e9ter le code suivant pour impl\u00e9menter la classe Coffre . Remarque: enlever les pass au fur et \u00e0 mesure pour tester le code. Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Coffre : \"\"\" Une classe pour les coffres-forts attributs : ouvert : bool code : int contenu : float \"\"\" def __init__ ( self , c ) : \"\"\" Coffre(code) , cr\u00e9e un coffre ferm\u00e9 et vide, et c comme code d'ouverture \"\"\" self . code = c self . ouvert = False self . montant = 0 def ouvrir ( self , c ) -> None : \"\"\" met le coffre en etat ouvert, en v\u00e9rifiant le code c donn\u00e9. \"\"\" if c == self . code : self . ouvert = True print ( \"Coffre ouvert\" ) else : print ( \"Mauvais code\" ) def fermer ( self ) -> None : \"\"\" met le coffre en etat ferm\u00e9 \"\"\" self . ouvert = False def consulter ( self ) -> str : \"\"\" donne le contenu du coffre s'il est ouvert, 'coffre ferm\u00e9' sinon\"\"\" if self . ouvert : return f \"Le coffre contient un montant de { self . montant } .\" else : return \"Le coffre est ferm\u00e9.\" def deposer ( self , montant ) -> str : \"\"\" Ajoute le montant au contenu si le coffre est ouvert. Renvoie une cha\u00eene de caract\u00e8res pr\u00e9cisant le montant d\u00e9pos\u00e9 (0 si ferm\u00e9). \"\"\" if self . ouvert : self . montant += montant return f \"montant d\u00e9pos\u00e9: { montant } \" else : return \"montant d\u00e9pos\u00e9: 0\" def retirer ( self , montant ) -> str : \"\"\" Retire le montant du coffre s'il est ouvert. Renvoie une cha\u00eene de caract\u00e8res pr\u00e9cisant le montant retir\u00e9 (0 si ferm\u00e9). \"\"\" if self . ouvert : if montant <= self . montant : self . montant -= montant return f \"montant retir\u00e9: { montant } \" else : return \"il n'y a pas assez d'argent dans le coffre\" else : return \"montant retir\u00e9: 0\" Voir 2. de l'exercice 2 - Partie I.","title":"Exercice 2 (POO)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS5_corrige/","text":"DS 0101 - Corrig\u00e9 \u2693\ufe0e Devoir du 09/12/2022 Exercice 1 (8 points) \u2693\ufe0e On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables correspondant au diagramme relationnel suivant : On suppose que les dates sont donn\u00e9es sous la forme aaaa--mm-jj . \u00c9crire le sch\u00e9ma de la relation ordonnances . Souligner la cl\u00e9 primaire et marquer d'un # les cl\u00e9s \u00e9trang\u00e8res. ordonnances ( code Int , #id_patient Int, #matricule_medecin Int, date_ord Date, medicaments String) Donner l'instruction SQL permettant de cr\u00e9er la table/relation ordonnances . CREATE TABLE ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER REFERENCES Patients ( Id ), matricule_medecin INTEGER REFERENCES Medecins ( matricule ), date_ord DATE , medicaments TEXT ); Mme Anne Vegue, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Trouperdu doit \u00eatre enregistr\u00e9e comme patiente num\u00e9ro 1. Donner l'instruction SQL correspondante. INSERT INTO patients VALUES ( 1 , \"Vegue\" , \"Anne\" , \"F\" , 2000 ); Le patient num\u00e9ro 100 a chang\u00e9 de pr\u00e9nom et s'appelle maintenant \"Alice\". Donner l'instruction SQL modifiant en cons\u00e9quence ses donn\u00e9es. UPDATE patients SET prenom = 'Alice' WHERE id = 100 ; Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner l'instruction SQL permettant de supprimer leurs fiches. DELETE FROM medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Donner la requ\u00eate SQL permettant d'obtenir la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. SELECT p . nom , p . prenom FROM patients AS p JOIN ordonnances AS o ON p . id = o . id_patient JOIN medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"2020-04%\" ; Exercice 2 (12 points) \u2693\ufe0e On consid\u00e8re ci-dessous le diagramme de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Proposer un type de domaine SQL pertinent pour l'attribut cp de la table fournisseur . L'attribut cp doit \u00eatre repr\u00e9sent\u00e9 par un type VARCHAR ( 5 ) (ou CHAR ( 5 ) ). Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? SELECT prix_achat FROM produits WHERE nom_court = 'Liq_Vaiss_1L' ; Quelle requ\u00eate SQL donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? SELECT adresse , cp , ville FROM fournisseur WHERE nom = 'Avenir_confiseur' ; Quelle requ\u00eate SQL donne les noms des produits \u00e9tant en rupture de stock ? SELECT produits . nom FROM produits JOIN stocks ON produits . id = stocks . produit WHERE stocks . quantite = 0 ; Quelle requ\u00eate SQL donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb. SELECT nom FROM produits WHERE nom LIKE \"%ampoule%\" ; Quelle requ\u00eate SQL permet d'avoir le prix de vente moyen de ces ampoules ? SELECT AVG ( prix_vente ) FROM produits WHERE nom LIKE \"%ampoule%\" ; Quelle requ\u00eate SQL permet d'identifier le produit le plus cher du magasin ? SELECT nom FROM produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM produits ); Un tri sur le prix de vente par ordre d\u00e9croissant est accept\u00e9. Quelle requ\u00eate SQL renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) SELECT p . nom FROM produits AS p JOIN stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW ();","title":"DS 0101 - Corrig\u00e9"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS5_corrige/#ds-0101-corrige","text":"Devoir du 09/12/2022","title":"DS 0101 - Corrig\u00e9"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS5_corrige/#exercice-1-8-points","text":"On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables correspondant au diagramme relationnel suivant : On suppose que les dates sont donn\u00e9es sous la forme aaaa--mm-jj . \u00c9crire le sch\u00e9ma de la relation ordonnances . Souligner la cl\u00e9 primaire et marquer d'un # les cl\u00e9s \u00e9trang\u00e8res. ordonnances ( code Int , #id_patient Int, #matricule_medecin Int, date_ord Date, medicaments String) Donner l'instruction SQL permettant de cr\u00e9er la table/relation ordonnances . CREATE TABLE ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER REFERENCES Patients ( Id ), matricule_medecin INTEGER REFERENCES Medecins ( matricule ), date_ord DATE , medicaments TEXT ); Mme Anne Vegue, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Trouperdu doit \u00eatre enregistr\u00e9e comme patiente num\u00e9ro 1. Donner l'instruction SQL correspondante. INSERT INTO patients VALUES ( 1 , \"Vegue\" , \"Anne\" , \"F\" , 2000 ); Le patient num\u00e9ro 100 a chang\u00e9 de pr\u00e9nom et s'appelle maintenant \"Alice\". Donner l'instruction SQL modifiant en cons\u00e9quence ses donn\u00e9es. UPDATE patients SET prenom = 'Alice' WHERE id = 100 ; Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner l'instruction SQL permettant de supprimer leurs fiches. DELETE FROM medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Donner la requ\u00eate SQL permettant d'obtenir la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. SELECT p . nom , p . prenom FROM patients AS p JOIN ordonnances AS o ON p . id = o . id_patient JOIN medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"2020-04%\" ;","title":"Exercice 1 (8 points)"},{"location":"T07_Evaluations/Devoirs_Surveill%C3%A9s/DS5_corrige/#exercice-2-12-points","text":"On consid\u00e8re ci-dessous le diagramme de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Proposer un type de domaine SQL pertinent pour l'attribut cp de la table fournisseur . L'attribut cp doit \u00eatre repr\u00e9sent\u00e9 par un type VARCHAR ( 5 ) (ou CHAR ( 5 ) ). Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? SELECT prix_achat FROM produits WHERE nom_court = 'Liq_Vaiss_1L' ; Quelle requ\u00eate SQL donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? SELECT adresse , cp , ville FROM fournisseur WHERE nom = 'Avenir_confiseur' ; Quelle requ\u00eate SQL donne les noms des produits \u00e9tant en rupture de stock ? SELECT produits . nom FROM produits JOIN stocks ON produits . id = stocks . produit WHERE stocks . quantite = 0 ; Quelle requ\u00eate SQL donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb. SELECT nom FROM produits WHERE nom LIKE \"%ampoule%\" ; Quelle requ\u00eate SQL permet d'avoir le prix de vente moyen de ces ampoules ? SELECT AVG ( prix_vente ) FROM produits WHERE nom LIKE \"%ampoule%\" ; Quelle requ\u00eate SQL permet d'identifier le produit le plus cher du magasin ? SELECT nom FROM produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM produits ); Un tri sur le prix de vente par ordre d\u00e9croissant est accept\u00e9. Quelle requ\u00eate SQL renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) SELECT p . nom FROM produits AS p JOIN stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW ();","title":"Exercice 2 (12 points)"},{"location":"T08_Divers/01_GitHub/Github/","text":"","title":"Github"},{"location":"T08_Divers/Projets/Projet1/","text":"Projet 1 \u2693\ufe0e Sujet 1 : Life & Death \u2693\ufe0e \u00c9nonc\u00e9 On consid\u00e8re une grille - th\u00e9oriquement infinie - dont les cases appell\u00e9es cellules peuvent prendre deux \u00e9tats distincts : \u00abvivante\u00bb ou \u00abmorte\u00bb. Une cellule poss\u00e8de huit voisins : les cellules adjacentes horizontalement, verticalement et diagonalement. \u00c0 chaque g\u00e9n\u00e9ration, les cellules peuvent changer d'\u00e9tat ou conserver leur \u00e9tat selon les r\u00e8gles suivantes: si une cellule morte poss\u00e8de exactement 3 cellules voisines vivantes, alors elle devient vivante (elle na\u00eet); si une cellule vivante poss\u00e8de 2 ou 3 cellules vivantes, alors elle reste vivante, sinon elle meurt . L'objectif est de simuler, g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration, l'\u00e9tat de la grille. Exemple: 1 2 3 4 5 6 7 8 9 10 11 12 Consignes Utiliser le module pygame pour animer la grille g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration. L'\u00e9tat initial de la grille sera choisi al\u00e9atoirement. Le programme principal devra contenir deux classes: Grille et Cellule . La classe Grille contiendra une m\u00e9thode actualisation (ou update ) qui consistera \u00e0 actualiser l'\u00e9tat de la grille (c'est \u00e0 dire de chacune de ses cellules) ainsi qu'\u00e0 afficher la grille. La boucle des \u00e9v\u00e9nements sera donc r\u00e9duite \u00e0 (avec par exemple G instance de la classe Grille ): 1 2 3 4 5 6 7 8 9 continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () pygame . time . delay ( 100 ) Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import pygame import random as rd ## Classes class Cellule (): def __init__ ( self , t , l , c , e ): self . s = t self . ligne = l self . colonne = c self . x = self . s * c self . y = self . s * l self . etat = e self . etat_suivant = 0 self . nb_voisins = 0 def actualise_suivant ( self ): if ( self . etat == 0 and self . nb_voisins == 3 ) or ( self . etat == 1 and self . nb_voisins in { 2 , 3 }): self . etat_suivant = 1 else : self . etat_suivant = 0 def actualise_cellule ( self ): self . etat = self . etat_suivant def affiche_cellule ( self , ecran ): if self . etat : pygame . draw . rect ( ecran , ( 0 , 0 , 0 ), ( self . x , self . y , self . s , self . s )) else : pygame . draw . rect ( ecran , ( 255 , 255 , 255 ), ( self . x , self . y , self . s , self . s )) class Grille (): def __init__ ( self , l , h , t , e ): self . longueur = l self . hauteur = h self . taille_cellule = t self . ecran = e self . cellules = [[ Cellule ( self . taille_cellule , r , c , rd . randint ( 0 , 1 )) for c in range ( self . longueur )] for r in range ( self . hauteur )] def actualisation ( self ): for r in range ( self . hauteur ): for c in range ( self . longueur ): self . cellules [ r ][ c ] . nb_voisins = self . compte_voisins ( r , c ) self . cellules [ r ][ c ] . actualise_suivant () for r in range ( self . hauteur ): for c in range ( self . longueur ): self . cellules [ r ][ c ] . actualise_cellule () self . cellules [ r ][ c ] . affiche_cellule ( self . ecran ) def compte_voisins ( self , r , c ): n = 0 for d in [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )]: try : n += self . cellules [ r + d [ 0 ]][ c + d [ 1 ]] . etat except : pass return n ## initialisation pygame . init () ## Constantes longueur_grille , hauteur_grille = 640 , 480 taille_cellule = 10 taille = ( longueur_grille , hauteur_grille ) ## \u00c9cran fenetre = pygame . display . set_mode ( taille ) pygame . display . set_caption ( \"Jeu de la vie de John Conway\" ) ## Grille G = Grille ( longueur_grille // taille_cellule , hauteur_grille // taille_cellule , taille_cellule , fenetre ) ## Boucle des \u00e9v\u00e9nements continuer = False while not continuer : for evenement in pygame . event . get (): if evenement . type == pygame . QUIT : continuer = True G . actualisation () pygame . display . flip () pygame . time . delay ( 200 ) ## Fermeture de la fen\u00eatre pygame . quit () Sujet 2: Promenade d'une puce \u2693\ufe0e \u00c9nonc\u00e9 Une puce se prom\u00e8ne sur une grille dont les cases appell\u00e9es cellules peuvent \u00eatre blanches ou noires. Au d\u00e9part, toutes les cellules sont blanches et la puce se trouve au centre de la grille. La puce peut se d\u00e9placer horizontalement ou verticalement sur la grille de la fa\u00e7on suivante: si la puce se situe sur une cellule blanche, elle tourne de 90\u00b0 vers la droite, change la couleur de la case en noir et avance d'une case. si la puce se situe sur une cellule noire, elle tourne de 90\u00b0 vers la gauche, change la couleur de la case en blanc et avance d'une case. Consignes Utiliser le module pygame pour animer la grille g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration. Le programme principal devra contenir deux classes: Grille et Puce . La classe Grille contiendra une m\u00e9thode actualisation (ou update ) qui consistera \u00e0 actualiser l'\u00e9tat de la grille (c'est \u00e0 dire de la cellule o\u00f9 la puce est pass\u00e9e) ainsi qu'\u00e0 afficher la grille. La boucle des \u00e9v\u00e9nements sera donc r\u00e9duite \u00e0 (avec par exemple G instance de la classe Grille ): 1 2 3 4 5 6 7 8 continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import pygame from pygame.locals import * class Grille : def __init__ ( self , l : int , h : int ): self . longueur = l self . hauteur = h self . cellules = [ self . longueur * [ 1 ] for _ in range ( self . hauteur )] self . puce = Puce ( self . longueur // 2 , self . hauteur // 2 ) self . go = True def actualisation ( self ): l , c = self . puce . ligne , self . puce . colonne try : self . puce . avance ( self . cellules [ l ][ c ]) self . cellules [ l ][ c ] = 1 - self . cellules [ l ][ c ] pygame . draw . rect ( fenetre , [ 255 * self . cellules [ l ][ c ]] * 3 , [ l , c , 1 , 1 ]) pygame . draw . rect ( fenetre , [ 255 , 0 , 0 ], [ self . puce . ligne , self . puce . colonne , 1 , 1 ]) except : pass class Puce : directions = [( - 1 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 )] def __init__ ( self , l , c ): self . ligne = l self . colonne = c self . dir = 0 def avance ( self , cellule ): if cellule == 1 : self . dir = ( self . dir + 1 ) % 4 else : self . dir = ( self . dir - 1 ) % 4 self . ligne += Puce . directions [ self . dir ][ 0 ] self . colonne += Puce . directions [ self . dir ][ 1 ] pygame . init () longueur , hauteur = 320 , 240 fenetre = pygame . display . set_mode (( longueur , hauteur )) fenetre . fill ([ 255 , 255 , 255 ]) pygame . display . flip () G = Grille ( longueur , hauteur ) continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () pygame . quit ()","title":"Projet 1"},{"location":"T08_Divers/Projets/Projet1/#projet-1","text":"","title":"Projet 1"},{"location":"T08_Divers/Projets/Projet1/#sujet-1-life-death","text":"\u00c9nonc\u00e9 On consid\u00e8re une grille - th\u00e9oriquement infinie - dont les cases appell\u00e9es cellules peuvent prendre deux \u00e9tats distincts : \u00abvivante\u00bb ou \u00abmorte\u00bb. Une cellule poss\u00e8de huit voisins : les cellules adjacentes horizontalement, verticalement et diagonalement. \u00c0 chaque g\u00e9n\u00e9ration, les cellules peuvent changer d'\u00e9tat ou conserver leur \u00e9tat selon les r\u00e8gles suivantes: si une cellule morte poss\u00e8de exactement 3 cellules voisines vivantes, alors elle devient vivante (elle na\u00eet); si une cellule vivante poss\u00e8de 2 ou 3 cellules vivantes, alors elle reste vivante, sinon elle meurt . L'objectif est de simuler, g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration, l'\u00e9tat de la grille. Exemple: 1 2 3 4 5 6 7 8 9 10 11 12 Consignes Utiliser le module pygame pour animer la grille g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration. L'\u00e9tat initial de la grille sera choisi al\u00e9atoirement. Le programme principal devra contenir deux classes: Grille et Cellule . La classe Grille contiendra une m\u00e9thode actualisation (ou update ) qui consistera \u00e0 actualiser l'\u00e9tat de la grille (c'est \u00e0 dire de chacune de ses cellules) ainsi qu'\u00e0 afficher la grille. La boucle des \u00e9v\u00e9nements sera donc r\u00e9duite \u00e0 (avec par exemple G instance de la classe Grille ): 1 2 3 4 5 6 7 8 9 continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () pygame . time . delay ( 100 ) Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import pygame import random as rd ## Classes class Cellule (): def __init__ ( self , t , l , c , e ): self . s = t self . ligne = l self . colonne = c self . x = self . s * c self . y = self . s * l self . etat = e self . etat_suivant = 0 self . nb_voisins = 0 def actualise_suivant ( self ): if ( self . etat == 0 and self . nb_voisins == 3 ) or ( self . etat == 1 and self . nb_voisins in { 2 , 3 }): self . etat_suivant = 1 else : self . etat_suivant = 0 def actualise_cellule ( self ): self . etat = self . etat_suivant def affiche_cellule ( self , ecran ): if self . etat : pygame . draw . rect ( ecran , ( 0 , 0 , 0 ), ( self . x , self . y , self . s , self . s )) else : pygame . draw . rect ( ecran , ( 255 , 255 , 255 ), ( self . x , self . y , self . s , self . s )) class Grille (): def __init__ ( self , l , h , t , e ): self . longueur = l self . hauteur = h self . taille_cellule = t self . ecran = e self . cellules = [[ Cellule ( self . taille_cellule , r , c , rd . randint ( 0 , 1 )) for c in range ( self . longueur )] for r in range ( self . hauteur )] def actualisation ( self ): for r in range ( self . hauteur ): for c in range ( self . longueur ): self . cellules [ r ][ c ] . nb_voisins = self . compte_voisins ( r , c ) self . cellules [ r ][ c ] . actualise_suivant () for r in range ( self . hauteur ): for c in range ( self . longueur ): self . cellules [ r ][ c ] . actualise_cellule () self . cellules [ r ][ c ] . affiche_cellule ( self . ecran ) def compte_voisins ( self , r , c ): n = 0 for d in [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )]: try : n += self . cellules [ r + d [ 0 ]][ c + d [ 1 ]] . etat except : pass return n ## initialisation pygame . init () ## Constantes longueur_grille , hauteur_grille = 640 , 480 taille_cellule = 10 taille = ( longueur_grille , hauteur_grille ) ## \u00c9cran fenetre = pygame . display . set_mode ( taille ) pygame . display . set_caption ( \"Jeu de la vie de John Conway\" ) ## Grille G = Grille ( longueur_grille // taille_cellule , hauteur_grille // taille_cellule , taille_cellule , fenetre ) ## Boucle des \u00e9v\u00e9nements continuer = False while not continuer : for evenement in pygame . event . get (): if evenement . type == pygame . QUIT : continuer = True G . actualisation () pygame . display . flip () pygame . time . delay ( 200 ) ## Fermeture de la fen\u00eatre pygame . quit ()","title":"Sujet 1 : Life &amp; Death"},{"location":"T08_Divers/Projets/Projet1/#sujet-2-promenade-dune-puce","text":"\u00c9nonc\u00e9 Une puce se prom\u00e8ne sur une grille dont les cases appell\u00e9es cellules peuvent \u00eatre blanches ou noires. Au d\u00e9part, toutes les cellules sont blanches et la puce se trouve au centre de la grille. La puce peut se d\u00e9placer horizontalement ou verticalement sur la grille de la fa\u00e7on suivante: si la puce se situe sur une cellule blanche, elle tourne de 90\u00b0 vers la droite, change la couleur de la case en noir et avance d'une case. si la puce se situe sur une cellule noire, elle tourne de 90\u00b0 vers la gauche, change la couleur de la case en blanc et avance d'une case. Consignes Utiliser le module pygame pour animer la grille g\u00e9n\u00e9ration apr\u00e8s g\u00e9n\u00e9ration. Le programme principal devra contenir deux classes: Grille et Puce . La classe Grille contiendra une m\u00e9thode actualisation (ou update ) qui consistera \u00e0 actualiser l'\u00e9tat de la grille (c'est \u00e0 dire de la cellule o\u00f9 la puce est pass\u00e9e) ainsi qu'\u00e0 afficher la grille. La boucle des \u00e9v\u00e9nements sera donc r\u00e9duite \u00e0 (avec par exemple G instance de la classe Grille ): 1 2 3 4 5 6 7 8 continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () Proposition de correction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import pygame from pygame.locals import * class Grille : def __init__ ( self , l : int , h : int ): self . longueur = l self . hauteur = h self . cellules = [ self . longueur * [ 1 ] for _ in range ( self . hauteur )] self . puce = Puce ( self . longueur // 2 , self . hauteur // 2 ) self . go = True def actualisation ( self ): l , c = self . puce . ligne , self . puce . colonne try : self . puce . avance ( self . cellules [ l ][ c ]) self . cellules [ l ][ c ] = 1 - self . cellules [ l ][ c ] pygame . draw . rect ( fenetre , [ 255 * self . cellules [ l ][ c ]] * 3 , [ l , c , 1 , 1 ]) pygame . draw . rect ( fenetre , [ 255 , 0 , 0 ], [ self . puce . ligne , self . puce . colonne , 1 , 1 ]) except : pass class Puce : directions = [( - 1 , 0 ), ( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 )] def __init__ ( self , l , c ): self . ligne = l self . colonne = c self . dir = 0 def avance ( self , cellule ): if cellule == 1 : self . dir = ( self . dir + 1 ) % 4 else : self . dir = ( self . dir - 1 ) % 4 self . ligne += Puce . directions [ self . dir ][ 0 ] self . colonne += Puce . directions [ self . dir ][ 1 ] pygame . init () longueur , hauteur = 320 , 240 fenetre = pygame . display . set_mode (( longueur , hauteur )) fenetre . fill ([ 255 , 255 , 255 ]) pygame . display . flip () G = Grille ( longueur , hauteur ) continuer = True while continuer : for evenement in pygame . event . get (): if evenement . type == QUIT : continuer = False G . actualisation () pygame . display . flip () pygame . quit ()","title":"Sujet 2: Promenade d'une puce"},{"location":"T08_Divers/Projets/Projet2/","text":"","title":"Projet2"},{"location":"T09_Extras/Hachage/","text":"Fonctions de hachage \u2693\ufe0e Principe Une fonction de hachage a pour but de transformer une donn\u00e9e informatique en un condens\u00e9 (ou hash ) de sorte que: une m\u00eame donn\u00e9e donne toujours le m\u00eame condens\u00e9; le proc\u00e9d\u00e9 est irr\u00e9versible; deux donn\u00e9es diff\u00e9rentes ne doivent pas donner le m\u00eame condens\u00e9 (sinon on parle de collision ). \u00c0 quoi \u00e7a sert? Le condens\u00e9 d'une donn\u00e9e/d'un fichier sert \u00e0 le caract\u00e9riser , avec beaucoup moins de bits! signatures \u00e9lectroniques v\u00e9rifier l'int\u00e9grit\u00e9 s\u00e9curiser cr\u00e9er une blockchain... En ligne de commande ~$ echo -n \"la NSI, c'est de l'eau\" | md5sum 194f05d7fb42018fb798a395039e778c - ~$ echo -n \"la NSI, c'est de l'eau!\" | md5sum b8229a03e391dfc901a2e6c2f3a6e3cd - ~$ echo -n \"la NSI, c'est de l'eau!\" | sha256sum 1dae53cba7ff51a81d6a8a3a6c23935dcc9040f0c6a33058d8e12f025a4d7d29 - Avec Python On utilise le module hashlib qui contient les principaux algorithmes de hachage : MD5, SHA-1, SHA-256, etc. 1 2 3 4 5 6 7 8 import hashlib def hachage ( chaine : str ) -> str : ''' renvoie le condens\u00e9 de chaine en utilisant la fonction de hachage md5 du module hashlib. ''' return hashlib . md5 ( chaine . encode ()) . hexdigest ()","title":"Hachage"},{"location":"T09_Extras/Hachage/#fonctions-de-hachage","text":"Principe Une fonction de hachage a pour but de transformer une donn\u00e9e informatique en un condens\u00e9 (ou hash ) de sorte que: une m\u00eame donn\u00e9e donne toujours le m\u00eame condens\u00e9; le proc\u00e9d\u00e9 est irr\u00e9versible; deux donn\u00e9es diff\u00e9rentes ne doivent pas donner le m\u00eame condens\u00e9 (sinon on parle de collision ). \u00c0 quoi \u00e7a sert? Le condens\u00e9 d'une donn\u00e9e/d'un fichier sert \u00e0 le caract\u00e9riser , avec beaucoup moins de bits! signatures \u00e9lectroniques v\u00e9rifier l'int\u00e9grit\u00e9 s\u00e9curiser cr\u00e9er une blockchain... En ligne de commande ~$ echo -n \"la NSI, c'est de l'eau\" | md5sum 194f05d7fb42018fb798a395039e778c - ~$ echo -n \"la NSI, c'est de l'eau!\" | md5sum b8229a03e391dfc901a2e6c2f3a6e3cd - ~$ echo -n \"la NSI, c'est de l'eau!\" | sha256sum 1dae53cba7ff51a81d6a8a3a6c23935dcc9040f0c6a33058d8e12f025a4d7d29 - Avec Python On utilise le module hashlib qui contient les principaux algorithmes de hachage : MD5, SHA-1, SHA-256, etc. 1 2 3 4 5 6 7 8 import hashlib def hachage ( chaine : str ) -> str : ''' renvoie le condens\u00e9 de chaine en utilisant la fonction de hachage md5 du module hashlib. ''' return hashlib . md5 ( chaine . encode ()) . hexdigest ()","title":"Fonctions de hachage"},{"location":"T09_Extras/Trucs/","text":"Trucs \u2693\ufe0e","title":"Trucs"},{"location":"T09_Extras/Trucs/#trucs","text":"","title":"Trucs"}]}