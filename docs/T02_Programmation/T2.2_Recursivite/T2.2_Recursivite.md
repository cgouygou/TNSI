# T2.2 Récursivité

{{ initexo(0) }}

Voir [ici](https://cgouygou.github.io/TNSI/T02_Programmation/T2.2_Recursivite/T2.2_Recursivite/)


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>



Dans le même état d'esprit, chez Google:

![](../images/recursivite_google.png){: .center} 

## 2.2.1 Principe 

En règle générale, un objet est dit récursif s'il se définit à partir de lui-même. On trouve donc des acronymes récursifs, comme GNU dans GNU/Linux (GNU is Not Unix), le logiciel d'émulation WINE (Wine Is Not an Emulator), les cartes bancaire VISA (Visa International Service Association), le moteur de recherche Bing (Bing is not Google), etc.

Mais aussi des images illustrant la mise en abîme:

![](../images/meme_drake_recursivite.png){: .center width=480} 

En informatique, on parle de programme récursif ou plutôt de fonction récursive:

!!! abstract "Définition"
    Une fonction **récursive** est une fonction qui s'appelle elle-même dans sa propre définition.

    Un programme est récursif lorsqu'il fait intervenir une fonction récursive (ou plusieurs).


## 2.2.2 Premiers exemples et précautions d'usage

!!! note "No infinite recursion !"
    Voici trois premiers exemples de fonctions récursives. Dans chaque cas, repérer l'appel récursif à la fonciton.
    
    Une seule de ces 3 fonctions est correcte, laquelle?

    === "Fonction 1"
        ```python linenums='1'
        def f(n):
            print(n)
            f(n-1)
            print("Hello world!")
        ```
    === "Fonction 2"
        ```python linenums='1'
        def f(n):
            if n == 0:
                print("Hello world!")
            else:
                print(n)
                f(n-1)
        ```
    === "Fonction 3"
    ```python linenums='1'
        def f(n):
            if n == 0:
                print("Hello world!")
            else:
                print(n)
                f(n)
    ```

!!! warning "Cas de base"
    Lorsqu'on écrit une fonction récursive, le piège classique est de créer une **boucle infinie**.
    
    Hormis les blaques ~~de geeks~~  d'initiés, la récursivité en informatique ne tolère pas l'auto-référence infinie: **il faut prévoir une condition d'arrêt qui traite le cas de base !!!**

    ![](../images/meme_gru_recursivite.jpg){: .center width=640} 

!!! warning "Terminaison"
    Pour s'assurer qu'une fonction récursive se termine, il faut **absolument** que la chaîne d'appel conduise au cas de base. 

    - si le paramètre de la fonction est un entier, alors l'appel doit se faire avec un **entier strictement inférieur**;
    - si le paramètre de la fonction est une liste, alors l'appel doit se faire avec une liste de **longueur strictement inférieure**;
    - etc.


!!! note "Exemples à connaître"
    === "Somme des n premiers entiers"
        On souhaite calculer la somme suivante:  $S = 0 + 1 + 2 + 3 + \dots + (n-1) + n$

        En première, on a vu comment construire une fonction *itérative* le permettant, à l'aide d'une boucle `for` (doù le terme *itératif*) et d'une variable accumulatrice:

        ```python linenums='1'
        def somme(n):
            s = 0
            for k in range(n+1):
                s += k
            return s
        ```
        
        Une autre façon de voir le problème, c'est de se dire que cette somme peut s'écrire $S = n + (n-1) + \dots + 3 + 2 + 1 + 0$ et que c'est la somme de $n$ et **de la somme des $n-1$ premiers entiers** : $S = n + \underbrace{(n-1) + \dots + 3 + 2 + 1 + 0}_{\text{somme des entiers jusqu'à } n-1}$.

        On écrit alors de façon «assez naturelle» la fonction récursive suivante:

        ```python linenums='1'
        def somme_rec(n):
            if n == 0:
                return 0
            else:
                return n + somme(n-1)
        ```

    === "Factorielle"
        En mathématiques, la factorielle d'un nombre entier $n$, notée $n!$, est le produit de tous les entiers positifs non nuls inférieurs ou égaux à $n$.

        Autrement dit, $n! = 1 \times 2 \times 3 \times \dots \times (n-1) \times n = n \times (n-1)  \times \dots \times 3 \times 2 \times 1$.

        !!! example "{{ exercice() }}"
            === "Énoncé" 
                S'inspirer des fonctions `somme` et `somme_rec` pour écrire deux fonctions `facto` (itérative) et `facto_rec` (récursive) renvoyant la factorielle d'un nombre entier `n` strictement positif.
            === "Correction" 
                {{ correction(False, 
                "
                ```python linenums='1'
                def facto(n):
                    f = 1
                    for k in range(1, n+1):
                        f *= k
                    return f
                
                def facto_rec(n):
                    if n == 1:
                        return 1
                    else:
                        return n * facto_rec(n-1)
                ```
                
                "
                ) }}
        

## 2.2.3 Mécanisme

## 2.2.4 Exercices

!!! example "{{ exercice() }}"
    === "Énoncé" 
        Écrire une fonction récursive `puissance(x, n)` qui renvoie le nombre $x^n$.
    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}