# T3.1 Diviser pour régner

{{ initexo(0) }}


!!! gear "Principe"
    La méthode **diviser pour régner** (en anglais *divide and conquer*) est une technique algorithmique de résolution d'un problème qui consiste à :

    1. décomposer le problème initial en (un ou) plusieurs sous-problèmes de taille
    **inférieure** et **indépendants**;
    2. résoudre chacun des sous-problèmes;
    3. combiner (éventuellement) les solutions des sous-problèmes pour obtenir la solution au problème initial.

    La plupart du temps la résolution des sous-problèmes se fait de façon **récursive**.


??? question "Une impression de «déjà-vu»?"
    Nous avons déjà utilisé cette technique. Par exemple:

    - en première en étudiant la recherche dichotomique dans une liste triée;
    - en terminale en étudiant les algorithmes sur les arbres binaires.

    Un autre exemple ? Dès le DS 0001:

    ```python linenums='1' title='Exponentiation rapide'
    def puissance(x:float, n:int) -> float :
        if n == 0 :
            return  1
        else :
            if n%2 == 0:
                return puissance(x*x, n//2)
            else :
                return  x * puissance(x**2, (n-1)//2)
    ```
    
Nous allons mettre en œuvre cette méthode sur quelques problèmes classiques...

## 1. Le tri fusion

!!! gear "Algorithme du tri fusion (*merge sort*)"
    === "Principe"
        L'algorithme du tri fusion consiste à:

        1. couper le tableau à trier en deux moitiés;
        2. trier indépendammment en place chaque moitié;
        3. fusionner (*to merge*) les deux moitiés triées.

    === "Illustration en vidéo"
        <p align="center">
        <iframe width="640" height="360" src="https://www.youtube.com/embed/dENca26N6V4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </p>
        
    === "Illustration en notice"
        ![](../images/merge_sort_ikea.png){: .center} 

    === "Illustration en GIF"

        <p align="center">
        <gif-player src="https://cgouygou.github.io/TNSI/T03_Algorithmique/images/gif_fusion.gif" speed="1" play></gif-player>
        </p>

        *Source: Gilles Lassus*



!!! code "Partie I: la fusion / *merge*"
    On veut pouvoir fusionner deux listes triées. Pour cela on construit une nouvelle liste, dans laquelle on ajoute successivement le minimum des plus petits éléments des deux listes. Il faut donc gérer deux indices: un pour chaque liste, où l'indice correspond à l'élément à comparer.

    ```python linenums='1'
    def fusion(tab1:list, tab2:list) -> list:
        tab_fusion = []
        i1 = 0
        i2 = 0
        # Tant qu'il reste des éléments à comparer dans les deux listes
        while ...:
            if tab1[i1] < tab2[i2]:
                tab_fusion.append( ...)
                ...
            else:
                ...
                ...

        # Une fois qu'une des deux listes est totalement traitée, on complète avec ce 
        # qu'il reste dans l'autre
        if i1 == len(tab1):
            while ...:
                ...
                ...
        else:
            while ...:
                ...
                ...        

        return 

    ```

    Pouvez-vous estimer la complexité de cette fonction?
    

!!! code "Partie II: le tri / *sort*"
    Reprenons l'algorithme du tri fusion: il faut d'abord couper le tableau en deux moitiés. On va utiliser les deux fonctions ci-dessous dont la liste renvoyée est à compléter en compréhension:

    ```python linenums='1'
    def moitie_gauche(lst:list) -> list:
        m = len(lst) // 2
        return [lst[k] for k in range(...)]

    def moitie_droite(lst:list, m:int):
        m = len(lst) // 2
        return [lst[k] for k in range(...)]
    ```
    
    Maintenant écrivons la fonction `tri_fusion` à proprement parler, qui va fusionner les deux moitiés de la liste qui ont été triées par fusion:

    ```python linenums='1'
    def tri_fusion(lst:list) -> list:
        if len(lst) <= 1:
            return ...
        else:
            lst1 = ...
            lst2 = ...
            return fusion(..., ...)
    ```

Il est à noter que cette version du tri fusion ne trie pas *en place*, c'est-à-dire que la liste initiale à trier n'est pas modifiée et qu'une nouvelle liste, triée, est créée par la fonction `tri_fusion`. Exactement comme le fait la fonction `sorted` de Python.

```python
>>> lst = [3, 4, 1, 6, 8, 7, 2]
>>> tri_fusion(lst)
[1, 2, 3, 4, 6, 7, 8]
>>> lst
[3, 4, 1, 6, 8, 7, 2]
```

On peut faire en sorte que le tri fusion trie *en place* une liste (comme la méthode `sort` de Python), c'est-à-dire qu'aucune autre liste ne sera créée, mais la liste initiale aura été triée.

On veut alors plutôt ce genre de comportement:
```python 
>>> lst = [3, 4, 1, 6, 8, 7, 2]
>>> tri_fusion(lst)
>>> lst
[1, 2, 3, 4, 6, 7, 8]
```

Pour cela, on utilise le caractère mutable d'une liste. Il faut faire en sorte de passer la liste en paramètre de la fonction `fusion` et de remplacer ses éléments un à un (plutôt que de créer une liste vide puis de la peupler), en gérant un indice de plus.

```python linenums='1' title='Fusion en place'
def fusion(lst, lst1, lst2):
    i, i1, i2 = 0, 0, 0
    while i1 < len(lst1) and i2 < len(lst2):
        if lst1[i1] < lst2[i2]:
            lst[i] = lst1[i1]
            i1 += 1
        else:
            lst[i] = lst2[i2]
            i2 += 1
        i += 1                  # indice pour lst
    if i1 == len(lst1):
        while i2 < len(lst2):
            lst[i] =  lst2[i2]
            i2 += 1
            i += 1              # indice pour lst
    else:
        while i1 < len(lst1):
            lst[i] = lst1[i1]
            i1 += 1
            i += 1              # indice pour lst
```

La fonction `tri_fusion` se modifie alors ainsi:

```python linenums='1' title='Tri fusion en place'
def tri_fusion(lst:list):
    if len(lst) > 1:
        lst1 = moitie_gauche(lst)
        lst2 = moitie_droite(lst)
        tri_fusion(lst1)
        tri_fusion(lst2)
        fusion(lst, lst1, lst2)

```



!!! example "{{ exercice() }}"
    === "Énoncé" 
        En s'inspirant de ce qui a été fait en classe de première sur le [tri par sélection](https://cgouygou.github.io/1NSI/T07_Algorithmes/T7.1_Tri_selection/T7.1_Tri_selection/){:target="_blank"} , mesurer le temps d'exécution pour plusieurs tailles de listes construites aléatoirement (ou pas, à vous de voir) et construire un graphique pour estimer la complexité du tri fusion.
    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}

## 2. Le tri rapide

!!! gear "Algorithme du tri rapide (*quick sort*)"
    === "Principe"
        L'algorithme du tri rapide consiste à:

        1. choisir une valeur pivot (le premier élément, le dernier, au hasard...);
        2. placer tous les éléments plus petits que le pivot avant les éléments qui sont plus grands que le pivot;
        3. trier récursivement chacune des deux parties.

    === "Illustration en vidéo"
        <p align="center">
        <iframe width="640" height="360" src="https://www.youtube.com/embed/3San3uKKHgg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </p>

    === "Illustration en notice"
        ![](../images/quick_sort_ikea.png){: .center} 


!!! code "Partie I : le tri"
    Un peu comme le tri fusion, la fonction de tri à proprement parler n'est pas très compliquée à écrire: elle suit l'algorithme donné à la lettre.
    
    Si on dispose d'une fonction `partition` qui procède aux échanges successifs des éléments de la liste entre deux indices et qui renvoie la position du pivot (qui est nécessairement bien placé à l'issue de ce partitionnement), on obtient le code suivant:

    ```python linenums='1'
    def tri_rapide(lst:list, indice_gauche:int, indice_droit:int):
        if indice_gauche < indice_droit:
            indice_pivot = partition(lst, indice_gauche, indice_droit)
            tri_rapide(lst, indice_gauche, indice_pivot-1)
            tri_rapide(lst, indice_pivot+1, indice_droit)
    ```
    
!!! code "Partie II: la partition"
    L'étape délicate du tri rapide est celle qui consiste à réaliser le partitionnement de la liste à trier en 3 parts:

    - les éléments inférieurs au pivot;
    - le pivot;
    - les éléments supérieurs au pivot.

    Il faut noter qu'une fois partitionnée, le pivot est nécessairement à sa position définitive, c'est l'intérêt de cet algorithme...

    Il existe plusieurs façons de réaliser ce partitionnement, et plusieurs façons de choisir le pivot. Nous choisirons systématiquement le pivot en dernière position et échangerons les valeurs inférieures au pivot en gérant leur indice d'échange. Une fois toutes les valeurs de la liste parcourues (et éventuellement échangées), cet indice d'insertion désigne celui du pivot, un dernier échange interviendra.

    Compléter le code suivant:

    ```python linenums='1'
    
    def partition(lst:list, indice_gauche:int, indice_droit:int) -> int:
        '''
        - échange les éléments de lst selon leur ordre par rapport au pivot
        - place le pivot à son indice définitif
        - renvoie l'indice du pivot
        '''
        pivot = lst[...] # on choisit comme pivot le dernier élément
        i = ...          # i est l'indice d'échange
        for j in range(indice_gauche, indice_droit):
            if lst[j] <= pivot:
                echange(lst, ..., ...)
                ...
        #Une fois tous les échanges possibles réalisés, le pivot doit se trouver en
        #position i, donc on l'échange et on renvoie cet indice
        echange(lst, ...)
        return ...
    ```

    <!-- https://www.youtube.com/watch?v=MZaf_9IZCrc -->

!!! example "{{ exercice() }}"
    === "Énoncé" 
        Il manque la fonction `echange`... Écrivez-la.
    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}

!!! example "{{ exercice() }}"
    === "Énoncé" 
        Même question qu'à l'exercice 1 sur le tri fusion...
    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}

## 3. Quart de tour d'une image

## 4. Génération d'un labyrinthe

