# T1.5.1 Parcours de graphes

{{ initexo(0) }}


!!! gear "Algorithme de parcours"
    Un parcours de graphe est un algorithme consistant à explorer les sommets d'un graphe de proche
    en proche à partir d'un sommet initial.

    :warning: Parcourir simplement le dictionnaire ou la matrice d’un
    graphe n’est pas considéré comme un
    parcours de graphe.


    Tous les parcours suivent plus ou moins le même algorithme de base :

    - On visite un sommet s1. On note S l’*ensemble* des voisins de s1.

    - Tant que S n’est pas vide :
    
        - on choisit un sommet s de S
        - on visite s
        - on ajoute à S tous les voisins de s **pas encore visités**



!!! warning "Sommets visités"
    Contrairement à un parcours d'arbre, où les fils d'un nœud ne peuvent pas avoir été visités avant le nœud, un voisin d'un sommet peut avoir déjà été visité en tant que voisin d'un sommet précédent...

    Il est donc nécessaire de mémoriser les sommets déja visités ou découverts (on dira qu'un sommet est découverts lorsqu'on l'ajoute à S).


Le choix de la structure de l'ensemble S est prépondérant:

- Si on choisit une **file** (FIFO): on visitera les sommets dans l'ordre d'arrivée, donc les plus proches du sommet précédent. On obtient donc un *parcours en largeur*.
- Si on choisit une **pile** (LIFO): on visitera d'abord les derniers sommets arrivés, donc on parcourt le graphe en visitant à chaque étape un voisin du précédent. On obtient donc un *parcours en profondeur*.

## 1. Parcours en largeur (BFS, Breadth First Search)

!!! gear "Algorithme BFS"
    C'est classiquement celui qu'on utilise pour trouver le chemin le plus court dans un graphe.

    **Exemple de parcours en largeur, avec B comme sommet de départ:**

    <gif-player src="https://cgouygou.github.io/TNSI/T01_StructuresDonnees/images/bfs.gif" speed="1" play></gif-player>

    On adapte l'algorithme donné plus haut, en utilisant:

    - une liste `#!py visites` qui contient les sommets visités (c'est-à-dire qu'on a finit de traiter, ici après avoir ajouté ses voisins);
    - une liste `#!py decouverts` qui contient les sommets découverts (c'est-à-dire les voisins du sommet en cours de traitement);
    - une file `#!py file` qui contient les sommets découverts mais non encore visités. On utilisera au choix une classe `File` écrite plus tôt dans l'année ou tout simplement une `#!py list` avec les méthodes `#!py pop` (pour défiler) et `#!py append` (pour enfiler).

    En début d'algorithme, seul le sommet de départ `#!py depart` donné en paramètre est découvert. La fonction `BFS` renvoie la liste des sommets dans l'ordre de visite lors du parcours.

    ```python linenums='1' title='Code à compléter'
    def BFS(g:Graphe, depart:str) -> list:
        '''
        Effectue un parcours en largeur du graphe G en partant du sommet depart,
        et renvoie la liste des sommets visités dans l'ordre du parcours.
        '''
        visites = []
        decouverts = [...]
        file = [...]
        while file ... :
            sommet = ...
            for voisin in ...:
                if voisin not in ...:
                    ...
                    ...
            visites.append(...)
        return ...
    
    ```

!!! example "Application: existence de chemin" 
    L'objectif est de retrouver une chaine ou un chemin dans un graphe entre un sommet source et un sommet cible, s'il existe.

    L'idée est d'ajouter dans le parcours en profondeur un dictionnaire de «parentalité»: un dictionnaire dont les clés sont les sommets découverts et la valeur associée est le sommet «père», c'est-à-dire celui à partir duquel il est découvert.

    Ensuite, il faut reconstituer le chemin en remontant de la cible à la source en utilisant ce dictionnaire.

    1. Commencer par écrire une fonction `chemin` qui prend en paramètre un graphe, un sommet source et un sommet cible, et qui renvoie le chemin entre la source et la cible (par exemple sous forme d'une chaîne de caractères).

    2. Modifier la fonction BFS en ajoutant le dictionnaire `parents` et en modifiant la valeur renvoyée: le chemin s'il existe, `#!py None` (ou un message mentionnant qu'il n'existe pas) sinon.

## 2. Parcours en profondeur (DFS, Depth First Search)



## 3. Exercices

!!! example "{{ exercice() }}"
    === "Énoncé" 
        Écrire une fonction (ou une méthode) `#!py est_connexe` qui détermine si un graphe est connexe ou non.
    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}

!!! example "{{ exercice() }}"
    === "Énoncé" 
        !!! info "Rappel"
            Un graphe est **eulérien** s'il est connexe et s'il possède exactement 0 ou 2 sommets de degré impair (le degré de sommet est son nombre de voisins).

        Écrire une fonction (ou une méthode) `#!py est_eulerien` qui détermine si un graphe est eulérien ou non.

    === "Correction" 
        {{ correction(False, 
        "
        "
        ) }}